{"UNKNOWN to If":[{"Line": "=>69", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (org.jppf.comm.socket.QueuingSocketInitializer.log.isTraceEnabled()) org.jppf.comm.socket.QueuingSocketInitializer.log.trace(e.toString());", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/2878/buggy-version/common.src.java.org.jppf.comm.socket.QueuingSocketInitializer.java", "BodyUseAPI": ["org.jppf.comm.socket.Logger.trace(java.lang.String)"], "Fixed commit": "32cab76153d2201cd4a30c619a4a366aaa637196", "Url": "https://api.github.com/repos/jppf-grid/JPPF", "Date": "2018-12-18T07:35:57Z", "Source Code Diff": "@@ -65,8 +65,9 @@ public Boolean call() throws Exception {\n       return f.get();\n     } catch (final Exception e) {\n       if (lastException == null) lastException = e;\n-      if (e instanceof InterruptedException) log.warn(e.toString());\n-      else log.error(e.getMessage(), e);\n+      if ((e instanceof InterruptedException)) {\n+        if (log.isTraceEnabled()) log.trace(e.toString());\n+      } else log.error(e.getMessage(), e);\n     }\n     return false;\n   }", "Complete After Code": "/*\n * JPPF.\n * Copyright (C) 2005-2018 JPPF Team.\n * http://www.jppf.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jppf.comm.socket;\n\nimport java.util.concurrent.*;\n\nimport org.jppf.utils.*;\nimport org.jppf.utils.concurrent.JPPFThreadFactory;\nimport org.slf4j.*;\n\n/**\n * This implementation uses a fixed thread pool in an attempt at reducing the JDK-level contentions triggered by\n * {@code SockerChannel.open()} and {@code SockerChannel.connect()}, when creating and connecting many channels concurrently.\n * @author Laurent Cohen\n */\nclass QueuingSocketInitializer extends SocketInitializerImpl {\n  /**\n   * Logger for this class.\n   */\n  private static final Logger log = LoggerFactory.getLogger(QueuingSocketInitializer.class);\n  /**\n   * Performs connection initializations asynchronously using threads with TTL.\n   */\n  private static final ExecutorService executor = initExecutor();\n\n  /**\n   * Instantiate this SocketInitializer with the global JPPF configuration.\n   */\n  public QueuingSocketInitializer() {\n    super(JPPFConfiguration.getProperties());\n  }\n\n  /**\n   * Instantiate this SocketInitializer with a specified configuration.\n   * @param config the configuration to use.\n   */\n  QueuingSocketInitializer(final TypedProperties config) {\n    super(config);\n  }\n\n  @Override\n  public boolean initialize(final SocketWrapper socketWrapper) {\n    final Future<Boolean> f = executor.submit(new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        return QueuingSocketInitializer.super.initialize(socketWrapper);\n      }\n    });\n    try {\n      return f.get();\n    } catch (final Exception e) {\n      if (lastException == null) lastException = e;\n      if ((e instanceof InterruptedException)) {\n        if (log.isTraceEnabled()) log.trace(e.toString());\n      } else log.error(e.getMessage(), e);\n    }\n    return false;\n  }\n\n  /**\n   * @return an {@link ExecutorService}.\n   */\n  private static ExecutorService initExecutor() {\n    final TypedProperties config = JPPFConfiguration.getProperties();\n    final long ttl = config.getLong(\"jppf.socket.initializer.thread.ttl\", 5000L);\n    final ThreadPoolExecutor tpe = new ThreadPoolExecutor(1, Integer.MAX_VALUE, ttl, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), new JPPFThreadFactory(\"SocketInitializer\"));\n    tpe.allowCoreThreadTimeOut(true);\n    return tpe;\n  }\n}\n"},
{"Line": "=>140", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((mbsc) != null) mbsc.close();", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/2878/buggy-version/jmxremote-nio.src.java.org.jppf.jmxremote.JPPFJMXConnector.java", "BodyUseAPI": [], "Fixed commit": "32cab76153d2201cd4a30c619a4a366aaa637196", "Url": "https://api.github.com/repos/jppf-grid/JPPF", "Date": "2018-12-18T07:35:57Z", "Source Code Diff": "@@ -137,7 +137,7 @@ public MBeanServerConnection getMBeanServerConnection(final Subject delegationSu\n \n   @Override\n   public void close() throws IOException {\n-    mbsc.close();\n+    if (mbsc != null) mbsc.close();\n   }\n \n   @Override", "Complete After Code": "/*\n * JPPF.\n * Copyright (C) 2005-2018 JPPF Team.\n * http://www.jppf.org\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jppf.jmxremote;\n\nimport static org.jppf.jmx.JMXHelper.*;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport javax.management.*;\nimport javax.management.remote.*;\nimport javax.security.auth.Subject;\n\nimport org.jppf.JPPFException;\nimport org.jppf.comm.interceptor.InterceptorHandler;\nimport org.jppf.comm.socket.*;\nimport org.jppf.jmx.*;\nimport org.jppf.jmxremote.message.*;\nimport org.jppf.jmxremote.nio.*;\nimport org.jppf.jmxremote.nio.ChannelsPair.CloseCallback;\nimport org.jppf.jmxremote.notification.ClientListenerInfo;\nimport org.jppf.utils.*;\nimport org.slf4j.*;\n\n/**\n * Implementation of the {@link JMXConnector} interface for the JPPF JMX remote connector.\n * @author Laurent Cohen\n */\npublic class JPPFJMXConnector implements JMXConnector {\n  /**\n   * Logger for this class.\n   */\n  private static final Logger log = LoggerFactory.getLogger(JPPFJMXConnector.class);\n  /**\n   * Determines whether the debug level is enabled in the log configuration, without the cost of a method call.\n   */\n  private static final boolean debugEnabled = log.isDebugEnabled();\n  /**\n   * The environment for this connector.\n   */\n  private final Map<String, Object> environment;\n  /**\n   * The address of this connector.\n   */\n  private final JMXServiceURL address;\n  /**\n   * Whether the connection is secured through TLS.\n   */\n  private boolean secure = false;\n  /**\n   * The mbean server connection.\n   */\n  private JPPFMBeanServerConnection mbsc;\n  /**\n   * The onnectin ID.\n   */\n  private String connectionID;\n  /**\n   * The list of connection notification listeners registered with this connector.\n   */\n  private final List<ConnectionListenerInfo> connectionListeners = new CopyOnWriteArrayList<>();\n  /**\n   * A sequence number for connection notifications.\n   */\n  private final AtomicInteger notificationSequence = new AtomicInteger(0);\n  /**\n   * Mapping of notification listener ids to actual listeners.\n   */\n  private final Map<Integer, ClientListenerInfo> notificationListenerMap = new HashMap<>();\n  /**\n   * The message handler.\n   */\n  private JMXMessageHandler messageHandler;\n\n  /**\n   *\n   * @param serviceURL the address of this connector.\n   * @param environment the environment for this connector.\n   */\n  public JPPFJMXConnector(final JMXServiceURL serviceURL, final Map<String, ?> environment) {\n    this.environment = (environment == null) ? new HashMap<>() : new HashMap<>(environment);\n    this.address = serviceURL;\n    if (debugEnabled) log.debug(\"initialized JPPFJMXConnector with serviceURL = {} and environment = {}\", address, this.environment);\n  }\n\n  @Override\n  public void connect() throws IOException {\n    connect(null);\n  }\n\n  @Override\n  public void connect(final Map<String, ?> env) throws IOException {\n    if (debugEnabled) log.debug(\"env = {}, this.environment={}\", env, this.environment);\n    if (env != null) environment.putAll(env);\n    final String s = JMXEnvHelper.getString(JPPFJMXProperties.TLS_ENABLED, environment, null);\n    if (debugEnabled) log.debug(\"secure='{}'\", s);\n    final Boolean tls = Boolean.valueOf(s);\n    secure = (tls == null) ? false : tls;\n    try {\n      init();\n      fireConnectionNotification(false, null);\n    } catch (final IOException e) {\n      throw e;\n    } catch (final Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n  @Override\n  public MBeanServerConnection getMBeanServerConnection() throws IOException {\n    return mbsc;\n  }\n\n  @Override\n  public MBeanServerConnection getMBeanServerConnection(final Subject delegationSubject) throws IOException {\n    return mbsc;\n  }\n\n  @Override\n  public void close() throws IOException {\n    if (mbsc != null) mbsc.close();\n  }\n\n  @Override\n  public void addConnectionNotificationListener(final NotificationListener listener, final NotificationFilter filter, final Object handback) {\n    if (listener == null) return;\n    connectionListeners.add(new ConnectionListenerInfo(listener, filter, handback));\n  }\n\n  @Override\n  public void removeConnectionNotificationListener(final NotificationListener listener) throws ListenerNotFoundException {\n    if (listener == null) return;\n    final List<ConnectionListenerInfo> toRemove = new ArrayList<>(connectionListeners.size());\n    for (ConnectionListenerInfo info: connectionListeners)\n      if (info.listener == listener) toRemove.add(info);\n    if (toRemove.isEmpty()) throw new ListenerNotFoundException(\"could not find any matching listener\");\n    connectionListeners.removeAll(toRemove);\n  }\n\n  @Override\n  public void removeConnectionNotificationListener(final NotificationListener listener, final NotificationFilter filter, final Object handback) throws ListenerNotFoundException {\n    if (listener == null) return;\n    ConnectionListenerInfo toRemove = null;\n    for (ConnectionListenerInfo info: connectionListeners)\n      if ((info.listener == listener) && (info.filter == filter) && (info.handback == handback)) {\n        toRemove = info;\n        break;\n      }\n    if (toRemove == null) throw new ListenerNotFoundException(\"could not find any matching listener\");\n    connectionListeners.remove(toRemove);\n  }\n\n  /**\n   * Send a connection notification to all registered listeners.\n   * @param isClose whether this is for a connection closing ({@code true}) or opening ({@code false}).\n   * @param exception an optional exception that may have cause the connection to close.\n   */\n  private void fireConnectionNotification(final boolean isClose, final Exception exception) {\n    if (debugEnabled) log.debug(\"isClose={}, exception={}\", isClose, exception);\n    final String type;\n    if (isClose) type = (exception == null) ? JMXConnectionNotification.CLOSED : JMXConnectionNotification.FAILED;\n    else type = JMXConnectionNotification.OPENED;\n    if (debugEnabled) log.debug(\"firing notif with type={}, exception={}, connectionID={}\", type, ExceptionUtils.getMessage(exception), connectionID);\n    final JMXConnectionNotification notif = new JMXConnectionNotification(type, this, connectionID, notificationSequence.incrementAndGet(), null, null);\n    for (final ConnectionListenerInfo info: connectionListeners) {\n      if ((info.filter == null) || info.filter.isNotificationEnabled(notif)) info.listener.handleNotification(notif, info.handback);\n    }\n  }\n\n  @Override\n  public String getConnectionId() throws IOException {\n    return connectionID;\n  }\n\n  /**\n   * @return the environment for this connector.\n   */\n  public Map<String, ?> getEnvironment() {\n    return environment;\n  }\n\n  /**\n   * @return the address of this connector.\n   */\n  public JMXServiceURL getAddress() {\n    return address;\n  }\n\n  /**\n   * @return the message handler.\n   */\n  JMXMessageHandler getMessageHandler() {\n    return messageHandler;\n  }\n\n  /**\n   * Initialize this connector.\n   * @throws Exception if an error is raised during initialization.\n   */\n  private void init() throws Exception {\n    @SuppressWarnings(\"resource\")\n    final SocketChannelClient socketClient =  new SocketChannelClient(address.getHost(), address.getPort(), true);\n    if (debugEnabled) log.debug(\"Attempting connection to remote peer at {}\", address);\n    final SocketInitializer socketInitializer = SocketInitializer.Factory.newInstance();\n    if (!socketInitializer.initialize(socketClient)) {\n      final Exception e = socketInitializer.getLastException();\n      throw (e == null) ? new ConnectException(\"could not connect to remote JMX server \" + address) : e;\n    }\n    if (!InterceptorHandler.invokeOnConnect(socketClient.getChannel())) throw new JPPFException(\"connection denied by interceptor\");\n    if (debugEnabled) log.debug(\"Connected to JMX server {}, sending channel identifier {}\", address, JPPFIdentifiers.serverName(JPPFIdentifiers.JMX_REMOTE_CHANNEL));\n    socketClient.writeInt(JPPFIdentifiers.JMX_REMOTE_CHANNEL);\n    if (debugEnabled) log.debug(\"Reconnected to JMX server {}, secure={}\", address, secure);\n    final JMXNioServer server = JMXNioServerPool.getServer();\n    final ChannelsPair pair = server.createChannelsPair(environment, \"\", -1, socketClient.getChannel(), secure, true);\n    pair.addCloseCallback(new CloseCallback() {\n      @Override\n      public void onClose(final Exception exception) {\n        fireConnectionNotification(true, exception);\n      }\n    });\n    messageHandler = pair.getMessageHandler();\n    if (debugEnabled) log.debug(\"registering channel\");\n    server.registerChannel(pair, socketClient.getChannel());\n    if (debugEnabled) log.debug(\"getting connection id\");\n    //connectionID = messageHandler.receiveConnectionID(address);\n    connectionID = (String) messageHandler.sendRequestWithResponse(JMXHelper.CONNECT, environment.get(JMXConnector.CREDENTIALS));\n    pair.setConnectionID(connectionID);\n    if (debugEnabled) log.debug(\"received connectionId = {}\", connectionID);\n    mbsc = new JPPFMBeanServerConnection(this);\n    pair.setJMXConnector(this);\n  }\n\n  /**\n   * Handle a new received notification.\n   * @param jmxNotification the notification message to process.\n   * @throws Exception if any error occurs.\n   */\n  public void handleNotification(final JMXNotification jmxNotification) throws Exception {\n    if (debugEnabled) log.debug(\"received notification {}\", jmxNotification);\n    final List<ClientListenerInfo> infos = new ArrayList<>(jmxNotification.getListenerIDs().length);\n    synchronized(notificationListenerMap) {\n      for (final Integer listenerID: jmxNotification.getListenerIDs()) {\n        final ClientListenerInfo info = notificationListenerMap.get(listenerID);\n        if (info != null) infos.add(info);\n      }\n    }\n    for  (final ClientListenerInfo info: infos) info.getListener().handleNotification(jmxNotification.getNotification(), info.getHandback());\n  }\n\n  /**\n   * Add a notification listener.\n   * @param name the name of the MBean on which the listener should be added.\n   * @param listener the listener object which will handle the notifications emitted by the registered MBean.\n   * @param filter the filter object. If filter is null, no filtering will be performed before handling notifications.\n   * @param handback the context to be sent to the listener when a notification is emitted.\n   * @throws Exception if any error occurs.\n   */\n  void addNotificationListener(final ObjectName name, final NotificationListener listener, final NotificationFilter filter, final Object handback) throws Exception {\n    final int listenerID = (Integer) messageHandler.sendRequestWithResponse(ADD_NOTIFICATION_LISTENER, name, filter);\n    synchronized(notificationListenerMap) {\n      notificationListenerMap.put(listenerID, new ClientListenerInfo(listenerID, name, listener, filter, handback));\n    }\n  }\n\n  /**\n   * Removes a listener from a registered MBean.\n   * @param name the name of the MBean on which the listener should be removed.\n   * @param listener the listener to remove.\n   * @throws Exception if any error occurs.\n   */\n  void removeNotificationListener(final ObjectName name, final NotificationListener listener) throws Exception {\n    final List<ClientListenerInfo> toRemove = new ArrayList<>();\n    synchronized(notificationListenerMap) {\n      for (final Map.Entry<Integer, ClientListenerInfo> entry: notificationListenerMap.entrySet()) {\n        final ClientListenerInfo info = entry.getValue();\n        if (info.getMbeanName().equals(name) && (info.getListener() == listener)) toRemove.add(info);\n      }\n      if (toRemove.isEmpty()) throw new ListenerNotFoundException(\"no matching listener\");\n      final int[] ids = new int[toRemove.size()];\n      for (int i=0; i<ids.length; i++) ids[i] = toRemove.get(i).getListenerID();\n      messageHandler.sendRequestWithResponse(REMOVE_NOTIFICATION_LISTENER, name, ids);\n      for (final int id: ids) notificationListenerMap.remove(id);\n    }\n  }\n\n  /**\n   * Removes a listener from a registered MBean.\n   * @param name the name of the MBean on which the listener should be removed.\n   * @param listener the listener to remove.\n   * @param filter the filter that was specified when the listener was added.\n   * @param handback the handback that was specified when the listener was added.\n   * @throws Exception if any error occurs.\n   */\n  void removeNotificationListener(final ObjectName name, final NotificationListener listener, final NotificationFilter filter, final Object handback) throws Exception {\n    ClientListenerInfo toRemove = null;\n    synchronized(notificationListenerMap) {\n      for (Map.Entry<Integer, ClientListenerInfo> entry: notificationListenerMap.entrySet()) {\n        final ClientListenerInfo info = entry.getValue();\n        if (info.getMbeanName().equals(name) && (info.getListener() == listener) && (info.getFilter() == filter) && (info.getHandback() == handback)) {\n          toRemove = info;\n          break;\n        }\n      }\n      if (toRemove == null) throw new ListenerNotFoundException(\"no matching listener\");\n      messageHandler.sendRequestWithResponse(REMOVE_NOTIFICATION_LISTENER_FILTER_HANDBACK, name, toRemove.getListenerID());\n      notificationListenerMap.remove(toRemove.getListenerID());\n    }\n  }\n\n  /**\n   * Information for all registered connection listeners.\n   */\n  private final static class ConnectionListenerInfo {\n    /**\n     * The notification listener.\n     */\n    private final NotificationListener listener;\n    /**\n     * The notification filter.\n     */\n    private final NotificationFilter filter;\n    /**\n     * The handback object.\n     */\n    private final Object handback;\n\n    /**\n     * Initialize with the specified parameters.\n     * @param listener the notification listener.\n     * @param filter the notification filter.\n     * @param handback the handback object.\n     */\n    private ConnectionListenerInfo(final NotificationListener listener, final NotificationFilter filter, final Object handback) {\n      super();\n      this.listener = listener;\n      this.filter = filter;\n      this.handback = handback;\n    }\n  }\n\n  @Override\n  public String toString() {\n    return new StringBuilder(getClass().getSimpleName()).append('[')\n      .append(\"connectionID=\").append(connectionID)\n      .append(\", secure=\").append(secure)\n      .append(\", address=\").append(address)\n      .append(']').toString();\n  }\n}\n"},
{"Line": "=>510", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((m_credentialsResolver) == null) { org.opencms.configuration.CmsSystemConfiguration systemConfig = ((org.opencms.configuration.CmsSystemConfiguration) (m_configurationManager.getConfiguration(org.opencms.configuration.CmsSystemConfiguration.class))); return systemConfig.getCredentialsResolver(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/4800/buggy-version/src.org.opencms.main.OpenCmsCore.java", "BodyUseAPI": [], "Fixed commit": "d01e93e12cecc8d321d9fdb68bddd7ef770737d1", "Url": "https://api.github.com/repos/alkacon/opencms-core", "Date": "2018-11-06T13:55:34Z", "Source Code Diff": "@@ -507,6 +507,12 @@ protected CmsConfigurationManager getConfigurationManager() {\n      */\n     protected I_CmsCredentialsResolver getCredentialsResolver() {\n \n+        if (m_credentialsResolver == null) {\n+            CmsSystemConfiguration systemConfig = (CmsSystemConfiguration)m_configurationManager.getConfiguration(\n+                CmsSystemConfiguration.class);\n+            return systemConfig.getCredentialsResolver();\n+        }\n+\n         return m_credentialsResolver;\n     }\n ", "Complete After Code": "/*\n * This library is part of OpenCms -\n * the Open Source Content Management System\n *\n * Copyright (c) Alkacon Software GmbH & Co. KG (http://www.alkacon.com)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * For further information about Alkacon Software GmbH & Co. KG, please see the\n * company website: http://www.alkacon.com\n *\n * For further information about OpenCms, please see the\n * project website: http://www.opencms.org\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\npackage org.opencms.main;\n\nimport org.opencms.ade.configuration.CmsADEManager;\nimport org.opencms.configuration.CmsConfigurationException;\nimport org.opencms.configuration.CmsConfigurationManager;\nimport org.opencms.configuration.CmsImportExportConfiguration;\nimport org.opencms.configuration.CmsModuleConfiguration;\nimport org.opencms.configuration.CmsParameterConfiguration;\nimport org.opencms.configuration.CmsSchedulerConfiguration;\nimport org.opencms.configuration.CmsSearchConfiguration;\nimport org.opencms.configuration.CmsSitesConfiguration;\nimport org.opencms.configuration.CmsSystemConfiguration;\nimport org.opencms.configuration.CmsVariablesConfiguration;\nimport org.opencms.configuration.CmsVfsConfiguration;\nimport org.opencms.configuration.CmsWorkplaceConfiguration;\nimport org.opencms.db.CmsAliasManager;\nimport org.opencms.db.CmsDbEntryNotFoundException;\nimport org.opencms.db.CmsDefaultUsers;\nimport org.opencms.db.CmsExportPoint;\nimport org.opencms.db.CmsLoginManager;\nimport org.opencms.db.CmsSecurityManager;\nimport org.opencms.db.CmsSqlManager;\nimport org.opencms.db.CmsSubscriptionManager;\nimport org.opencms.db.timing.CmsDefaultProfilingHandler;\nimport org.opencms.db.timing.CmsThreadStatsTreeProfilingHandler;\nimport org.opencms.file.CmsObject;\nimport org.opencms.file.CmsProject;\nimport org.opencms.file.CmsProperty;\nimport org.opencms.file.CmsPropertyDefinition;\nimport org.opencms.file.CmsRequestContext;\nimport org.opencms.file.CmsResource;\nimport org.opencms.file.CmsUser;\nimport org.opencms.file.CmsVfsResourceNotFoundException;\nimport org.opencms.flex.CmsFlexCache;\nimport org.opencms.flex.CmsFlexCacheConfiguration;\nimport org.opencms.flex.CmsFlexController;\nimport org.opencms.gwt.CmsGwtService;\nimport org.opencms.gwt.CmsGwtServiceContext;\nimport org.opencms.i18n.CmsEncoder;\nimport org.opencms.i18n.CmsI18nInfo;\nimport org.opencms.i18n.CmsLocaleManager;\nimport org.opencms.i18n.CmsMessageContainer;\nimport org.opencms.i18n.CmsSingleTreeLocaleHandler;\nimport org.opencms.i18n.CmsVfsBundleManager;\nimport org.opencms.importexport.CmsImportExportManager;\nimport org.opencms.jsp.jsonpart.CmsJsonPartFilter;\nimport org.opencms.letsencrypt.CmsLetsEncryptConfiguration;\nimport org.opencms.loader.CmsResourceManager;\nimport org.opencms.loader.CmsTemplateContextManager;\nimport org.opencms.loader.I_CmsFlexCacheEnabledLoader;\nimport org.opencms.loader.I_CmsResourceLoader;\nimport org.opencms.lock.CmsLockManager;\nimport org.opencms.module.CmsModuleManager;\nimport org.opencms.monitor.CmsMemoryMonitor;\nimport org.opencms.monitor.CmsMemoryMonitorConfiguration;\nimport org.opencms.publish.CmsPublishEngine;\nimport org.opencms.publish.CmsPublishManager;\nimport org.opencms.repository.CmsRepositoryManager;\nimport org.opencms.rmi.CmsRemoteShellServer;\nimport org.opencms.scheduler.CmsScheduleManager;\nimport org.opencms.search.CmsSearchManager;\nimport org.opencms.security.CmsOrgUnitManager;\nimport org.opencms.security.CmsPersistentLoginTokenHandler;\nimport org.opencms.security.CmsRole;\nimport org.opencms.security.CmsRoleManager;\nimport org.opencms.security.CmsRoleViolationException;\nimport org.opencms.security.CmsSecurityException;\nimport org.opencms.security.I_CmsAuthorizationHandler;\nimport org.opencms.security.I_CmsCredentialsResolver;\nimport org.opencms.security.I_CmsPasswordHandler;\nimport org.opencms.security.I_CmsValidationHandler;\nimport org.opencms.site.CmsSite;\nimport org.opencms.site.CmsSiteManagerImpl;\nimport org.opencms.site.CmsSiteMatcher;\nimport org.opencms.staticexport.CmsDefaultLinkSubstitutionHandler;\nimport org.opencms.staticexport.CmsLinkManager;\nimport org.opencms.staticexport.CmsStaticExportManager;\nimport org.opencms.ui.apps.CmsWorkplaceAppManager;\nimport org.opencms.ui.error.CmsErrorUI;\nimport org.opencms.ui.login.CmsLoginHelper;\nimport org.opencms.ui.login.CmsLoginUI;\nimport org.opencms.util.CmsRequestUtil;\nimport org.opencms.util.CmsStringUtil;\nimport org.opencms.util.CmsUUID;\nimport org.opencms.workflow.CmsDefaultWorkflowManager;\nimport org.opencms.workflow.I_CmsWorkflowManager;\nimport org.opencms.workplace.CmsWorkplace;\nimport org.opencms.workplace.CmsWorkplaceLoginHandler;\nimport org.opencms.workplace.CmsWorkplaceManager;\nimport org.opencms.workplace.CmsWorkplaceSettings;\nimport org.opencms.xml.CmsXmlContentTypeManager;\nimport org.opencms.xml.CmsXmlUtils;\nimport org.opencms.xml.containerpage.CmsFormatterConfiguration;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.Security;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\nimport org.apache.commons.logging.Log;\n\nimport org.antlr.stringtemplate.StringTemplate;\n\nimport com.google.common.base.Optional;\n\nimport cryptix.jce.provider.CryptixCrypto;\n\n/**\n * The internal implementation of the core OpenCms \"operating system\" functions.<p>\n *\n * All access to this class must be done through the public static methods\n * of the <code>{@link org.opencms.main.OpenCms}</code> object.\n * Under no circumstances should you ever try to access this class directly.<p>\n *\n * This class is so OpenCms internal you should not even be reading this documentation ;-)<p>\n *\n * Any request to the <code>{@link org.opencms.main.OpenCmsServlet}</code> will be forwarded to this core class.\n * The core will then try to map the request to a VFS (Virtual File System) URI,\n * that is a <code>{@link org.opencms.file.CmsResource}</code> in the OpenCms database.\n * If a resource is found, it will be read and forwarded to\n * to the corresponding <code>{@link org.opencms.loader.I_CmsResourceLoader}</code>,\n * which will then generate the output for the requested resource and return it to the requesting client.<p>\n *\n * There will be only one singleton instance of this object created for\n * this core class. This means that in the default configuration, where\n * OpenCms is accessed through a servlet context, there will be only one instance of\n * the core in that servlet context.<p>\n *\n * @since 6.0.0\n */\npublic final class OpenCmsCore {\n\n    /** The static log object for this class. */\n    static final Log LOG = CmsLog.getLog(OpenCmsCore.class);\n\n    /** Lock object for synchronization. */\n    private static final Object LOCK = new Object();\n\n    /** Indicates if the configuration was successfully finished or not. */\n    private static CmsMessageContainer m_errorCondition;\n\n    /** One instance to rule them all, one instance to find them... */\n    private static OpenCmsCore m_instance;\n\n    /** The ADE manager instance. */\n    private CmsADEManager m_adeManager;\n\n    /** The manager for page aliases. */\n    private CmsAliasManager m_aliasManager;\n\n    /** The configured authorization handler. */\n    private I_CmsAuthorizationHandler m_authorizationHandler;\n\n    /** The configuration manager that contains the information from the XML configuration. */\n    private CmsConfigurationManager m_configurationManager;\n\n    /** The object used for resolving database user credentials. */\n    private I_CmsCredentialsResolver m_credentialsResolver;\n\n    /** List of configured directory default file names. */\n    private List<String> m_defaultFiles;\n\n    /** The default user and group names. */\n    private CmsDefaultUsers m_defaultUsers;\n\n    /** The event manager for the event handling. */\n    private CmsEventManager m_eventManager;\n\n    /** The thread pool executor. */\n    private ScheduledThreadPoolExecutor m_executor;\n\n    /** The set of configured export points. */\n    private Set<CmsExportPoint> m_exportPoints;\n\n    /** The flex cache instance. */\n    private CmsFlexCache m_flexCache;\n\n    /** The context objects for GWT services. */\n    private Map<String, CmsGwtServiceContext> m_gwtServiceContexts;\n\n    /** The site manager contains information about the Cms import/export. */\n    private CmsImportExportManager m_importExportManager;\n\n    /** The LetsEncrypt configuration. */\n    private CmsLetsEncryptConfiguration m_letsEncryptConfig;\n\n    /** The link manager to resolve links in &lt;cms:link&gt; tags. */\n    private CmsLinkManager m_linkManager;\n\n    /** The locale manager used for obtaining the current locale. */\n    private CmsLocaleManager m_localeManager;\n\n    /** The login manager. */\n    private CmsLoginManager m_loginManager;\n\n    /** The memory monitor for the collection of memory and runtime statistics. */\n    private CmsMemoryMonitor m_memoryMonitor;\n\n    /** The module manager. */\n    private CmsModuleManager m_moduleManager;\n\n    /** The organizational unit manager. */\n    private CmsOrgUnitManager m_orgUnitManager;\n\n    /** The password handler used to digest and validate passwords. */\n    private I_CmsPasswordHandler m_passwordHandler;\n\n    /** The publish engine. */\n    private CmsPublishEngine m_publishEngine;\n\n    /** The publish manager instance. */\n    private CmsPublishManager m_publishManager;\n\n    /** The remote shell server. */\n    private CmsRemoteShellServer m_remoteShellServer;\n\n    /** The repository manager. */\n    private CmsRepositoryManager m_repositoryManager;\n\n    /** The configured request handlers that handle \"special\" requests, for example in the static export on demand. */\n    private Map<String, I_CmsRequestHandler> m_requestHandlers;\n\n    /** Stores the resource init handlers that allow modification of the requested resource. */\n    private List<I_CmsResourceInit> m_resourceInitHandlers;\n\n    /** The resource manager. */\n    private CmsResourceManager m_resourceManager;\n\n    /** The role manager. */\n    private CmsRoleManager m_roleManager;\n\n    /** The runlevel of this OpenCmsCore object instance. */\n    private int m_runLevel;\n\n    /** The runtime properties allow storage of system wide accessible runtime information. */\n    private Map<Object, Object> m_runtimeProperties;\n\n    /** The configured scheduler manager. */\n    private CmsScheduleManager m_scheduleManager;\n\n    /** The search manager provides indexing and searching. */\n    private CmsSearchManager m_searchManager;\n\n    /** The security manager to access the database and validate user permissions. */\n    private CmsSecurityManager m_securityManager;\n\n    /** The session manager. */\n    private CmsSessionManager m_sessionManager;\n\n    /** The site manager contains information about all configured sites. */\n    private CmsSiteManagerImpl m_siteManager;\n\n    /** The static export manager. */\n    private CmsStaticExportManager m_staticExportManager;\n\n    /** The subscription manager. */\n    private CmsSubscriptionManager m_subscriptionManager;\n\n    /** The system information container for \"read only\" system settings. */\n    private CmsSystemInfo m_systemInfo;\n\n    /** The template context manager. */\n    private CmsTemplateContextManager m_templateContextManager;\n\n    /** The thread store. */\n    private CmsThreadStore m_threadStore;\n\n    /** The runtime validation handler. */\n    private I_CmsValidationHandler m_validationHandler;\n\n    /** The VFS bundle manager. */\n    private CmsVfsBundleManager m_vfsBundleManager;\n\n    /** The workflow manager instance. */\n    private I_CmsWorkflowManager m_workflowManager;\n\n    /** The workplace app manager. */\n    private CmsWorkplaceAppManager m_workplaceAppManager;\n\n    /** The workplace manager contains information about the global workplace settings. */\n    private CmsWorkplaceManager m_workplaceManager;\n\n    /** The XML content type manager that contains the initialized XML content types. */\n    private CmsXmlContentTypeManager m_xmlContentTypeManager;\n\n    /**\n     * Protected constructor that will initialize the singleton OpenCms instance\n     * with runlevel {@link OpenCms#RUNLEVEL_1_CORE_OBJECT}.<p>\n     *\n     * @throws CmsInitException in case of errors during the initialization\n     */\n    private OpenCmsCore()\n    throws CmsInitException {\n\n        if ((m_instance != null) && (m_instance.getRunLevel() > OpenCms.RUNLEVEL_0_OFFLINE)) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_ALREADY_INITIALIZED_0));\n        }\n        initMembers();\n        m_instance = this;\n        setRunLevel(OpenCms.RUNLEVEL_1_CORE_OBJECT);\n    }\n\n    /**\n     * Returns the initialized OpenCms singleton instance.<p>\n     *\n     * @return the initialized OpenCms singleton instance\n     */\n    protected static OpenCmsCore getInstance() {\n\n        if (m_errorCondition != null) {\n            // OpenCms is not properly initialized\n            throw new CmsInitException(m_errorCondition, false);\n        }\n\n        if (m_instance != null) {\n            return m_instance;\n        }\n        synchronized (LOCK) {\n            if (m_instance == null) {\n                try {\n                    // create a new core object with runlevel 1\n                    m_instance = new OpenCmsCore();\n                } catch (CmsInitException e) {\n                    // already initialized, this is all we need\n                    LOG.debug(e.getMessage(), e);\n                }\n            }\n        }\n        return m_instance;\n    }\n\n    /**\n     * Sets the error condition.<p>\n     *\n     * @param errorCondition the error condition to set\n     */\n    protected static void setErrorCondition(CmsMessageContainer errorCondition) {\n\n        // init exceptions should only be thrown during setup process\n        if ((m_instance != null) && (m_instance.getRunLevel() < OpenCms.RUNLEVEL_3_SHELL_ACCESS)) {\n            if (!Messages.ERR_CRITICAL_INIT_WIZARD_0.equals(errorCondition.getKey())) {\n                // if wizard is still enabled allow retry of initialization (for setup wizard)\n                m_errorCondition = errorCondition;\n                // output an error message to the console\n                System.err.println(\n                    Messages.get().getBundle().key(Messages.LOG_INIT_FAILURE_MESSAGE_1, errorCondition.key()));\n            }\n            LOG.error(errorCondition.key(), new CmsException(errorCondition));\n            m_instance = null;\n        } else if (m_instance != null) {\n            // OpenCms already was successful initialized\n            LOG.warn(\n                Messages.get().getBundle().key(\n                    Messages.LOG_INIT_INVALID_ERROR_2,\n                    new Integer(m_instance.getRunLevel()),\n                    errorCondition.key()));\n        }\n    }\n\n    /**\n     * Gets a string containing all keys and variations currently in the flex cache, for debug purposes.<p>\n     *\n     * @return a debug information string with the flex cache data\n     */\n    public String getFlexCacheKeyDump() {\n\n        if (m_flexCache != null) {\n            StringBuffer buffer = new StringBuffer();\n            m_flexCache.dumpKeys(buffer);\n            return buffer.toString();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the LetsEncrypt configuration.<p>\n     *\n     * @return the LetsEncrypt configuration\n     */\n    public CmsLetsEncryptConfiguration getLetsEncryptConfig() {\n\n        return m_letsEncryptConfig;\n    }\n\n    /**\n     * Adds the specified request handler to the Map of OpenCms request handlers. <p>\n     *\n     * @param handler the handler to add\n     */\n    protected void addRequestHandler(I_CmsRequestHandler handler) {\n\n        if (handler == null) {\n            return;\n        }\n        String[] names = handler.getHandlerNames();\n        for (int i = 0; i < names.length; i++) {\n            String name = names[i];\n            if (m_requestHandlers.get(name) != null) {\n                CmsLog.INIT.error(Messages.get().getBundle().key(Messages.LOG_DUPLICATE_REQUEST_HANDLER_1, name));\n                continue;\n            }\n            m_requestHandlers.put(name, handler);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(\n                    Messages.get().getBundle().key(\n                        Messages.INIT_ADDED_REQUEST_HANDLER_2,\n                        name,\n                        handler.getClass().getName()));\n            }\n        }\n    }\n\n    /**\n     * Gets the ADE manager, and makes sure it is initialized.<p>\n     *\n     * @return the initialized ADE manager\n     */\n    protected CmsADEManager getADEManager() {\n\n        if (!m_adeManager.isInitialized()) {\n            m_adeManager.initialize();\n        }\n        return m_adeManager;\n    }\n\n    /**\n     * Returns the alias manager.<p>\n     *\n     * @return the alias manager\n     */\n    protected CmsAliasManager getAliasManager() {\n\n        return m_aliasManager;\n    }\n\n    /**\n     * Returns the configured authorization handler.<p>\n     *\n     * @return the configured authorization handler\n     */\n    protected I_CmsAuthorizationHandler getAuthorizationHandler() {\n\n        return m_authorizationHandler;\n    }\n\n    /**\n     * Returns the initialized OpenCms configuration manager.<p>\n     *\n     * @return the initialized OpenCms configuration manager\n     */\n    protected CmsConfigurationManager getConfigurationManager() {\n\n        return m_configurationManager;\n    }\n\n    /**\n     * Gets the configured credentials resolver instance.<p>\n     *\n     * @return the credentials resolver\n     */\n    protected I_CmsCredentialsResolver getCredentialsResolver() {\n\n        if (m_credentialsResolver == null) {\n            CmsSystemConfiguration systemConfig = (CmsSystemConfiguration)m_configurationManager.getConfiguration(\n                CmsSystemConfiguration.class);\n            return systemConfig.getCredentialsResolver();\n        }\n\n        return m_credentialsResolver;\n    }\n\n    /**\n     * Returns the configured list of default directory file names.<p>\n     *\n     * @return the configured list of default directory file names\n     */\n    protected List<String> getDefaultFiles() {\n\n        return m_defaultFiles;\n    }\n\n    /**\n     * Returns the default user and group name configuration.<p>\n     *\n     * @return the default user and group name configuration\n     */\n    protected CmsDefaultUsers getDefaultUsers() {\n\n        return m_defaultUsers;\n    }\n\n    /**\n     * Returns the OpenCms event manager.<p>\n     *\n     * @return the OpenCms event manager\n     */\n    protected CmsEventManager getEventManager() {\n\n        return m_eventManager;\n    }\n\n    /**\n     * Gets the thread pool executor.<p>\n     *\n     * @return the thread pool executor\n     */\n    protected ScheduledThreadPoolExecutor getExecutor() {\n\n        return m_executor;\n    }\n\n    /**\n     * Returns the configured export points,\n     * the returned set being an unmodifiable set.<p>\n     *\n     * @return an unmodifiable set of the configured export points\n     */\n    protected Set<CmsExportPoint> getExportPoints() {\n\n        return m_exportPoints;\n    }\n\n    /**\n     * Gets the flex cache.\n     * @return CmsFlexCache\n     */\n\n    protected CmsFlexCache getFlexCache() {\n\n        return m_flexCache;\n    }\n\n    /**\n     * Returns the initialized import/export manager,\n     * which contains information about the Cms import/export.<p>\n     *\n     * @return the initialized import/export manager\n     */\n    protected CmsImportExportManager getImportExportManager() {\n\n        return m_importExportManager;\n    }\n\n    /**\n     * Returns the link manager to resolve links in &lt;link&gt; tags.<p>\n     *\n     * @return  the link manager to resolve links in &lt;link&gt; tags\n     */\n    protected CmsLinkManager getLinkManager() {\n\n        return m_linkManager;\n    }\n\n    /**\n     * Returns the locale manager used for obtaining the current locale.<p>\n     *\n     * @return the locale manager\n     */\n    protected CmsLocaleManager getLocaleManager() {\n\n        return m_localeManager;\n    }\n\n    /**\n     * Returns the lock manager used for the locking mechanism.<p>\n     *\n     * @return the lock manager used for the locking mechanism\n     */\n    protected CmsLockManager getLockManager() {\n\n        return m_securityManager.getLockManager();\n    }\n\n    /**\n     * Returns the login manager used to check the validity of a login.<p>\n     *\n     * @return the login manager\n     */\n    protected CmsLoginManager getLoginManager() {\n\n        return m_loginManager;\n    }\n\n    /**\n     * Returns the memory monitor.<p>\n     *\n     * @return the memory monitor\n     */\n    protected CmsMemoryMonitor getMemoryMonitor() {\n\n        return m_memoryMonitor;\n    }\n\n    /**\n     * Returns the module manager.<p>\n     *\n     * @return the module manager\n     */\n    protected CmsModuleManager getModuleManager() {\n\n        return m_moduleManager;\n    }\n\n    /**\n     * Returns the organizational unit manager.<p>\n     *\n     * @return the organizational unit manager\n     */\n    protected CmsOrgUnitManager getOrgUnitManager() {\n\n        return m_orgUnitManager;\n    }\n\n    /**\n     * Return the password handler.<p>\n     *\n     * @return the password handler\n     */\n    protected I_CmsPasswordHandler getPasswordHandler() {\n\n        return m_passwordHandler;\n    }\n\n    /**\n     * Returns the path for the request.<p>\n     *\n     * First checks the {@link HttpServletRequest#getPathInfo()}, then\n     * the configured request error page attribute (if set), and then\n     * if still undefined the <code>/</code> is returned as path info.<p>\n     *\n     * This is only needed when the {@link HttpServletRequest#getPathInfo()}\n     * is not really working as expected like in BEA WLS 9.x, where we have\n     * to use the 'weblogic.servlet.errorPage' request attribute.<p>\n     *\n     * @param req the http request context\n     *\n     * @return the path for the request\n     */\n    protected String getPathInfo(HttpServletRequest req) {\n\n        String path = req.getPathInfo();\n        if (path == null) {\n            // if the HttpServletRequest#getPathInfo() method does not work properly\n            String requestErrorPageAttribute = getSystemInfo().getServletContainerSettings().getRequestErrorPageAttribute();\n            if (requestErrorPageAttribute != null) {\n                // use the proper page attribute\n                path = (String)req.getAttribute(requestErrorPageAttribute);\n                if (path != null) {\n                    int pos = path.indexOf(\"/\", 1);\n                    if (pos > 0) {\n                        // cut off the servlet name\n                        path = path.substring(pos);\n                    }\n                }\n            }\n        }\n        if (path == null) {\n            path = \"/\";\n        }\n        return path;\n    }\n\n    /**\n     * Returns the publish manager instance.<p>\n     *\n     * @return the publish manager instance\n     */\n    protected CmsPublishManager getPublishManager() {\n\n        return m_publishManager;\n    }\n\n    /**\n     * Returns the repository manager.<p>\n     *\n     * @return the repository manager\n     */\n    protected CmsRepositoryManager getRepositoryManager() {\n\n        return m_repositoryManager;\n    }\n\n    /**\n     * Returns the handler instance for the specified name,\n     * or null if the name does not match any handler name.<p>\n     *\n     * @param name the name of the handler instance to return\n     * @return the handler instance for the specified name\n     */\n    protected I_CmsRequestHandler getRequestHandler(String name) {\n\n        return m_requestHandlers.get(name);\n    }\n\n    /**\n     * Returns the resource manager.<p>\n     *\n     * @return the resource manager\n     */\n    protected CmsResourceManager getResourceManager() {\n\n        return m_resourceManager;\n    }\n\n    /**\n     * Returns the role manager.<p>\n     *\n     * @return the role manager\n     */\n    protected CmsRoleManager getRoleManager() {\n\n        return m_roleManager;\n    }\n\n    /**\n     * Returns the runlevel of this OpenCmsCore object instance.<p>\n     *\n     * For a detailed description about the possible run levels,\n     * please see {@link OpenCms#getRunLevel()}.<p>\n     *\n     * @return the runlevel of this OpenCmsCore object instance\n     *\n     * @see OpenCms#getRunLevel()\n     */\n    protected int getRunLevel() {\n\n        return m_runLevel;\n    }\n\n    /**\n     * Looks up a value in the runtime property Map.<p>\n     *\n     * @param key the key to look up in the runtime properties\n     * @return the value for the key, or null if the key was not found\n     */\n    protected Object getRuntimeProperty(Object key) {\n\n        return m_runtimeProperties.get(key);\n    }\n\n    /**\n     * Returns the configured schedule manager.<p>\n     *\n     * @return the configured schedule manager\n     */\n    protected CmsScheduleManager getScheduleManager() {\n\n        return m_scheduleManager;\n    }\n\n    /**\n     * Returns the initialized search manager,\n     * which provides indexing and searching operations.<p>\n     *\n     * @return the initialized search manager\n     */\n    protected CmsSearchManager getSearchManager() {\n\n        return m_searchManager;\n    }\n\n    /**\n     * Returns the initialized OpenCms security manager.<p>\n     *\n     * @return the initialized OpenCms security manager\n     */\n    protected CmsSecurityManager getSecurityManager() {\n\n        return m_securityManager;\n    }\n\n    /**\n     * Returns the session manager.<p>\n     *\n     * @return the session manager\n     */\n    protected CmsSessionManager getSessionManager() {\n\n        return m_sessionManager;\n    }\n\n    /**\n     * Returns the initialized site manager,\n     * which contains information about all configured sites.<p>\n     *\n     * @return the initialized site manager\n     */\n    protected CmsSiteManagerImpl getSiteManager() {\n\n        return m_siteManager;\n    }\n\n    /**\n     * Returns an instance of the common sql manager.<p>\n     *\n     * @return an instance of the common sql manager\n     */\n    protected CmsSqlManager getSqlManager() {\n\n        return m_securityManager.getSqlManager();\n    }\n\n    /**\n     * Returns the properties for the static export.<p>\n     *\n     * @return the properties for the static export\n     */\n    protected CmsStaticExportManager getStaticExportManager() {\n\n        return m_staticExportManager;\n    }\n\n    /**\n     * Returns the subscription manager.<p>\n     *\n     * @return the subscription manager\n     */\n    protected CmsSubscriptionManager getSubscriptionManager() {\n\n        return m_subscriptionManager;\n    }\n\n    /**\n     * Returns the system information storage.<p>\n     *\n     * @return the system information storage\n     */\n    protected CmsSystemInfo getSystemInfo() {\n\n        return m_systemInfo;\n    }\n\n    /**\n     * Gets the template context manager instance.<p>\n     *\n     * @return the template context manager instance\n     */\n    protected CmsTemplateContextManager getTemplateContextManager() {\n\n        return m_templateContextManager;\n\n    }\n\n    /**\n     * Returns the OpenCms Thread store.<p>\n     *\n     * @return the OpenCms Thread store\n     */\n    protected CmsThreadStore getThreadStore() {\n\n        return m_threadStore;\n    }\n\n    /**\n     * Returns the runtime validation handler.<p>\n     *\n     * @return the validation handler\n     */\n    protected I_CmsValidationHandler getValidationHandler() {\n\n        return m_validationHandler;\n    }\n\n    /**\n     * Returns the workflow manager instance.<p>\n     *\n     * @return the workflow manager\n     */\n    protected I_CmsWorkflowManager getWorkflowManager() {\n\n        return m_workflowManager;\n    }\n\n    /**\n     * Returns the workplace app manager.<p>\n     *\n     * @return the workplace app manager\n     */\n    protected CmsWorkplaceAppManager getWorkplaceAppManager() {\n\n        return m_workplaceAppManager;\n    }\n\n    /**\n     * Returns the initialized workplace manager,\n     * which contains information about the global workplace settings.<p>\n     *\n     * @return the initialized workplace manager\n     */\n    protected CmsWorkplaceManager getWorkplaceManager() {\n\n        return m_workplaceManager;\n    }\n\n    /**\n     * Returns the XML content type manager.<p>\n     *\n     * @return the XML content type manager\n     */\n    protected CmsXmlContentTypeManager getXmlContentTypeManager() {\n\n        if (m_xmlContentTypeManager != null) {\n            return m_xmlContentTypeManager;\n        }\n        if (getRunLevel() == OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n            // this is only to enable test cases to run\n            m_xmlContentTypeManager = CmsXmlContentTypeManager.createTypeManagerForTestCases();\n        }\n        return m_xmlContentTypeManager;\n    }\n\n    /**\n     * Initializes the OpenCms context for Vaadin UI servlet.<p>\n     *\n     * @param req the request\n     * @param res the response\n     * @param servlet the UI servlet\n     *\n     * @throws IOException if user authentication fails\n     * @throws CmsException if something goes wrong\n     */\n    protected void initCmsContextForUI(HttpServletRequest req, HttpServletResponse res, CmsUIServlet servlet)\n    throws IOException, CmsException {\n\n        // instantiate CMS context\n        String originalEncoding = req.getCharacterEncoding();\n        String referrer = req.getHeader(\"referer\");\n        boolean allowPrivilegedLogin = (referrer == null) || !referrer.contains(CmsWorkplaceLoginHandler.LOGIN_HANDLER);\n\n        CmsObject cms = initCmsObject(req, res, allowPrivilegedLogin);\n        servlet.setCms(cms);\n        if (originalEncoding != null) {\n            // getI18NInfo sets wrong encoding\n            req.setCharacterEncoding(originalEncoding);\n        }\n    }\n\n    /**\n     * Returns an independent copy of the provided CmsObject.<p>\n     *\n     * This can be useful in case a permanent reference to a CmsObject is stored.\n     * Changing the request context values (for example project, siteroot) in the new CmsObject\n     * will have no side effects to the CmsObject it was copied form.<p>\n     *\n     * The request time (<code>{@link CmsRequestContext#getRequestTime()}</code>)\n     * is set to the current time.<p>\n     *\n     * @param cms the CmsObject to create a copy of\n     *\n     * @return an independent copy of the provided CmsObject\n     *\n     * @throws CmsException in case the initialization failed\n     *\n     * @see OpenCms#initCmsObject(CmsObject)\n     * @see OpenCms#initCmsObject(CmsObject, CmsContextInfo)\n     * @see OpenCms#initCmsObject(String)\n     */\n    protected CmsObject initCmsObject(CmsObject cms) throws CmsException {\n\n        CmsContextInfo contextInfo = new CmsContextInfo(cms.getRequestContext());\n        contextInfo.setRequestTime(CmsContextInfo.CURRENT_TIME);\n        return initCmsObject(contextInfo);\n    }\n\n    /**\n     * Returns an initialized CmsObject with the user and context initialized as provided.<p>\n     *\n     * Note: Only if the provided <code>adminCms</code> CmsObject has admin permissions,\n     * this method allows the creation a CmsObject for any existing user. Otherwise\n     * only the default users 'Guest' and 'Export' can initialized with\n     * this method, all other user names will throw an Exception.<p>\n     *\n     * @param adminCms must either be initialized with \"Admin\" permissions, or null\n     * @param contextInfo the context info to create a CmsObject for\n     *\n     * @return an initialized CmsObject with the given users permissions\n     *\n     * @throws CmsException if an invalid user name was provided\n     * @throws CmsRoleViolationException if the current user does not have the role permissions to create a context for the requested user\n     *\n     * @see org.opencms.db.CmsDefaultUsers#getUserGuest()\n     * @see org.opencms.db.CmsDefaultUsers#getUserExport()\n     * @see OpenCms#initCmsObject(CmsObject)\n     * @see OpenCms#initCmsObject(CmsObject, CmsContextInfo)\n     * @see OpenCms#initCmsObject(String)\n     */\n    protected CmsObject initCmsObject(CmsObject adminCms, CmsContextInfo contextInfo)\n    throws CmsRoleViolationException, CmsException {\n\n        String userName = contextInfo.getUserName();\n\n        if ((adminCms == null) || !m_roleManager.hasRole(adminCms, CmsRole.ROOT_ADMIN)) {\n            if (!userName.endsWith(getDefaultUsers().getUserGuest())\n                && !userName.endsWith(getDefaultUsers().getUserExport())) {\n\n                // if no admin object is provided, only \"Guest\" or \"Export\" user can be generated\n                CmsMessageContainer message = Messages.get().container(\n                    Messages.ERR_INVALID_INIT_USER_2,\n                    userName,\n                    ((adminCms != null) ? (adminCms.getRequestContext().getCurrentUser().getName()) : \"\"));\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(message.key());\n                }\n                throw new CmsRoleViolationException(message);\n            }\n        }\n\n        return initCmsObject(contextInfo);\n    }\n\n    /**\n     * Handles the user authentification for each request sent to OpenCms.<p>\n     *\n     * User authentification is done in three steps:\n     * <ol>\n     * <li>Session authentification: OpenCms stores information of all authentificated\n     *      users in an internal storage based on the users session.</li>\n     * <li>Authorization handler authentification: If the session authentification fails,\n     *      the current configured authorization handler is called.</li>\n     * <li>Default user: When both authentification methods fail, the user is set to\n     *      the default (Guest) user.</li>\n     * </ol>\n     *\n     * @param req the current http request\n     * @param res the current http response\n     * @param allowPrivilegedLogin <code>true</code> to allow login through authorization handlers\n     *\n     * @return the initialized cms context\n     *\n     * @throws IOException if user authentication fails\n     * @throws CmsException in case something goes wrong\n     */\n    protected CmsObject initCmsObject(HttpServletRequest req, HttpServletResponse res, boolean allowPrivilegedLogin)\n    throws IOException, CmsException {\n\n        // first try to restore a stored session\n        CmsObject cms = initCmsObjectFromSession(req);\n        if (cms != null) {\n            return cms;\n        }\n        if (allowPrivilegedLogin) {\n            // if does not work, try to authorize the request\n            I_CmsAuthorizationHandler.I_PrivilegedLoginAction loginAction = new I_CmsAuthorizationHandler.I_PrivilegedLoginAction() {\n\n                private CmsObject m_adminCms;\n\n                /**\n                 * @see org.opencms.security.I_CmsAuthorizationHandler.I_PrivilegedLoginAction#doLogin(javax.servlet.http.HttpServletRequest, java.lang.String)\n                 */\n                public CmsObject doLogin(HttpServletRequest request, String principal) throws CmsException {\n\n                    try {\n                        CmsUser user = m_adminCms.readUser(principal);\n                        if (!user.isEnabled()) {\n                            throw new CmsException(\n                                Messages.get().container(Messages.ERR_INVALID_INIT_USER_2, user.getName(), \"-\"));\n                        }\n\n                        // initialize the new cms object\n                        CmsContextInfo contextInfo = new CmsContextInfo(m_adminCms.getRequestContext());\n                        contextInfo.setUserName(principal);\n                        CmsObject newCms = initCmsObject(m_adminCms, contextInfo);\n\n                        if ((contextInfo.getRequestedUri().startsWith(\"/system/workplace/\")\n                            // also check for new workplace\n                            || request.getRequestURI().startsWith(OpenCms.getSystemInfo().getWorkplaceContext()))\n                            && getRoleManager().hasRole(newCms, CmsRole.ELEMENT_AUTHOR)) {\n                            LOG.debug(\"Handling workplace login for user \" + principal);\n                            CmsWorkplaceSettings settings = CmsLoginHelper.initSiteAndProject(newCms);\n                            request.getSession(true).setAttribute(\n                                CmsWorkplaceManager.SESSION_WORKPLACE_SETTINGS,\n                                settings);\n                            OpenCms.getSessionManager().updateSessionInfo(newCms, request);\n                        }\n                        m_adminCms.updateLastLoginDate(user);\n\n                        // fire the login user event\n                        OpenCms.fireCmsEvent(\n                            I_CmsEventListener.EVENT_LOGIN_USER,\n                            Collections.<String, Object> singletonMap(\"data\", user));\n                        return newCms;\n                    } finally {\n                        m_adminCms = null;\n                    }\n                }\n\n                /**\n                 * @see org.opencms.security.I_CmsAuthorizationHandler.I_PrivilegedLoginAction#getCmsObject()\n                 */\n                public CmsObject getCmsObject() {\n\n                    return m_adminCms;\n                }\n\n                /**\n                 * @see org.opencms.security.I_CmsAuthorizationHandler.I_PrivilegedLoginAction#setCmsObject(org.opencms.file.CmsObject)\n                 */\n                public void setCmsObject(CmsObject adminCms) {\n\n                    m_adminCms = adminCms;\n                }\n            };\n            loginAction.setCmsObject(initCmsObject(req, res, OpenCms.getDefaultUsers().getUserAdmin(), null, null));\n            cms = m_authorizationHandler.initCmsObject(req, loginAction);\n            if (cms != null) {\n                return cms;\n            }\n\n            // authentification failed or not enough permissions, so display a login screen\n            m_authorizationHandler.requestAuthorization(req, res, getLoginFormURL(req, res));\n        }\n        cms = initCmsObject(\n            req,\n            m_securityManager.readUser(null, OpenCms.getDefaultUsers().getUserGuest()),\n            getSiteManager().matchRequest(req).getSiteRoot(),\n            CmsProject.ONLINE_PROJECT_ID,\n            \"\");\n        // return the initialized cms user context object\n        return cms;\n    }\n\n    /**\n     * Returns an initialized CmsObject with the user initialized as provided,\n     * with the \"Online\" project selected and \"/\" set as the current site root.<p>\n     *\n     * Note: Only the default users 'Guest' and 'Export' can initialized with\n     * this method, all other user names will throw an Exception.<p>\n     *\n     * @param user the user name to initialize, can only be\n     *        {@link org.opencms.db.CmsDefaultUsers#getUserGuest()} or\n     *        {@link org.opencms.db.CmsDefaultUsers#getUserExport()}\n     *\n     * @return an initialized CmsObject with the given users permissions\n     *\n     * @throws CmsException if an invalid user name was provided, or if something else goes wrong\n     *\n     * @see org.opencms.db.CmsDefaultUsers#getUserGuest()\n     * @see org.opencms.db.CmsDefaultUsers#getUserExport()\n     * @see OpenCms#initCmsObject(String)\n     * @see #initCmsObject(CmsObject, CmsContextInfo)\n     */\n    protected CmsObject initCmsObject(String user) throws CmsException {\n\n        return initCmsObject(null, new CmsContextInfo(user));\n    }\n\n    /**\n     * Initializes a new cms object from the session data of the request.<p>\n     *\n     * If no session data is found, <code>null</code> is returned.<p>\n     *\n     * @param req the request\n     *\n     * @return the new initialized cms object\n     *\n     * @throws CmsException if something goes wrong\n     */\n    protected CmsObject initCmsObjectFromSession(HttpServletRequest req) throws CmsException {\n\n        String url = req.getRequestURL().toString();\n        String p = \"[ \" + url + \" ] \";\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(p + \"Trying to init cms object from session for request \\\"\" + req.toString() + \"\\\".\");\n        }\n        // try to get an OpenCms user session info object for this request\n        CmsSessionInfo sessionInfo = m_sessionManager.getSessionInfo(req);\n\n        if (sessionInfo == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(p + \"No session info found.\");\n            }\n            return null;\n        }\n\n        // initialize the requested site root\n        CmsSite site = getSiteManager().matchRequest(req);\n\n        // a user name is found in the session manager, reuse this user information\n        CmsUUID project = sessionInfo.getProject();\n\n        // initialize site root from request\n        String siteroot = sessionInfo.getSiteRoot();\n        if (siteroot == null) {\n            // not sure if this can actually happen?\n            LOG.debug(p + \"site root from session info was null, determining site root from current request's host\");\n            siteroot = site.getSiteRoot();\n        }\n        // initialize user from request\n        CmsUser user = m_securityManager.readUser(null, sessionInfo.getUserId());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(p + \"Initializing cms object with user \\\"\" + user.getName() + \"\\\".\");\n            LOG.debug(p + \"siteRoot = \" + siteroot);\n        }\n        return initCmsObject(req, user, siteroot, project, sessionInfo.getOrganizationalUnitFqn());\n    }\n\n    /**\n     * Constructor to create a new OpenCms object.<p>\n     *\n     * It reads the configurations from the <code>opencms.properties</code>\n     * file in the <code>config/</code> subdirectory. With the information\n     * from this file is inits a ResourceBroker (Database access module),\n     * various caching systems and other options.<p>\n     *\n     * This will only be done once per accessing class.\n     *\n     * @param configuration the configurations from the <code>opencms.properties</code> file\n     * @throws CmsInitException in case OpenCms can not be initialized\n     */\n    protected synchronized void initConfiguration(CmsParameterConfiguration configuration) throws CmsInitException {\n\n        String serverInfo = configuration.getString(\"context.servlet.container\", null);\n\n        // output startup message to log file\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            CmsLog.INIT.info(\n                \". \"\n                    + Messages.get().getBundle().key(\n                        Messages.GUI_SHELL_VERSION_1,\n                        OpenCms.getSystemInfo().getVersionNumber()));\n            for (int i = 0; i < Messages.COPYRIGHT_BY_ALKACON.length; i++) {\n                CmsLog.INIT.info(\". \" + Messages.COPYRIGHT_BY_ALKACON[i]);\n            }\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_STARTUP_TIME_1, new Date(System.currentTimeMillis())));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_OPENCMS_VERSION_1,\n                    OpenCms.getSystemInfo().getVersionNumber() + \" [\" + OpenCms.getSystemInfo().getVersionId() + \"]\"));\n            if (serverInfo != null) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_SERVLET_CONTAINER_1, serverInfo));\n            }\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBAPP_NAME_1, getSystemInfo().getWebApplicationName()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_SERVLET_PATH_1, getSystemInfo().getServletPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_OPENCMS_CONTEXT_1, getSystemInfo().getOpenCmsContext()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(Messages.INIT_WEBINF_PATH_1, getSystemInfo().getWebInfRfsPath()));\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_PROPERTY_FILE_1,\n                    getSystemInfo().getConfigurationFileRfsPath()));\n\n            String logFileRfsPath = getSystemInfo().getLogFileRfsPath();\n            CmsLog.INIT.info(\n                Messages.get().getBundle().key(\n                    Messages.INIT_LOG_FILE_1,\n                    logFileRfsPath != null ? logFileRfsPath : \"Managed by log4j\"));\n        }\n\n        String systemEncoding = null;\n        try {\n            systemEncoding = System.getProperty(\"file.encoding\");\n        } catch (SecurityException se) {\n            // security manager is active, but we will try other options before giving up\n            LOG.debug(\"Security manager preventing access to file.encoding system property.\", se);\n        }\n        Security.addProvider(new CryptixCrypto());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FILE_ENCODING_1, systemEncoding));\n        }\n\n        // read server ethernet address (MAC) and init UUID generator\n        String ethernetAddress = configuration.getString(\"server.ethernet.address\", CmsStringUtil.getEthernetAddress());\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_ETHERNET_ADDRESS_1, ethernetAddress));\n        }\n        CmsUUID.init(ethernetAddress);\n\n        // set the server name\n        String serverName = configuration.getString(\"server.name\", \"OpenCmsServer\");\n        getSystemInfo().setServerName(serverName);\n\n        // check the installed Java SDK\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                String jdkinfo = System.getProperty(\"java.vm.name\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.version\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.info\") + \" \";\n                jdkinfo += System.getProperty(\"java.vm.vendor\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_JAVA_VM_1, jdkinfo));\n                String osinfo = System.getProperty(\"os.name\") + \" \";\n                osinfo += System.getProperty(\"os.version\") + \" \";\n                osinfo += System.getProperty(\"os.arch\") + \" \";\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPERATING_SYSTEM_1, osinfo));\n            }\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_PROP_0), e);\n        }\n\n        // create the configuration manager instance\n        m_configurationManager = new CmsConfigurationManager(getSystemInfo().getConfigFolder());\n        // store the configuration read from \"opencms.properties\" in the configuration manager\n        m_configurationManager.setConfiguration(configuration);\n\n        // now load the XML configuration\n        try {\n            m_configurationManager.loadXmlConfiguration();\n        } catch (Exception e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_XML_0), e);\n        }\n\n        // get the system configuration\n        CmsSystemConfiguration systemConfiguration = (CmsSystemConfiguration)m_configurationManager.getConfiguration(\n            CmsSystemConfiguration.class);\n\n        if (systemConfiguration.useSaxImplSystemProperties()) {\n            CmsXmlUtils.initSystemProperties();\n        }\n\n        // initialize the memory monitor\n        CmsMemoryMonitorConfiguration memoryMonitorConfiguration = systemConfiguration.getCmsMemoryMonitorConfiguration();\n        // initialize the memory monitor\n        try {\n            if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(memoryMonitorConfiguration.getClassName())) {\n                m_memoryMonitor = (CmsMemoryMonitor)Class.forName(\n                    memoryMonitorConfiguration.getClassName()).newInstance();\n            } else {\n                m_memoryMonitor = new CmsMemoryMonitor();\n            }\n        } catch (Exception e) {\n            // we can not start without a valid memory monitor\n            throw new CmsInitException(\n                Messages.get().container(\n                    Messages.ERR_CRITICAL_INIT_MEMORY_MONITOR_1,\n                    memoryMonitorConfiguration.getClassName()),\n                e);\n        }\n        m_memoryMonitor.initialize(systemConfiguration);\n\n        // get the event manager from the configuration and initialize it with the events already registered\n        CmsEventManager configuredEventManager = systemConfiguration.getEventManager();\n        configuredEventManager.initialize(m_eventManager);\n        m_eventManager = configuredEventManager;\n\n        // check if the encoding setting is valid\n        String setEncoding = systemConfiguration.getDefaultContentEncoding();\n        String defaultEncoding = CmsEncoder.lookupEncoding(setEncoding, null);\n        if (defaultEncoding == null) {\n            // we can not start without a valid encoding setting\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ENCODING_1, setEncoding));\n        }\n        if (CmsLog.INIT.isInfoEnabled()) {\n            CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPENCMS_ENCODING_1, defaultEncoding));\n        }\n        getSystemInfo().setDefaultEncoding(defaultEncoding);\n\n        // set version history information\n        getSystemInfo().setVersionHistorySettings(\n            systemConfiguration.isHistoryEnabled(),\n            systemConfiguration.getHistoryVersions(),\n            systemConfiguration.getHistoryVersionsAfterDeletion());\n        // set mail configuration\n        getSystemInfo().setMailSettings(systemConfiguration.getMailSettings());\n        // set HTTP authentication settings\n        getSystemInfo().setHttpAuthenticationSettings(systemConfiguration.getHttpAuthenticationSettings());\n        getSystemInfo().setRestrictDetailContents(systemConfiguration.isRestrictDetailContents());\n\n        // set content notification settings\n        getSystemInfo().setNotificationTime(systemConfiguration.getNotificationTime());\n        getSystemInfo().setNotificationProject(systemConfiguration.getNotificationProject());\n        m_executor = new ScheduledThreadPoolExecutor(2);\n        // set resource init classes\n        m_resourceInitHandlers = systemConfiguration.getResourceInitHandlers();\n        // register request handler classes\n        Iterator<I_CmsRequestHandler> it = systemConfiguration.getRequestHandlers().iterator();\n        while (it.hasNext()) {\n            I_CmsRequestHandler handler = it.next();\n            addRequestHandler(handler);\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(\n                    Messages.get().getBundle().key(\n                        Messages.INIT_REQUEST_HANDLER_CLASS_1,\n                        handler.getClass().getName()));\n            }\n        }\n\n        // read the default user configuration\n        m_defaultUsers = systemConfiguration.getCmsDefaultUsers();\n\n        // get the site manager from the configuration\n        CmsSitesConfiguration sitesConfiguration = (CmsSitesConfiguration)m_configurationManager.getConfiguration(\n            CmsSitesConfiguration.class);\n        m_siteManager = sitesConfiguration.getSiteManager();\n\n        CmsSchedulerConfiguration schedulerConfiguration = (CmsSchedulerConfiguration)m_configurationManager.getConfiguration(\n            CmsSchedulerConfiguration.class);\n        // set the scheduler manager\n        m_scheduleManager = schedulerConfiguration.getScheduleManager();\n\n        CmsVariablesConfiguration variablesConfiguration = (CmsVariablesConfiguration)m_configurationManager.getConfiguration(\n            CmsVariablesConfiguration.class);\n\n        // get the VFS / resource configuration\n        CmsVfsConfiguration vfsConfiguation = (CmsVfsConfiguration)m_configurationManager.getConfiguration(\n            CmsVfsConfiguration.class);\n        m_resourceManager = vfsConfiguation.getResourceManager();\n        m_xmlContentTypeManager = vfsConfiguation.getXmlContentTypeManager();\n        m_defaultFiles = vfsConfiguation.getDefaultFiles();\n\n        // initialize translation engines\n        m_resourceManager.setTranslators(\n            vfsConfiguation.getFolderTranslator(),\n            vfsConfiguation.getFileTranslator(),\n            vfsConfiguation.getXsdTranslator());\n\n        // try to initialize the flex cache\n        CmsFlexCache flexCache = null;\n        try {\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_STARTING_0));\n            }\n            // get the flex cache configuration from the SystemConfiguration\n            CmsFlexCacheConfiguration flexCacheConfiguration = systemConfiguration.getCmsFlexCacheConfiguration();\n            getSystemInfo().setDeviceSelector(flexCacheConfiguration.getDeviceSelector());\n            // pass configuration to flex cache for initialization\n            flexCache = new CmsFlexCache(flexCacheConfiguration);\n            m_flexCache = flexCache;\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_FINISHED_0));\n            }\n        } catch (Exception e) {\n            if (CmsLog.INIT.isWarnEnabled()) {\n                CmsLog.INIT.warn(Messages.get().getBundle().key(Messages.INIT_FLEX_CACHE_ERROR_1, e.getMessage()));\n            }\n        }\n\n        if (flexCache != null) {\n            // check all resource loaders if they require the Flex cache\n            Iterator<I_CmsResourceLoader> i = m_resourceManager.getLoaders().iterator();\n            while (i.hasNext()) {\n                Object o = i.next();\n                if (o instanceof I_CmsFlexCacheEnabledLoader) {\n                    // this resource loader requires the Flex cache\n                    ((I_CmsFlexCacheEnabledLoader)o).setFlexCache(flexCache);\n                }\n            }\n        }\n\n        // get the import/export configuration\n        CmsImportExportConfiguration importExportConfiguration = (CmsImportExportConfiguration)m_configurationManager.getConfiguration(\n            CmsImportExportConfiguration.class);\n        m_importExportManager = importExportConfiguration.getImportExportManager();\n        m_staticExportManager = importExportConfiguration.getStaticExportManager();\n        m_repositoryManager = importExportConfiguration.getRepositoryManager();\n\n        // get the search configuration\n        CmsSearchConfiguration searchConfiguration = (CmsSearchConfiguration)m_configurationManager.getConfiguration(\n            CmsSearchConfiguration.class);\n        m_searchManager = searchConfiguration.getSearchManager();\n\n        // get the workplace configuration\n        CmsWorkplaceConfiguration workplaceConfiguration = (CmsWorkplaceConfiguration)m_configurationManager.getConfiguration(\n            CmsWorkplaceConfiguration.class);\n        m_workplaceManager = workplaceConfiguration.getWorkplaceManager();\n        // add the export points from the workplace\n        addExportPoints(m_workplaceManager.getExportPoints());\n        addExportPoints(m_staticExportManager.getExportPoints());\n\n        // get the module configuration\n        CmsModuleConfiguration moduleConfiguration = (CmsModuleConfiguration)m_configurationManager.getConfiguration(\n            CmsModuleConfiguration.class);\n        m_moduleManager = moduleConfiguration.getModuleManager();\n\n        // get the password handler\n        m_passwordHandler = systemConfiguration.getPasswordHandler();\n\n        // get the validation handler\n        m_validationHandler = systemConfiguration.getValidationHandler();\n\n        // get the authorization handler\n        m_authorizationHandler = systemConfiguration.getAuthorizationHandler();\n\n        // get the login manager\n        m_loginManager = systemConfiguration.getLoginManager();\n        // set the login message\n        try {\n            m_loginManager.setLoginMessage(null, variablesConfiguration.getLoginMessage());\n            m_loginManager.setBeforeLoginMessage(null, variablesConfiguration.getBeforeLoginMessage());\n        } catch (CmsRoleViolationException e1) {\n            CmsLog.INIT.error(e1.getLocalizedMessage(), e1);\n        }\n\n        // initialize the publish engine\n        m_publishEngine = new CmsPublishEngine(systemConfiguration.getRuntimeInfoFactory());\n\n        // Credentials resolver - needs to be set before the driver manager is initialized\n        m_credentialsResolver = systemConfiguration.getCredentialsResolver();\n\n        // init the OpenCms security manager\n        m_securityManager = CmsSecurityManager.newInstance(\n            m_configurationManager,\n            systemConfiguration.getRuntimeInfoFactory(),\n            m_publishEngine);\n\n        // get the publish manager\n        m_publishManager = systemConfiguration.getPublishManager();\n\n        // get the subscription manager\n        m_subscriptionManager = systemConfiguration.getSubscriptionManager();\n\n        // initialize the role manager\n        m_roleManager = new CmsRoleManager(m_securityManager);\n\n        // initialize the organizational unit manager\n        m_orgUnitManager = new CmsOrgUnitManager(m_securityManager);\n\n        // initialize the Thread store\n        m_threadStore = new CmsThreadStore(m_securityManager);\n\n        // initialize the link manager\n        m_linkManager = new CmsLinkManager(m_staticExportManager.getLinkSubstitutionHandler());\n\n        m_aliasManager = new CmsAliasManager(m_securityManager);\n\n        // store the runtime properties\n        m_runtimeProperties.putAll(systemConfiguration.getRuntimeProperties());\n\n        // initialize the session storage provider\n        I_CmsSessionStorageProvider sessionStorageProvider = systemConfiguration.getSessionStorageProvider();\n\n        // get an Admin cms context object with site root set to \"/\"\n        CmsObject adminCms;\n        try {\n            adminCms = initCmsObject(null, null, getDefaultUsers().getUserAdmin(), (String)null, (String)null);\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_ADMINCMS_0), e);\n        }\n\n        m_repositoryManager.initializeCms(adminCms);\n        // now initialize the other managers\n        try {\n            if (flexCache != null) {\n                flexCache.initializeCms(initCmsObject(adminCms));\n            }\n\n            m_configurationManager.setAdminCms(adminCms);\n\n            // initialize the scheduler\n            m_scheduleManager.initialize(initCmsObject(adminCms));\n\n            // initialize the locale manager\n            m_localeManager = systemConfiguration.getLocaleManager();\n            m_localeManager.initialize(initCmsObject(adminCms));\n\n            // initialize the site manager\n            m_siteManager.initialize(initCmsObject(adminCms));\n\n            // initialize the static export manager\n            m_staticExportManager.initialize(initCmsObject(adminCms));\n\n            // initialize the XML content type manager\n            m_xmlContentTypeManager.initialize(initCmsObject(adminCms));\n\n            m_orgUnitManager.initialize(initCmsObject(adminCms));\n\n            // initialize the module manager\n            m_moduleManager.initialize(initCmsObject(adminCms), m_configurationManager);\n\n            // initialize the resource manager\n            m_resourceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the publish manager\n            m_publishManager.setPublishEngine(m_publishEngine);\n            m_publishManager.setSecurityManager(m_securityManager);\n            m_publishManager.setPublishListRemoveMode(systemConfiguration.getPublishListRemoveMode());\n            m_publishManager.initialize(initCmsObject(adminCms));\n\n            // initialize the search manager\n            m_searchManager.initialize(initCmsObject(adminCms));\n\n            // initialize the VFS bundle manager\n            m_vfsBundleManager = new CmsVfsBundleManager(adminCms);\n\n            // initialize the workplace manager\n            m_workplaceManager.initialize(initCmsObject(adminCms));\n\n            // initialize the session manager\n            m_sessionManager.initialize(sessionStorageProvider);\n            m_sessionManager.setUserSessionMode(systemConfiguration.getUserSessionMode(true));\n\n            // initialize the subscription manager\n            m_subscriptionManager.setSecurityManager(m_securityManager);\n            m_subscriptionManager.initialize(adminCms);\n\n            // initialize the formatter configuration\n            CmsFormatterConfiguration.initialize(adminCms);\n            CmsPersistentLoginTokenHandler.setAdminCms(initCmsObject(adminCms));\n            CmsLoginUI.setAdminCmsObject(initCmsObject(adminCms));\n\n            // initialize ade manager\n            m_adeManager = new CmsADEManager(initCmsObject(adminCms), m_memoryMonitor, systemConfiguration);\n            m_workplaceAppManager = new CmsWorkplaceAppManager(initCmsObject(adminCms));\n            m_workplaceAppManager.loadApps();\n            m_workplaceAppManager.initWorkplaceCssUris(m_moduleManager);\n\n            m_templateContextManager = new CmsTemplateContextManager(initCmsObject(adminCms));\n            m_workflowManager = systemConfiguration.getWorkflowManager();\n            m_letsEncryptConfig = systemConfiguration.getLetsEncryptConfig();\n            if (m_workflowManager == null) {\n                m_workflowManager = new CmsDefaultWorkflowManager();\n                m_workflowManager.setParameters(new HashMap<String, String>());\n            }\n            m_workflowManager.initialize(adminCms);\n\n            m_remoteShellServer = CmsRemoteShellServer.initialize(systemConfiguration);\n\n        } catch (CmsException e) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_MANAGERS_0), e);\n        }\n\n        try {\n            // mitigate potential stringtemplate 3 class loading deadlock by making sure the class is loaded on startup\n            @SuppressWarnings(\"unused\")\n            StringTemplate stringTemplate = new org.antlr.stringtemplate.StringTemplate();\n        } catch (Exception e) {\n            CmsLog.INIT.error(\"Problem with initializing stringtemplate class: \" + e.getLocalizedMessage(), e);\n        }\n\n        try {\n            getEventManager().fireEvent(I_CmsEventListener.EVENT_CLEAR_CACHES);\n        } catch (Exception e) {\n            CmsLog.INIT.error(\"Problem with clearing caches after initialization: \" + e.getLocalizedMessage(), e);\n        }\n    }\n\n    /**\n     * Initialization of the OpenCms runtime environment.<p>\n     *\n     * The connection information for the database is read\n     * from the <code>opencms.properties</code> configuration file and all\n     * driver manager are initialized via the initializer,\n     * which usually will be an instance of a <code>OpenCms</code> class.\n     *\n     * @param context configuration of OpenCms from <code>web.xml</code>\n     * @throws CmsInitException in case OpenCms can not be initialized\n     */\n    protected synchronized void initContext(ServletContext context) throws CmsInitException {\n\n        m_gwtServiceContexts = new HashMap<String, CmsGwtServiceContext>();\n\n        // automatic servlet container recognition and specific behavior:\n        CmsServletContainerSettings servletContainerSettings = new CmsServletContainerSettings(context);\n        getSystemInfo().init(servletContainerSettings);\n\n        // Collect the configurations\n        CmsParameterConfiguration configuration;\n        try {\n            configuration = new CmsParameterConfiguration(getSystemInfo().getConfigurationFileRfsPath());\n        } catch (Exception e) {\n            throw new CmsInitException(\n                Messages.get().container(\n                    Messages.ERR_CRITICAL_INIT_PROPFILE_1,\n                    getSystemInfo().getConfigurationFileRfsPath()),\n                e);\n        }\n\n        String throwException = configuration.getString(\"servlet.exception.enabled\", \"auto\");\n        if (!throwException.equals(\"auto\")) {\n            // set the parameter is not automatic, the rest of the servlet container dependent parameters\n            // will be set when reading the system configuration, if not set to auto\n            boolean throwExc = Boolean.valueOf(throwException).booleanValue();\n            getSystemInfo().getServletContainerSettings().setServletThrowsException(throwExc);\n        }\n\n        // check if the wizard is enabled, if so stop initialization\n        if (configuration.getBoolean(\"wizard.enabled\", true)) {\n            throw new CmsInitException(Messages.get().container(Messages.ERR_CRITICAL_INIT_WIZARD_0));\n        }\n\n        // add an indicator that the configuration was processed from the servlet context\n        configuration.add(\"context.servlet.container\", context.getServerInfo());\n\n        // output startup message and copyright to STDERR\n        System.err.println(\n            Messages.get().getBundle().key(\n                Messages.LOG_STARTUP_CONSOLE_NOTE_2,\n                OpenCms.getSystemInfo().getVersionNumber(),\n                getSystemInfo().getWebApplicationName()));\n        for (int i = 0; i < Messages.COPYRIGHT_BY_ALKACON.length; i++) {\n            System.err.println(Messages.COPYRIGHT_BY_ALKACON[i]);\n        }\n        System.err.println();\n\n        // initialize the configuration\n        initConfiguration(configuration);\n    }\n\n    /**\n     * Initialize member variables.<p>\n     */\n    protected void initMembers() {\n\n        synchronized (LOCK) {\n            m_resourceInitHandlers = new ArrayList<I_CmsResourceInit>();\n            m_requestHandlers = new HashMap<String, I_CmsRequestHandler>();\n            m_systemInfo = new CmsSystemInfo();\n            m_exportPoints = Collections.emptySet();\n            m_defaultUsers = new CmsDefaultUsers();\n            m_localeManager = new CmsLocaleManager(Locale.ENGLISH);\n            m_sessionManager = new CmsSessionManager();\n            m_runtimeProperties = new Hashtable<Object, Object>();\n            // the default event manager must be available because the configuration already registers events\n            m_eventManager = new CmsEventManager();\n            // default link manager is required for test cases\n            m_linkManager = new CmsLinkManager(new CmsDefaultLinkSubstitutionHandler());\n        }\n    }\n\n    /**\n     * Reads the requested resource from the OpenCms VFS,\n     * in case a directory name is requested, the default files of the\n     * directory will be looked up and the first match is returned.<p>\n     *\n     * The resource that is returned is always a <code>{@link org.opencms.file.CmsFile}</code>,\n     * even though the content will usually not be loaded in the result. Folders are never returned since\n     * the point of this method is really to load the default file if just a folder name is requested. If\n     * there is no default file in a folder, then the return value is null and no CmsException is thrown.<p>\n     *\n     * The URI stored in the given OpenCms user context will be changed to the URI of the resource\n     * that was found and returned.<p>\n     *\n     * Implementing and configuring an <code>{@link I_CmsResourceInit}</code> handler\n     * allows to customize the process of default resource selection.<p>\n     *\n     * @param cms the current users OpenCms context\n     * @param resourceName the path of the requested resource in the OpenCms VFS\n     * @param req the current http request\n     * @param res the current http response\n     *\n     * @return the requested resource read from the VFS\n     *\n     * @throws CmsException in case the requested file does not exist or the user has insufficient access permissions\n     *\n     * @see OpenCms#initResource(CmsObject, String, HttpServletRequest, HttpServletResponse)\n     */\n    protected CmsResource initResource(\n        CmsObject cms,\n        String resourceName,\n        HttpServletRequest req,\n        HttpServletResponse res)\n    throws CmsException {\n\n        CmsException tmpException = null;\n        CmsResource resource;\n        boolean handledSecure = false;\n\n        try {\n            // try to read the requested resource\n            resource = cms.readDefaultFile(resourceName);\n        } catch (CmsException e) {\n            // file or folder with given name does not exist, store exception\n            tmpException = e;\n            resource = null;\n        }\n\n        if (resource != null) {\n            // set the request uri to the right file\n            cms.getRequestContext().setUri(cms.getSitePath(resource));\n            // test if this file is only available for internal access operations\n            if (resource.isInternal()) {\n                throw new CmsException(\n                    Messages.get().container(Messages.ERR_READ_INTERNAL_RESOURCE_1, cms.getRequestContext().getUri()));\n            }\n\n            resource = handleSecureResource(cms, req, res, resource, resourceName);\n            if (resource == null) {\n                handledSecure = true;\n\n            }\n        }\n\n        boolean clearErrors = false;\n        // test if this file has to be checked or modified\n        for (I_CmsResourceInit handler : m_resourceInitHandlers) {\n            try {\n                resource = handler.initResource(resource, cms, req, res);\n                // the loop has to be interrupted when the exception is thrown!\n            } catch (CmsResourceInitException e) {\n                if (e.isClearErrors()) {\n                    tmpException = null;\n                    clearErrors = true;\n                }\n                break;\n            } catch (CmsSecurityException e) {\n                tmpException = e;\n                break;\n            }\n        }\n\n        // file is still null and not found exception was thrown, so throw original exception\n        if (resource == null) {\n            if (tmpException != null) {\n                throw tmpException;\n            } else if (!clearErrors) {\n                throw new CmsVfsResourceNotFoundException(\n                    org.opencms.main.Messages.get().container(\n                        org.opencms.main.Messages.ERR_PATH_NOT_FOUND_1,\n                        resourceName));\n\n            }\n        } else {\n            if (!handledSecure) {\n                if (cms.getRequestContext().getDetailContentId() != null) {\n                    // in theory we should do this for all kinds of resource init handlers,\n                    // but I'm not clear on how to handle this in general, so only do this for detail pages for now\n                    resource = handleSecureResource(cms, req, res, resource, resourceName);\n                    handledSecure = true;\n                }\n            }\n        }\n\n        // return the resource read from the VFS\n        return resource;\n    }\n\n    /**\n     * Initializes the system with the OpenCms servlet.<p>\n     *\n     * This is the final step that is called on the servlets \"init()\" method.\n     * It registers the servlets request handler and also outputs the final\n     * startup message. The servlet should auto-load since the &ltload-on-startup&gt;\n     * parameter is set in the 'web.xml' by default.<p>\n     *\n     * @param servlet the OpenCms servlet\n     */\n    protected void initServlet(OpenCmsServlet servlet) {\n\n        synchronized (LOCK) {\n            // add the servlets request handler\n            addRequestHandler(servlet);\n\n            // output the final 'startup is finished' message\n            if (CmsLog.INIT.isInfoEnabled()) {\n                CmsLog.INIT.info(\n                    Messages.get().getBundle().key(\n                        Messages.INIT_SYSTEM_RUNNING_1,\n                        CmsStringUtil.formatRuntime(getSystemInfo().getRuntime())));\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n                CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n            }\n        }\n    }\n\n    /**\n     * Invokes the GWT servlet from within OpenCms.<p>\n     *\n     * @param serviceName the GWT PRC service class name\n     * @param req the current servlet request\n     * @param res the current servlet response\n     * @param servletConfig the servlet configuration\n     */\n    protected void invokeGwtService(\n        String serviceName,\n        HttpServletRequest req,\n        HttpServletResponse res,\n        ServletConfig servletConfig) {\n\n        CmsObject cms = null;\n        try {\n            // instantiate CMS context\n            cms = initCmsObject(req, res);\n            // instantiate GWT RPC service\n            CmsGwtService rpcService = getGwtService(serviceName, servletConfig);\n            // check permissions\n            rpcService.checkPermissions(cms);\n            // set runtime variables\n            rpcService.setCms(cms);\n            Object lock = req.getSession();\n            if (lock == null) {\n                lock = new Object();\n            }\n            rpcService.service(req, res);\n            // update the session info\n            m_sessionManager.updateSessionInfo(cms, req);\n        } catch (CmsRoleViolationException rv) {\n            // don't log these into the error channel\n            LOG.debug(rv.getLocalizedMessage(), rv);\n            // error code not set - set \"unauthorized error\" (401)\n            int status = HttpServletResponse.SC_UNAUTHORIZED;\n            res.setStatus(status);\n            try {\n                res.sendError(status, rv.toString());\n            } catch (IOException e) {\n                // can be ignored\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        } catch (Throwable t) {\n            // error code not set - set \"internal server error\" (500)\n            LOG.error(t.getLocalizedMessage(), t);\n            int status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n            res.setStatus(status);\n            try {\n                res.sendError(status, t.toString());\n            } catch (IOException e) {\n                // can be ignored\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * This method adds an Object to the OpenCms runtime properties.\n     * The runtime properties can be used to store Objects that are shared\n     * in the whole system.<p>\n     *\n     * @param key the key to add the Object with\n     * @param value the value of the Object to add\n     */\n    protected void setRuntimeProperty(Object key, Object value) {\n\n        m_runtimeProperties.put(key, value);\n    }\n\n    /**\n     * Displays a resource from the OpenCms by writing the result to the provided\n     * Servlet response output stream.<p>\n     *\n     * @param req the current servlet request\n     * @param res the current servlet response\n     */\n    protected void showResource(HttpServletRequest req, HttpServletResponse res) {\n\n        CmsObject cms = null;\n        try {\n            cms = initCmsObject(req, res);\n\n            if (cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n                String uri = cms.getRequestContext().getUri();\n                if (uri.startsWith(CmsWorkplace.VFS_PATH_SITES)) {\n                    // resources within the sites folder may only be called with their site relative path\n                    // this should prevent showing pages from other sites with their root path\n                    throw new CmsVfsResourceNotFoundException(\n                        org.opencms.main.Messages.get().container(org.opencms.main.Messages.ERR_PATH_NOT_FOUND_1, uri));\n                }\n                if (OpenCms.getStaticExportManager().isExportLink(cms, uri)) {\n                    // if we used the request's query string for getRfsName, clients could cause an unlimited number\n                    // of files to be exported just by varying the request parameters!\n                    String url = m_linkManager.getOnlineLink(cms, uri);\n                    res.sendRedirect(url);\n                    return;\n                }\n            }\n            List<CmsSiteMatcher> currentSiteAliase = m_siteManager.getCurrentSite(cms).getAliases();\n            CmsSiteMatcher currentSiteMatcher = cms.getRequestContext().getRequestMatcher();\n            if (currentSiteAliase.contains(currentSiteMatcher.forDifferentScheme(\"http\"))\n                || currentSiteAliase.contains(currentSiteMatcher.forDifferentScheme(\"https\"))) {\n                int pos = currentSiteAliase.indexOf(currentSiteMatcher.forDifferentScheme(\"http\"));\n                if (pos == -1) {\n                    pos = currentSiteAliase.indexOf(currentSiteMatcher.forDifferentScheme(\"https\"));\n                }\n                if (currentSiteAliase.get(pos).isRedirect()) {\n                    res.sendRedirect(\n                        m_siteManager.getCurrentSite(cms).getUrl() + req.getContextPath() + req.getPathInfo());\n                    return;\n                }\n            }\n\n            // user is initialized, now deliver the requested resource\n            CmsResource resource = initResource(cms, cms.getRequestContext().getUri(), req, res);\n            if (resource != null) {\n                // a file was read, go on process it\n                m_resourceManager.loadResource(cms, resource, req, res);\n                m_sessionManager.updateSessionInfo(cms, req);\n            }\n\n        } catch (Throwable t) {\n            errorHandling(cms, req, res, t);\n        }\n    }\n\n    /**\n     * Destroys this OpenCms instance, called if the servlet (or shell) is shut down.<p>\n     */\n    protected void shutDown() {\n\n        synchronized (LOCK) {\n            if (getRunLevel() > OpenCms.RUNLEVEL_0_OFFLINE) {\n                System.err.println(\n                    Messages.get().getBundle().key(\n                        Messages.LOG_SHUTDOWN_CONSOLE_NOTE_2,\n                        getSystemInfo().getVersionNumber(),\n                        getSystemInfo().getWebApplicationName()));\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n                    CmsLog.INIT.info(\n                        Messages.get().getBundle().key(\n                            Messages.INIT_SHUTDOWN_START_1,\n                            getSystemInfo().getVersionNumber() + \" [\" + getSystemInfo().getVersionId() + \"]\"));\n                    CmsLog.INIT.info(\n                        Messages.get().getBundle().key(Messages.INIT_CURRENT_RUNLEVEL_1, new Integer(getRunLevel())));\n                    CmsLog.INIT.info(\n                        Messages.get().getBundle().key(\n                            Messages.INIT_SHUTDOWN_TIME_1,\n                            new Date(System.currentTimeMillis())));\n                }\n\n                // take the system offline\n                setRunLevel(OpenCms.RUNLEVEL_0_OFFLINE);\n\n                if (LOG.isDebugEnabled()) {\n                    // log exception to see which method did call the shutdown\n                    LOG.debug(Messages.get().getBundle().key(Messages.LOG_SHUTDOWN_TRACE_0), new Exception());\n                }\n\n                try {\n                    // the first thing we have to do is to wait until the current publish process finishes\n                    if (null != m_publishEngine) {\n                        m_publishEngine.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_PUBLISH_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    // search manager must be shut down early since there may be background indexing still ongoing\n                    if (m_searchManager != null) {\n                        m_searchManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_SEARCH_MANAGER_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    // remote shell server must be shut down early since there is a background thread ongoing that reloads from the VFS\n                    if (m_remoteShellServer != null) {\n                        m_remoteShellServer.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_REMOTESHELL_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    // VFS bundle manager must be shut down early since there is a background thread ongoing that reloads from the VFS\n                    if (m_vfsBundleManager != null) {\n                        m_vfsBundleManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_VFSBUNDLE_MANAGER_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_staticExportManager != null) {\n                        m_staticExportManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_EXPORT_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_moduleManager != null) {\n                        m_moduleManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_MODULE_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n\n                try {\n                    if (m_executor != null) {\n                        m_executor.shutdownNow();\n                        m_executor.awaitTermination(30, TimeUnit.SECONDS);\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_MODULE_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n\n                try {\n                    if (m_scheduleManager != null) {\n                        m_scheduleManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_SCHEDULE_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_resourceManager != null) {\n                        m_resourceManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_RESOURCE_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n\n                try {\n                    if (m_repositoryManager != null) {\n                        m_repositoryManager.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(e.getLocalizedMessage(), e);\n                }\n\n                try {\n                    // has to be stopped before the security manager, since this thread uses it\n                    if (m_threadStore != null) {\n                        m_threadStore.shutDown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_THREAD_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_securityManager != null) {\n                        m_securityManager.destroy();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_SECURITY_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_sessionManager != null) {\n                        m_sessionManager.shutdown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_SESSION_MANAGER_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_memoryMonitor != null) {\n                        m_memoryMonitor.shutdown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_MEMORY_MONITOR_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n                try {\n                    if (m_adeManager != null) {\n                        m_adeManager.shutdown();\n                    }\n                } catch (Throwable e) {\n                    CmsLog.INIT.error(\n                        Messages.get().getBundle().key(Messages.LOG_ERROR_ADE_MANAGER_SHUTDOWN_1, e.getMessage()),\n                        e);\n                }\n\n                String runtime = CmsStringUtil.formatRuntime(getSystemInfo().getRuntime());\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_OPENCMS_STOPPED_1, runtime));\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_LINE_0));\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n                    CmsLog.INIT.info(Messages.get().getBundle().key(Messages.INIT_DOT_0));\n                }\n                System.err.println(Messages.get().getBundle().key(Messages.LOG_CONSOLE_TOTAL_RUNTIME_1, runtime));\n\n            }\n            m_instance = null;\n        }\n    }\n\n    /**\n     * This method updates the request context information.<p>\n     *\n     * The update information is:<br>\n     * <ul>\n     *   <li>Requested Url</li>\n     *   <li>Locale</li>\n     *   <li>Encoding</li>\n     *   <li>Remote Address</li>\n     *   <li>Request Time</li>\n     * </ul>\n     *\n     * @param request the current request\n     * @param cms the cms object to update the request context for\n     *\n     * @return a new updated cms context\n     *\n     * @throws CmsException if something goes wrong\n     */\n    protected CmsObject updateContext(HttpServletRequest request, CmsObject cms) throws CmsException {\n\n        // get the right site for the request\n        String siteRoot = null;\n        boolean isWorkplace = cms.getRequestContext().getUri().startsWith(\"/system/workplace/\")\n            || request.getRequestURI().startsWith(OpenCms.getSystemInfo().getWorkplaceContext());\n        if (isWorkplace && getRoleManager().hasRole(cms, CmsRole.ELEMENT_AUTHOR)) {\n            // keep the site root for workplace requests\n            siteRoot = cms.getRequestContext().getSiteRoot();\n        } else {\n            CmsSite site = OpenCms.getSiteManager().matchRequest(request);\n            siteRoot = site.getSiteRoot();\n        }\n        return initCmsObject(\n            request,\n            cms.getRequestContext().getCurrentUser(),\n            siteRoot,\n            cms.getRequestContext().getCurrentProject().getUuid(),\n            cms.getRequestContext().getOuFqn());\n    }\n\n    /**\n     * Upgrades to runlevel {@link OpenCms#RUNLEVEL_3_SHELL_ACCESS},\n     * this is shell access to the database but no Servlet context.<p>\n     *\n     * To upgrade the runlevel, the system must be in runlevel {@link OpenCms#RUNLEVEL_1_CORE_OBJECT},\n     * otherwise an exception is thrown.<p>\n     *\n     * @param configuration the configuration\n     * @throws CmsInitException in case OpenCms can not be initialized\n     * @return the initialized OpenCmsCore\n     */\n    protected OpenCmsCore upgradeRunlevel(CmsParameterConfiguration configuration) throws CmsInitException {\n\n        synchronized (LOCK) {\n            if ((m_instance != null) && (getRunLevel() >= OpenCms.RUNLEVEL_2_INITIALIZING)) {\n                // instance already in runlevel 3 or 4\n                return m_instance;\n            }\n            if (getRunLevel() != OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n                CmsLog.INIT.error(\n                    Messages.get().getBundle().key(\n                        Messages.LOG_WRONG_INIT_SEQUENCE_2,\n                        new Integer(3),\n                        new Integer(getRunLevel())));\n                return m_instance;\n            }\n\n            // set the runlevel to \"initializing OpenCms\"\n            setRunLevel(OpenCms.RUNLEVEL_2_INITIALIZING);\n            // initialize the configuration\n            m_instance.initConfiguration(configuration);\n            // upgrade the runlevel - OpenCms shell is available\n            setRunLevel(OpenCms.RUNLEVEL_3_SHELL_ACCESS);\n\n            afterUpgradeRunlevel();\n\n            return m_instance;\n        }\n    }\n\n    /**\n     * Upgrades to runlevel {@link OpenCms#RUNLEVEL_4_SERVLET_ACCESS},\n     * this is the final runlevel with an initialized database and Servlet context.<p>\n     *\n     * To upgrade the runlevel, the system must be in runlevel {@link OpenCms#RUNLEVEL_1_CORE_OBJECT},\n     * otherwise an exception is thrown.<p>\n     *\n     * @param context the current servlet context\n     * @throws CmsInitException in case OpenCms can not be initialized\n     * @return the initialized OpenCmsCore\n     */\n    protected OpenCmsCore upgradeRunlevel(ServletContext context) throws CmsInitException {\n\n        synchronized (LOCK) {\n            if ((m_instance != null) && (getRunLevel() >= OpenCms.RUNLEVEL_4_SERVLET_ACCESS)) {\n                // instance already in runlevel 5 or 6\n                return m_instance;\n            }\n            if (getRunLevel() != OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n                CmsLog.INIT.error(\n                    Messages.get().getBundle().key(\n                        Messages.LOG_WRONG_INIT_SEQUENCE_2,\n                        new Integer(4),\n                        new Integer(getRunLevel())));\n                return m_instance;\n            }\n\n            // set the runlevel to \"initializing OpenCms\"\n            setRunLevel(OpenCms.RUNLEVEL_2_INITIALIZING);\n            // initialize the servlet context\n            m_instance.initContext(context);\n            // initialization successfully finished - OpenCms servlet is online\n            // the runlevel will change from 2 directly to 4, this is on purpose\n            setRunLevel(OpenCms.RUNLEVEL_4_SERVLET_ACCESS);\n\n            afterUpgradeRunlevel();\n\n            return m_instance;\n        }\n    }\n\n    /**\n     * Writes the XML configuration for the provided configuration class.<p>\n     *\n     * @param clazz the configuration class to write the XML for\n     */\n    protected void writeConfiguration(Class<?> clazz) {\n\n        // exception handling is provided here to ensure identical log messages\n        try {\n            m_configurationManager.writeConfiguration(clazz);\n        } catch (IOException e) {\n            CmsLog.getLog(CmsConfigurationManager.class).error(\n                Messages.get().getBundle().key(Messages.LOG_ERROR_WRITING_CONFIG_1, clazz.getName()),\n                e);\n        } catch (CmsConfigurationException e) {\n            CmsLog.getLog(CmsConfigurationManager.class).error(\n                Messages.get().getBundle().key(Messages.LOG_ERROR_WRITING_CONFIG_1, clazz.getName()),\n                e);\n        }\n    }\n\n    /**\n     * Adds the given set of export points to the list of all configured export points.<p>\n     *\n     * @param exportPoints the export points to add\n     */\n    private void addExportPoints(Set<CmsExportPoint> exportPoints) {\n\n        // create a new immutable set of export points\n        HashSet<CmsExportPoint> newSet = new HashSet<CmsExportPoint>(m_exportPoints.size() + exportPoints.size());\n        newSet.addAll(exportPoints);\n        newSet.addAll(m_exportPoints);\n        m_exportPoints = Collections.unmodifiableSet(newSet);\n    }\n\n    /**\n     * Finishes the startup sequence after last runlevel upgrade.<p>\n     */\n    private void afterUpgradeRunlevel() {\n\n        try {\n            // read the persistent locks\n            m_instance.m_securityManager.readLocks();\n        } catch (CmsException e) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\n                    org.opencms.lock.Messages.get().getBundle().key(org.opencms.lock.Messages.ERR_READ_LOCKS_0),\n                    e);\n            }\n        }\n        // only init ADE manager in case of servlet initialization, it won't be needed in case of shell access\n        if (OpenCms.getRunLevel() == OpenCms.RUNLEVEL_4_SERVLET_ACCESS) {\n            CmsThreadStatsTreeProfilingHandler stats = new CmsThreadStatsTreeProfilingHandler();\n            try {\n                CmsDefaultProfilingHandler.INSTANCE.addHandler(stats);\n                m_adeManager.initialize();\n            } finally {\n                CmsDefaultProfilingHandler.INSTANCE.removeHandler(stats);\n                if (stats.hasData()) {\n                    String adeInitData = stats.dump();\n                    String prefix = String.format(\"%010X\", Long.valueOf(System.currentTimeMillis() / 1000));\n                    String path = OpenCms.getSystemInfo().getAbsoluteRfsPathRelativeToWebInf(\n                        \"logs/\" + prefix + \"_startup-ade-driver-report.xml\");\n                    try (FileOutputStream out = new FileOutputStream(path)) {\n                        out.write(adeInitData.getBytes(\"UTF-8\"));\n                    } catch (Exception e) {\n                        LOG.error(\n                            \"Could not write ADE init profiling data to file, writing to log instead: \"\n                                + e.getLocalizedMessage(),\n                            e);\n                        LOG.error(adeInitData);\n                    }\n                }\n            }\n        }\n        // everything is initialized, now start publishing\n        m_publishManager.startPublishing();\n    }\n\n    /**\n     * This method performs the error handling for OpenCms.<p>\n     *\n     * @param cms the current cms context, might be null !\n     * @param req the client request\n     * @param res the client response\n     * @param t the exception that occurred\n     */\n    private void errorHandling(CmsObject cms, HttpServletRequest req, HttpServletResponse res, Throwable t) {\n\n        // remove the controller attribute from the request\n        CmsFlexController.removeController(req);\n\n        boolean canWrite = (!res.isCommitted() && !res.containsHeader(\"Location\"));\n        int status = -1;\n        boolean isGuest = true;\n\n        if (t instanceof ServletException) {\n            ServletException s = (ServletException)t;\n            if (s.getRootCause() != null) {\n                t = s.getRootCause();\n            }\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else if (t instanceof CmsSecurityException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // access error - display login dialog\n            if (canWrite) {\n                try {\n                    m_authorizationHandler.requestAuthorization(req, res, getLoginFormURL(req, res));\n                } catch (IOException ioe) {\n                    LOG.debug(\"Error calling authorization handler.\", ioe);\n                }\n                return;\n            }\n        } else if (t instanceof CmsDbEntryNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // user or group does not exist\n            status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;\n            isGuest = false;\n        } else if (t instanceof CmsVfsResourceNotFoundException) {\n            LOG.warn(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            // file not found - display 404 error.\n            status = HttpServletResponse.SC_NOT_FOUND;\n        } else if (t instanceof CmsException) {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n            if (t.getCause() != null) {\n                t = t.getCause();\n            }\n        } else if (t.getClass().getName().equals(\"org.apache.catalina.connector.ClientAbortException\")) {\n            // only log to debug channel any exceptions caused by a client abort - this is tomcat specific\n            LOG.debug(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        } else {\n            LOG.error(t.getLocalizedMessage() + \" rendering URL \" + req.getRequestURL(), t);\n        }\n\n        if (status < 1) {\n            // error code not set - set \"internal server error\" (500)\n            status = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n        }\n        res.setStatus(status);\n\n        try {\n            if ((cms != null) && (cms.getRequestContext().getCurrentUser() != null)) {\n                isGuest = isGuest\n                    && (cms.getRequestContext().getCurrentUser().isGuestUser()\n                        || cms.userInGroup(\n                            cms.getRequestContext().getCurrentUser().getName(),\n                            OpenCms.getDefaultUsers().getGroupGuests()));\n            }\n        } catch (CmsException e) {\n            // result is false\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        if (canWrite) {\n            res.setContentType(\"text/html\");\n            CmsRequestUtil.setNoCacheHeaders(res);\n            if ((status != 404)\n                && !isGuest\n                && (cms != null)\n                && (!CmsJsonPartFilter.isJsonRequest(req))\n                && !cms.getRequestContext().getCurrentProject().isOnlineProject()) {\n                try {\n                    res.setStatus(HttpServletResponse.SC_OK);\n                    res.getWriter().print(CmsErrorUI.getBootstrapPage(cms, t, req));\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            } else {\n                try {\n                    res.sendError(status, t.toString());\n                } catch (IOException e) {\n                    // can be ignored\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     *\n     * @param serviceName the GWT PRC service class name\n     * @param servletConfig the servlet configuration\n     *\n     * @return the GWT service instance\n     *\n     * @throws Throwable if something goes wrong\n     */\n    private synchronized CmsGwtService getGwtService(String serviceName, ServletConfig servletConfig) throws Throwable {\n\n        CmsGwtServiceContext context = m_gwtServiceContexts.get(serviceName);\n        if (context == null) {\n            context = new CmsGwtServiceContext(serviceName);\n            m_gwtServiceContexts.put(serviceName, context);\n        }\n        CmsGwtService gwtService = (CmsGwtService)Class.forName(serviceName).newInstance();\n        gwtService.init(servletConfig);\n        gwtService.setContext(context);\n        return gwtService;\n    }\n\n    /**\n     * Reads the login form which should be used for authenticating the current request.<p>\n     *\n     * @param req current request\n     * @param res current response\n     *\n     * @return the URL of the login form or <code>null</code> if not set\n     *\n     * @throws IOException in case of IO errors\n     */\n    private String getLoginFormURL(HttpServletRequest req, HttpServletResponse res) throws IOException {\n\n        CmsHttpAuthenticationSettings httpAuthenticationSettings = OpenCms.getSystemInfo().getHttpAuthenticationSettings();\n        String loginFormURL = null;\n\n        // this will create an admin user with the \"right\" site root already set\n        CmsObject adminCms;\n        try {\n            adminCms = initCmsObject(req, res, OpenCms.getDefaultUsers().getUserAdmin(), null, null);\n        } catch (CmsException e) {\n            // this should never happen, if it does we can't continue\n            throw new IOException(\n                Messages.get().getBundle().key(\n                    Messages.ERR_INVALID_INIT_USER_2,\n                    OpenCms.getDefaultUsers().getUserAdmin(),\n\n                    null),\n                e);\n        }\n        // get the requested resource\n        String path = adminCms.getRequestContext().getUri();\n        CmsProperty propertyLoginForm = null;\n        try {\n            propertyLoginForm = adminCms.readPropertyObject(path, CmsPropertyDefinition.PROPERTY_LOGIN_FORM, true);\n        } catch (Throwable t) {\n            if (t instanceof CmsVfsResourceNotFoundException) {\n                // if we can't read the property from the path, try to use the resource init handlers to find the\n                // resource to read it from\n                CmsResource alternativeResource = null;\n                try {\n                    // use null as the response to avoid side effects like redirects, etc.\n                    alternativeResource = initResource(adminCms, path, req, null);\n                    if (alternativeResource != null) {\n                        propertyLoginForm = adminCms.readPropertyObject(\n                            adminCms.getSitePath(alternativeResource),\n                            CmsPropertyDefinition.PROPERTY_LOGIN_FORM,\n                            true);\n                    }\n                } catch (Exception e) {\n                    LOG.error(e.getLocalizedMessage(), e);\n                }\n            }\n\n            if (propertyLoginForm == null) {\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\n                        Messages.get().getBundle().key(\n                            Messages.LOG_ERROR_READING_AUTH_PROP_2,\n                            CmsPropertyDefinition.PROPERTY_LOGIN_FORM,\n                            path),\n                        t);\n                }\n\n            }\n        }\n\n        String params = null;\n        if ((propertyLoginForm != null)\n            && (propertyLoginForm != CmsProperty.getNullProperty())\n            && CmsStringUtil.isNotEmpty(propertyLoginForm.getValue())) {\n            // login form property value was found\n            // build a redirect URL using the value of the property\n            // \"__loginform\" is a dummy request parameter that could be used in a JSP template to trigger\n            // if the template should display a login formular or not\n            loginFormURL = propertyLoginForm.getValue();\n            params = \"__loginform=true\";\n        } else if (!httpAuthenticationSettings.useBrowserBasedHttpAuthentication()\n            && CmsStringUtil.isNotEmpty(httpAuthenticationSettings.getFormBasedHttpAuthenticationUri())) {\n            // login form property value not set, but form login set in configuration\n            // build a redirect URL to the default login form URI configured in opencms.properties\n            loginFormURL = httpAuthenticationSettings.getFormBasedHttpAuthenticationUri();\n        }\n\n        String callbackURL = CmsRequestUtil.encodeParamsWithUri(path, req);\n        if (loginFormURL != null) {\n            if (!loginFormURL.startsWith(\"http\")) {\n                loginFormURL = m_linkManager.substituteLink(adminCms, loginFormURL, null, true);\n            } else {\n                callbackURL = m_linkManager.getServerLink(adminCms, path);\n                callbackURL = CmsRequestUtil.encodeParamsWithUri(callbackURL, req);\n            }\n        }\n\n        return m_authorizationHandler.getLoginFormURL(loginFormURL, params, callbackURL);\n    }\n\n    /**\n     * If we are in the Online project, check if the given resource is marked as secure, and handle it according to the secure server configuration.<p>\n     *\n     * @param cms the current CMS context\n     * @param req the current request\n     * @param res the current response\n     * @param resource the resource to check\n     * @param resourceName the resource path from the request\n     *\n     * @return the resource to replace the original resource\n     *\n     * @throws CmsException if something goes wrong\n     * @throws CmsVfsResourceNotFoundException if the resource could not be found\n     */\n    private CmsResource handleSecureResource(\n        CmsObject cms,\n        HttpServletRequest req,\n        HttpServletResponse res,\n        CmsResource resource,\n        String resourceName)\n    throws CmsException, CmsVfsResourceNotFoundException {\n\n        // check online project\n        if (cms.getRequestContext().getCurrentProject().isOnlineProject() && (res != null)) {\n            boolean secure = false;\n            try {\n                // check if resource is secure\n                secure = Boolean.valueOf(\n                    cms.readPropertyObject(\n                        cms.getSitePath(resource),\n                        CmsPropertyDefinition.PROPERTY_SECURE,\n                        true).getValue()).booleanValue();\n            } catch (CmsVfsResourceNotFoundException e) {\n                LOG.warn(e.getLocalizedMessage(), e);\n            } catch (CmsException e) {\n                LOG.error(e.getLocalizedMessage(), e);\n            }\n            if (secure) {\n                CmsResource resource1 = resource;\n                // resource is secure, check site config\n                CmsSite site = OpenCms.getSiteManager().getCurrentSite(cms);\n                // check the secure url\n                String secureUrl = null;\n                try {\n                    secureUrl = site.getSecureUrl();\n                } catch (Exception e) {\n                    LOG.error(\n                        Messages.get().getBundle().key(Messages.ERR_SECURE_SITE_NOT_CONFIGURED_1, resourceName),\n                        e);\n                    throw new CmsException(\n                        Messages.get().container(Messages.ERR_SECURE_SITE_NOT_CONFIGURED_1, resourceName),\n                        e);\n                }\n                boolean usingSec = true;\n                if (req != null) {\n                    usingSec = req.getRequestURL().toString().toUpperCase().startsWith(secureUrl.toUpperCase());\n                }\n                if (site.isExclusiveUrl() && !usingSec) {\n                    resource1 = null;\n                    // secure resource without secure protocol, check error config\n                    if (site.isExclusiveError()) {\n                        // trigger 404 error\n                        throw new CmsVfsResourceNotFoundException(\n                            Messages.get().container(Messages.ERR_REQUEST_SECURE_RESOURCE_0));\n                    } else {\n                        // redirect\n                        String target = OpenCms.getLinkManager().getOnlineLink(cms, resourceName);\n                        if (!target.toLowerCase().startsWith(secureUrl.toLowerCase())) {\n                            Optional<String> targetWithReplacedHost = CmsStringUtil.replacePrefix(\n                                target,\n                                site.getSiteMatcher().getUrl(),\n                                secureUrl,\n                                true);\n                            if (targetWithReplacedHost.isPresent()) {\n                                target = targetWithReplacedHost.get();\n                            }\n                            if (!target.toLowerCase().startsWith(secureUrl.toLowerCase())) {\n                                LOG.warn(\"Failed to generate secure URL for \" + target + \", site = \" + site);\n                            }\n                        }\n\n                        try {\n                            if (site.usesPermanentRedirects()) {\n                                res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n                                res.setHeader(\"Location\", target);\n                            } else {\n                                res.sendRedirect(target);\n                            }\n                        } catch (Exception e) {\n                            // ignore, but should never happen\n                            LOG.error(\"Error sending secure resource redirect.\", e);\n                        }\n                    }\n                }\n                resource = resource1;\n            }\n\n        }\n        return resource;\n    }\n\n    /**\n     * Initializes a CmsObject with the given context information.<p>\n     *\n     * @param contextInfo the information for the CmsObject context to create\n     *\n     * @return the initialized CmsObject\n     *\n     * @throws CmsException if something goes wrong\n     */\n    private CmsObject initCmsObject(CmsContextInfo contextInfo) throws CmsException {\n\n        CmsUser user = contextInfo.getUser();\n        if (user == null) {\n            user = m_securityManager.readUser(null, contextInfo.getUserName());\n        }\n\n        CmsProject project = contextInfo.getProject();\n        if (project == null) {\n            project = m_securityManager.readProject(contextInfo.getProjectName());\n        }\n\n        // first create the request context\n        CmsRequestContext context = new CmsRequestContext(\n            user,\n            project,\n            contextInfo.getRequestedUri(),\n            contextInfo.getRequestMatcher(),\n            contextInfo.getSiteRoot(),\n            contextInfo.isSecureRequest(),\n            contextInfo.getLocale(),\n            contextInfo.getEncoding(),\n            contextInfo.getRemoteAddr(),\n            contextInfo.getRequestTime(),\n            m_resourceManager.getFolderTranslator(),\n            m_resourceManager.getFileTranslator(),\n            contextInfo.getOuFqn());\n        context.setDetailResource(contextInfo.getDetailResource());\n\n        // now initialize and return the CmsObject\n        return new CmsObject(m_securityManager, context);\n    }\n\n    /**\n     * Initializes a {@link CmsObject} with the given users information.<p>\n     *\n     * @param request the current http request (or <code>null</code>)\n     * @param user the initialized user\n     * @param siteRoot the users current site\n     * @param projectId the id of the users current project\n     * @param ouFqn the organizational unit\n     *\n     * @return the initialized CmsObject\n     *\n     * @throws CmsException in case something goes wrong\n     */\n    private CmsObject initCmsObject(\n        HttpServletRequest request,\n        CmsUser user,\n        String siteRoot,\n        CmsUUID projectId,\n        String ouFqn)\n    throws CmsException {\n\n        CmsProject project = null;\n        try {\n            project = m_securityManager.readProject(projectId);\n        } catch (CmsDbEntryNotFoundException e) {\n            // project not found, switch to online project\n            project = m_securityManager.readProject(CmsProject.ONLINE_PROJECT_ID);\n            LOG.debug(\"Project '\" + projectId + \"' was not found, switch to online project.\", e);\n        }\n\n        // get requested resource uri and remote IP address, as well as time for \"time warp\" browsing\n        String requestedResource = null;\n        Long requestTimeAttr = null;\n        String remoteAddr;\n        CmsSiteMatcher requestMatcher;\n\n        boolean isSecureRequest = false;\n\n        if (request != null) {\n            // get path info from request\n            requestedResource = getPathInfo(request);\n\n            // check for special header for remote address\n            remoteAddr = request.getHeader(CmsRequestUtil.HEADER_X_FORWARDED_FOR);\n            if (remoteAddr == null) {\n                // if header is not available, use default remote address\n                remoteAddr = request.getRemoteAddr();\n            }\n\n            // check for special \"time warp\" browsing\n            HttpSession session = request.getSession(false);\n            if (session != null) {\n                // no new session must be created here\n                requestTimeAttr = (Long)session.getAttribute(CmsContextInfo.ATTRIBUTE_REQUEST_TIME);\n            }\n            isSecureRequest = OpenCms.getSiteManager().usesSecureSite(request);\n\n            // create the request matcher\n            requestMatcher = new CmsSiteMatcher(request.getRequestURL().toString());\n        } else {\n            // if no request is available, the IP is always set to localhost\n            remoteAddr = CmsContextInfo.LOCALHOST;\n            // also the request matcher is always the workplace server\n            requestMatcher = OpenCms.getSiteManager().getWorkplaceSiteMatcher();\n        }\n        if (requestedResource == null) {\n            // path info can still be null\n            requestedResource = \"/\";\n        }\n\n        // calculate the request time\n        long requestTime;\n        if (requestTimeAttr == null) {\n            requestTime = System.currentTimeMillis();\n        } else {\n            requestTime = requestTimeAttr.longValue();\n        }\n\n        // get locale and encoding\n        CmsI18nInfo i18nInfo;\n        if (m_localeManager.isInitialized()) {\n            // locale manager is initialized\n            // resolve locale and encoding\n            if ((request != null)\n                && (requestedResource.endsWith(OpenCmsServlet.HANDLE_GWT) || isWorkplaceServletRequest(request))) {\n                // GWT RPC or workplace servlet call, always keep the request encoding and use the default locale\n                i18nInfo = new CmsI18nInfo(CmsLocaleManager.getDefaultLocale(), request.getCharacterEncoding());\n            } else {\n                String resourceName;\n                if (requestedResource.startsWith(CmsWorkplace.VFS_PATH_SYSTEM)) {\n                    // add site root only if resource name does not start with \"/system\"\n                    resourceName = requestedResource;\n                } else if (OpenCms.getSiteManager().startsWithShared(requestedResource)) {\n                    resourceName = requestedResource;\n                } else {\n                    resourceName = siteRoot.concat(requestedResource);\n                }\n                i18nInfo = m_localeManager.getI18nInfo(request, user, project, resourceName);\n            }\n        } else {\n            // locale manager not initialized, this will be true _only_ during system startup\n            // the values set does not matter, no locale information form VFS is used on system startup\n            // this is just to protect against null pointer exceptions\n            i18nInfo = new CmsI18nInfo(Locale.ENGLISH, getSystemInfo().getDefaultEncoding());\n        }\n\n        // decode the requested resource, always using UTF-8\n        requestedResource = CmsEncoder.decode(requestedResource);\n\n        // in case the current site could be configured for single tree localization, if so, remove the locale prefix if present\n        CmsSite site = OpenCms.getSiteManager().getSiteForSiteRoot(siteRoot);\n        if ((site != null) && CmsSite.LocalizationMode.singleTree.equals(site.getLocalizationMode())) {\n            Locale locale = CmsSingleTreeLocaleHandler.getLocaleFromPath(requestedResource);\n            if (locale != null) {\n                requestedResource = requestedResource.substring(\n                    requestedResource.indexOf(locale.toString()) + locale.toString().length());\n            }\n        }\n\n        // initialize the context info\n        CmsContextInfo contextInfo = new CmsContextInfo(\n            user,\n            project,\n            requestedResource,\n            requestMatcher,\n            siteRoot,\n            isSecureRequest,\n            i18nInfo.getLocale(),\n            i18nInfo.getEncoding(),\n            remoteAddr,\n            requestTime,\n            ouFqn);\n\n        // now generate and return the CmsObject\n        return initCmsObject(contextInfo);\n    }\n\n    /**\n     * Handles the user authentification for each request sent to OpenCms.<p>\n     *\n     * User authentification is done in three steps:\n     * <ol>\n     * <li>Session authentification: OpenCms stores information of all authentificated\n     *      users in an internal storage based on the users session.</li>\n     * <li>Authorization handler authentification: If the session authentification fails,\n     *      the current configured authorization handler is called.</li>\n     * <li>Default user: When both authentification methods fail, the user is set to\n     *      the default (Guest) user.</li>\n     * </ol>\n     *\n     * @param req the current http request\n     * @param res the current http response\n     *\n     * @return the initialized cms context\n     *\n     * @throws IOException if user authentication fails\n     * @throws CmsException in case something goes wrong\n     */\n    private CmsObject initCmsObject(HttpServletRequest req, HttpServletResponse res) throws IOException, CmsException {\n\n        return initCmsObject(req, res, true);\n    }\n\n    /**\n     * Returns an initialized CmsObject with the given users permissions.<p>\n     *\n     * In case the password is <code>null</code>, or the user is the <code>Guest</code> user,\n     * no password check is done. Therefore you can initialize all users without knowing their passwords\n     * by just supplying <code>null</code> as password. This is intended only for\n     * internal operation in the core.<p>\n     *\n     * @param req the current request\n     * @param res the current response\n     * @param user the user to initialize the CmsObject with\n     * @param password the password of the user\n     * @param ouFqn the organizational unit, if <code>null</code> the users ou is used\n     *\n     * @return a cms context that has been initialized with \"Guest\" permissions\n     *\n     * @throws CmsException in case the CmsObject could not be initialized\n     */\n    private CmsObject initCmsObject(\n        HttpServletRequest req,\n        HttpServletResponse res,\n        String user,\n        String password,\n        String ouFqn)\n    throws CmsException {\n\n        String siteroot = null;\n        // gather information from request if provided\n        if (req != null) {\n            siteroot = OpenCms.getSiteManager().matchRequest(req).getSiteRoot();\n        }\n        // initialize the user\n        if (user == null) {\n            user = getDefaultUsers().getUserGuest();\n        }\n        if (siteroot == null) {\n            siteroot = \"/\";\n        }\n        CmsObject cms = initCmsObject(\n            req,\n            m_securityManager.readUser(null, user),\n            siteroot,\n            CmsProject.ONLINE_PROJECT_ID,\n            ouFqn);\n        // login the user if different from Guest and password was provided\n        if ((password != null) && !getDefaultUsers().isUserGuest(user)) {\n            cms.loginUser(user, password, CmsContextInfo.LOCALHOST);\n        }\n        return cms;\n    }\n\n    /**\n     * Checks whether the given request targets the workplace UI servlet.<p>\n     *\n     * @param req the request\n     *\n     * @return <code>true</code> in case the given request targets the workplace UI servlet\n     */\n    private boolean isWorkplaceServletRequest(HttpServletRequest req) {\n\n        String servletPath = req.getServletPath();\n        return (servletPath != null) && servletPath.startsWith(CmsSystemInfo.WORKPLACE_PATH);\n    }\n\n    /**\n     * Sets the init level of this OpenCmsCore object instance.<p>\n     *\n     * For a detailed description about the possible run levels,\n     * please see {@link OpenCms#getRunLevel()}.<p>\n     *\n     * @param level the level to set\n     */\n    private void setRunLevel(int level) {\n\n        if (m_instance != null) {\n            if (m_instance.m_runLevel >= OpenCms.RUNLEVEL_1_CORE_OBJECT) {\n                // otherwise the log is not available\n                if (CmsLog.INIT.isInfoEnabled()) {\n                    CmsLog.INIT.info(\n                        Messages.get().getBundle().key(\n                            Messages.INIT_RUNLEVEL_CHANGE_2,\n                            new Integer(m_instance.m_runLevel),\n                            new Integer(level)));\n                }\n            }\n            m_instance.m_runLevel = level;\n        }\n    }\n\n}\n"},
{"Line": "=>71", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (!(fragment.getUserVisibleHint())) { fragment.setMenuVisibility(true); fragment.setUserVisibleHint(true); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/7536/buggy-version/recyclerpager.src.main.java.me.relex.recyclerpager.FragmentRecyclerAdapter.java", "BodyUseAPI": ["android.support.v4.app.Fragment.setUserVisibleHint(boolean)", "android.support.v4.app.Fragment.setMenuVisibility(boolean)"], "Fixed commit": "3d6554dc3ded9d1a143c00ccc228304fa5f35c12", "Url": "https://api.github.com/repos/ongakuer/RecyclerPager", "Date": "2018-11-06T13:48:35Z", "Source Code Diff": "@@ -38,7 +38,7 @@ public FragmentViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int view\n     }\n \n     /**\n-     * Attach Fragment && Fragment setUserVisibleHint true\n+     * Attach Fragment and Fragment setUserVisibleHint true\n      */\n     @Override public void onViewAttachedToWindow(@NonNull FragmentViewHolder holder) {\n         super.onViewAttachedToWindow(holder);\n@@ -60,24 +60,26 @@ public FragmentViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int view\n \n             fragmentTransaction.commitNowAllowingStateLoss();\n \n-            if (holder.currentFragment != null) {\n+            if (holder.currentFragment != null && holder.currentFragment.getUserVisibleHint()) {\n                 holder.currentFragment.setMenuVisibility(false);\n                 holder.currentFragment.setUserVisibleHint(false);\n             }\n \n             holder.currentFragment = fragment;\n         }\n-        \n-        fragment.setMenuVisibility(true);\n-        fragment.setUserVisibleHint(true);\n+\n+        if (!fragment.getUserVisibleHint()) {\n+            fragment.setMenuVisibility(true);\n+            fragment.setUserVisibleHint(true);\n+        }\n     }\n \n     /**\n      * Fragment setUserVisibleHint false\n      */\n     @Override public void onViewDetachedFromWindow(@NonNull FragmentViewHolder holder) {\n         super.onViewDetachedFromWindow(holder);\n-        if (holder.currentFragment != null) {\n+        if (holder.currentFragment != null && holder.currentFragment.getUserVisibleHint()) {\n             holder.currentFragment.setMenuVisibility(false);\n             holder.currentFragment.setUserVisibleHint(false);\n         }", "Complete After Code": "package me.relex.recyclerpager;\n\nimport android.support.annotation.NonNull;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentTransaction;\nimport android.support.v4.view.ViewCompat;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.FrameLayout;\n\npublic abstract class FragmentRecyclerAdapter\n        extends PageRecyclerAdapter<FragmentRecyclerAdapter.FragmentViewHolder> {\n\n    private final int mBaseContainerId;\n    private final FragmentManager mFragmentManager;\n\n    public FragmentRecyclerAdapter(FragmentManager fm) {\n        mFragmentManager = fm;\n        mBaseContainerId = ViewCompat.generateViewId();\n    }\n\n    @NonNull @Override\n    public FragmentViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        FrameLayout frameLayout = new FrameLayout(parent.getContext());\n        frameLayout.setLayoutParams(\n                new RecyclerView.LayoutParams(RecyclerView.LayoutParams.MATCH_PARENT,\n                        RecyclerView.LayoutParams.MATCH_PARENT));\n        return new FragmentViewHolder(frameLayout);\n    }\n\n    /**\n     * Set ContainerId\n     */\n    @Override public void onBindViewHolder(@NonNull FragmentViewHolder holder, int position) {\n        holder.itemView.setId(mBaseContainerId + position);\n    }\n\n    /**\n     * Attach Fragment and Fragment setUserVisibleHint true\n     */\n    @Override public void onViewAttachedToWindow(@NonNull FragmentViewHolder holder) {\n        super.onViewAttachedToWindow(holder);\n\n        String name = makeFragmentName(holder.itemView.getId(), holder.getAdapterPosition());\n        Fragment fragment = mFragmentManager.findFragmentByTag(name);\n\n        if (fragment != null && fragment == holder.currentFragment) {\n            // Nothing Changed\n        } else {\n            FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();\n\n            if (fragment != null) {\n                fragmentTransaction.attach(fragment);\n            } else {\n                fragment = getItem(holder.getAdapterPosition());\n                fragmentTransaction.add(holder.itemView.getId(), fragment, name);\n            }\n\n            fragmentTransaction.commitNowAllowingStateLoss();\n\n            if (holder.currentFragment != null && holder.currentFragment.getUserVisibleHint()) {\n                holder.currentFragment.setMenuVisibility(false);\n                holder.currentFragment.setUserVisibleHint(false);\n            }\n\n            holder.currentFragment = fragment;\n        }\n\n        if (!fragment.getUserVisibleHint()) {\n            fragment.setMenuVisibility(true);\n            fragment.setUserVisibleHint(true);\n        }\n    }\n\n    /**\n     * Fragment setUserVisibleHint false\n     */\n    @Override public void onViewDetachedFromWindow(@NonNull FragmentViewHolder holder) {\n        super.onViewDetachedFromWindow(holder);\n        if (holder.currentFragment != null && holder.currentFragment.getUserVisibleHint()) {\n            holder.currentFragment.setMenuVisibility(false);\n            holder.currentFragment.setUserVisibleHint(false);\n        }\n    }\n\n    /**\n     * Detach Fragment\n     */\n    @Override public void onViewRecycled(@NonNull FragmentViewHolder holder) {\n        super.onViewRecycled(holder);\n\n        if (holder.currentFragment != null) {\n            FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();\n            fragmentTransaction.detach(holder.currentFragment);\n            fragmentTransaction.commitNowAllowingStateLoss();\n        }\n        holder.currentFragment = null;\n    }\n\n    private static String makeFragmentName(int viewId, int position) {\n        return \"fragment:adapter:\" + viewId + \":\" + position;\n    }\n\n    /**\n     * Return the Fragment associated with a specified position.\n     */\n    public abstract Fragment getItem(int position);\n\n    class FragmentViewHolder extends RecyclerView.ViewHolder {\n        Fragment currentFragment;\n\n        FragmentViewHolder(@NonNull View itemView) {\n            super(itemView);\n        }\n    }\n}"},
{"Line": "=>187", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (useStartTLS) { props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/3116/buggy-version/alpine.src.main.java.alpine.mail.SendMail.java", "BodyUseAPI": [], "Fixed commit": "97f867b6e60a6c2f7bd9717d13ba1b38392f6605", "Url": "https://api.github.com/repos/stevespringett/Alpine", "Date": "2018-11-19T04:55:53Z", "Source Code Diff": "@@ -184,6 +184,8 @@ public void send() throws SendMailException {\n                 throw new SendMailException(\"An error occurred while configuring trust managers\", e);\n             }\n             props.put(\"mail.smtp.ssl.socketFactory\", sf);\n+        } else if (useStartTLS) {\n+            props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n         }\n         props.put(\"mail.smtp.host\", host);\n         props.put(\"mail.smtp.port\", port);\n@@ -195,7 +197,7 @@ public void send() throws SendMailException {\n             props.put(\"mail.smtp.auth.ntlm.domain\", host);\n         }\n \n-        Session session = Session.getDefaultInstance(props, new javax.mail.Authenticator() {\n+        Session session = Session.getInstance(props, new javax.mail.Authenticator() {\n             protected PasswordAuthentication getPasswordAuthentication() {\n                 return new PasswordAuthentication(username, password);\n             }", "Complete After Code": "/*\n * This file is part of Alpine.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Copyright (c) Steve Springett. All Rights Reserved.\n */\npackage alpine.mail;\n\nimport alpine.crypto.RelaxedX509TrustManager;\nimport com.sun.mail.util.MailSSLSocketFactory;\nimport javax.activation.DataHandler;\nimport javax.activation.DataSource;\nimport javax.activation.FileDataSource;\nimport javax.mail.Address;\nimport javax.mail.BodyPart;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.AddressException;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\nimport javax.net.ssl.TrustManager;\nimport java.io.File;\nimport java.security.GeneralSecurityException;\nimport java.util.Properties;\n\npublic class SendMail {\n    private Address from;\n    private Address[] to;\n    private Address[] cc;\n    private Address[] bcc;\n    private String subject;\n    private String body;\n    private File[] attachments = {};\n    private String host;\n    private int port;\n    private String username;\n    private String password;\n    private boolean useStartTLS;\n    private boolean useNTLM;\n    private boolean smtpauth;\n    private boolean trustCert;\n    private boolean debug;\n\n    public SendMail from(final String from) throws SendMailException {\n        this.from = parseAddress(from);\n        return this;\n    }\n\n    public SendMail to(final String[] to) throws SendMailException {\n        this.to = parseAddress(to);\n        return this;\n    }\n\n    public SendMail to(final String to) throws SendMailException {\n        this.to = parseAddress(new String[]{to});\n        return this;\n    }\n\n    public SendMail cc(final String[] cc) throws SendMailException {\n        this.cc = parseAddress(cc);\n        return this;\n    }\n\n    public SendMail cc(final String cc) throws SendMailException {\n        this.cc = parseAddress(new String[]{cc});\n        return this;\n    }\n\n    public SendMail bcc(final String[] bcc) throws SendMailException {\n        this.bcc = parseAddress(bcc);\n        return this;\n    }\n\n    public SendMail bcc(final String bcc) throws SendMailException {\n        this.bcc = parseAddress(new String[]{bcc});\n        return this;\n    }\n\n    public SendMail subject(final String subject) {\n        this.subject = subject;\n        return this;\n    }\n\n    public SendMail body(final String body) {\n        this.body = body;\n        return this;\n    }\n\n    public SendMail attachments(final File[] attachments) {\n        this.attachments = attachments;\n        return this;\n    }\n\n    public SendMail host(final String host) {\n        this.host = host;\n        return this;\n    }\n\n    public SendMail port(final int port) {\n        this.port = port;\n        return this;\n    }\n\n    public SendMail username(final String username) {\n        this.username = username;\n        return this;\n    }\n\n    public SendMail password(final String password) {\n        this.password = password;\n        return this;\n    }\n\n    public SendMail useStartTLS(final boolean useStartTLS) {\n        this.useStartTLS = useStartTLS;\n        return this;\n    }\n\n    public SendMail useNTLM(final boolean useNTLM) {\n        this.useNTLM = useNTLM;\n        return this;\n    }\n\n    public SendMail smtpauth(final boolean smtpauth) {\n        this.smtpauth = smtpauth;\n        return this;\n    }\n\n    public SendMail trustCert(final boolean trustCert) {\n        this.trustCert = trustCert;\n        return this;\n    }\n\n    public SendMail debug(final boolean debug) {\n        this.debug = debug;\n        return this;\n    }\n\n    private Address parseAddress(String address) throws SendMailException {\n        return parseAddress(new String[]{address})[0];\n    }\n\n    private Address[] parseAddress(String[] addresses) throws SendMailException {\n        final InternetAddress[] internetAddresses = new InternetAddress[addresses.length];\n        for (int i=0; i<addresses.length; i++) {\n            try {\n                internetAddresses[i] = new InternetAddress(addresses[i]);\n            } catch (AddressException e) {\n                throw new SendMailException(\"An error occurred processing internet addresses\", e);\n            }\n        }\n        return internetAddresses;\n    }\n\n    public void send() throws SendMailException {\n        Properties props = new Properties();\n        if (trustCert) {\n            // This block will automatically allow the SendMail client to accept any certificate,\n            // even self-signed ones not currently in the local keystore.\n            MailSSLSocketFactory sf;\n            try {\n                sf = new MailSSLSocketFactory();\n                sf.setTrustAllHosts(true);\n                TrustManager[] trustManagers = {new RelaxedX509TrustManager()};\n                sf.setTrustManagers(trustManagers);\n            } catch (GeneralSecurityException e) {\n                throw new SendMailException(\"An error occurred while configuring trust managers\", e);\n            }\n            props.put(\"mail.smtp.ssl.socketFactory\", sf);\n        } else if (useStartTLS) {\n            props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n        }\n        props.put(\"mail.smtp.host\", host);\n        props.put(\"mail.smtp.port\", port);\n        props.put(\"mail.smtp.socketFactory.port\", port);\n        props.put(\"mail.smtp.auth\", smtpauth);\n        props.put(\"mail.smtp.starttls.enable\", useStartTLS);\n\n        if (useNTLM) {\n            props.put(\"mail.smtp.auth.ntlm.domain\", host);\n        }\n\n        Session session = Session.getInstance(props, new javax.mail.Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(username, password);\n            }\n        });\n\n        session.setDebug(debug);\n        try {\n            Message message = new MimeMessage(session);\n            message.setFrom(from);\n            message.setRecipients(Message.RecipientType.TO, to);\n\n            if (cc != null && cc.length > 0) {\n                message.setRecipients(Message.RecipientType.CC, cc);\n            }\n            if (bcc != null && bcc.length > 0) {\n                message.setRecipients(Message.RecipientType.BCC, bcc);\n            }\n\n            message.setSubject(subject);\n            BodyPart messageBodyPart = new MimeBodyPart();\n            messageBodyPart.setText(body);\n            Multipart multipart = new MimeMultipart();\n            multipart.addBodyPart(messageBodyPart);\n\n            for (File file : attachments) {\n                messageBodyPart = new MimeBodyPart();\n                DataSource source = new FileDataSource(file);\n                messageBodyPart.setDataHandler(new DataHandler(source));\n                messageBodyPart.setFileName(file.getName());\n                multipart.addBodyPart(messageBodyPart);\n            }\n            message.setContent(multipart);\n            Transport.send(message);\n        } catch (MessagingException e) {\n            throw new SendMailException(\"An error occurred while sending email\", e);\n        }\n    }\n}"},
{"Line": "=>176", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (reward == null) { reward = \"\"; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/4463/buggy-version/AdvancedCore.src.com.Ben12345rocks.AdvancedCore.Rewards.RewardHandler.java", "BodyUseAPI": [], "Fixed commit": "0ae49a3bbbc685d3760e3b6ec1d04eac08d7b647", "Url": "https://api.github.com/repos/Ben12345rocks/AdvancedCore", "Date": "2018-12-30T17:21:07Z"},
{"Line": "=>1896", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (!(isDisplayedCkbx.isSelected())) { schemaItemCBX.setSelectedIndex(0); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/4229/buggy-version/src.edu.ku.brc.specify.tasks.subpane.qb.QueryFieldPanel.java", "BodyUseAPI": [], "Fixed commit": "e2ca34af3908ad88bc1a680f54267db5a4112506", "Url": "https://api.github.com/repos/specify/specify6", "Date": "2018-11-09T21:12:09Z", "Source Code Diff": "@@ -1893,6 +1893,10 @@ public void run()\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tsortCheckbox.setEnabled(isDisplayedCkbx.isSelected());\n \t\t\t\t\t\t\townerQuery.changeNotification(QueryFieldPanel.this);\n+                            if (!isDisplayedCkbx.isSelected()) {\n+                                schemaItemCBX.setSelectedIndex(0);\n+                            }\n+                            schemaItemCBX.setEnabled(isDisplayedCkbx.isSelected());\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n \t\t\t\t}", "Complete After Code": "/* Copyright (C) 2017, University of Kansas Center for Research\n * \n * Specify Software Project, specify@ku.edu, Biodiversity Institute,\n * 1345 Jayhawk Boulevard, Lawrence, Kansas, 66045, USA\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n*/\npackage edu.ku.brc.specify.tasks.subpane.qb;\n\nimport static edu.ku.brc.ui.UIHelper.createLabel;\nimport static edu.ku.brc.ui.UIRegistry.getResourceString;\n\nimport java.awt.CardLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Insets;\nimport java.awt.RenderingHints;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.FocusEvent;\nimport java.awt.event.FocusListener;\nimport java.awt.event.ItemEvent;\nimport java.awt.event.ItemListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.geom.RoundRectangle2D;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.List;\nimport java.util.Vector;\n\nimport javax.swing.DefaultComboBoxModel;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JComboBox;\nimport javax.swing.JComponent;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\nimport javax.swing.SwingConstants;\nimport javax.swing.SwingUtilities;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;\n\nimport com.jgoodies.forms.builder.PanelBuilder;\nimport com.jgoodies.forms.layout.CellConstraints;\nimport com.jgoodies.forms.layout.FormLayout;\n\nimport edu.ku.brc.af.core.db.DBFieldInfo;\nimport edu.ku.brc.af.core.db.DBRelationshipInfo;\nimport edu.ku.brc.af.core.db.DBRelationshipInfo.RelationshipType;\nimport edu.ku.brc.af.ui.db.PickListDBAdapterIFace;\nimport edu.ku.brc.af.ui.forms.FormHelper;\nimport edu.ku.brc.af.ui.forms.formatters.UIFieldFormatterIFace;\nimport edu.ku.brc.af.ui.forms.validation.DataChangeNotifier;\nimport edu.ku.brc.af.ui.forms.validation.FormValidator;\nimport edu.ku.brc.af.ui.forms.validation.UIValidator;\nimport edu.ku.brc.af.ui.forms.validation.ValCheckBox;\nimport edu.ku.brc.af.ui.forms.validation.ValComboBox;\nimport edu.ku.brc.af.ui.forms.validation.ValTextField;\nimport edu.ku.brc.specify.datamodel.Agent;\nimport edu.ku.brc.specify.datamodel.CollectionObject;\nimport edu.ku.brc.specify.datamodel.SpExportSchemaItem;\nimport edu.ku.brc.specify.datamodel.SpExportSchemaItemMapping;\nimport edu.ku.brc.specify.datamodel.SpExportSchemaMapping;\nimport edu.ku.brc.specify.datamodel.SpQueryField;\nimport edu.ku.brc.specify.datamodel.SpQueryField.OperatorType;\nimport edu.ku.brc.specify.dbsupport.RecordTypeCodeBuilder;\nimport edu.ku.brc.specify.ui.CatalogNumberFormatter;\nimport edu.ku.brc.specify.ui.CatalogNumberUIFieldFormatter;\nimport edu.ku.brc.specify.ui.db.PickListDBAdapterFactory;\nimport edu.ku.brc.specify.ui.db.PickListTableAdapter;\nimport edu.ku.brc.ui.IconManager;\nimport edu.ku.brc.ui.MultiStateIconButon;\nimport edu.ku.brc.ui.RolloverCommand;\nimport edu.ku.brc.ui.UIRegistry;\nimport edu.ku.brc.util.DateConverter;\nimport edu.ku.brc.util.Pair;\n\n/**\n * @author rod\n *\n * @code_status Alpha\n *\n * Oct 18, 2007\n *\n */\n@SuppressWarnings(\"serial\")\npublic class QueryFieldPanel extends JPanel implements ActionListener \n{\n    protected static final Logger log = Logger.getLogger(QueryFieldPanel.class);\n    \n//    private static final String operatorSavingFixDateStr = \"2012-12-05\"; \n//    private static final Date operatorSavingFixDate = DateFormat.getDateInstance(DateFormat.LONG, Locale.US).parse(\"2012-12-05\");\n    \n    protected String           noMappingStr = getResourceString(\"WB_NO_MAPPING\");\n\n    protected QueryFieldPanelContainerIFace    ownerQuery;\n    protected String           columnDefStr;\n    protected ImageIcon        blankIcon = IconManager.getIcon(\"BlankIcon\", IconManager.IconSize.Std24);\n\n    \n    protected boolean\t\t\t\t\t\thasFocus\t\t= false;\n\tprotected Color\t\t\t\t\t\t\tbgColor\t\t\t= null;\n\tprotected JLabel\t\t\t\t\t\tfieldLabel;\n\tprotected boolean\t\t\t\t\t\tlabelQualified\t= false;\n\tprotected JButton\t\t\t\t\t\tcloseBtn;\n\tprotected JComboBox\t\t\t\t\t\tschemaItemCBX;\n\tprotected JLabel\t\t\t\t\t\ticonLabel;\n\tprotected ImageIcon\t\t\t\t\t\ticon;\n\tprotected IconManager.IconSize\t\t\ticonSize = IconManager.IconSize.Std24;\n\tprotected JCheckBox\t\t\t\t\t\tisNotCheckbox;\n\tprotected JComboBox\t\t                operatorCBX;\n\tprotected JComponent\t\t\t\t\tcriteria;\n\tprotected MultiStateIconButon\t\t\tsortCheckbox;\n\tprotected JCheckBox\t\t\t\t\t\tisDisplayedCkbx;\n\tprotected JCheckBox\t\t\t\t\t\tisPromptCkbx;\n\tprotected JCheckBox\t\t\t\t\t\tisEnforcedCkbx;\n\n\tprotected JComponent[]\t\t\t\t\tcomps;\n\n\tprotected FieldQRI\t\t\t\t\t\tfieldQRI;\n\tprotected SpQueryField\t\t\t\t\tqueryField\t\t= null;\n\tprotected SpExportSchemaMapping\t        schemaMapping   = null;\n\tprotected SpExportSchemaItem\t\t\tschemaItem      = null;\n\tprotected String\t \t\t\t\t\tschemaItemName  = null;\n\tprotected boolean\t\t\t\t\t\tautoMapped      = false;\n\t\n\tprotected PickListDBAdapterIFace\t\tpickList\t\t= null;\n\n\tprotected FormValidator\t\t\t\t\tvalidator;\n\n\tprotected QueryFieldPanel\t\t\t\tthisItem;\n\n\tprotected String[]\t\t\t\t\t\tlabelStrs;\n\tprotected SpQueryField.OperatorType[]\tcomparators;\n\n\tprotected DateConverter\t\t\t\t\tdateConverter\t= null;\n\n\tprotected boolean\t\t\t\t\t\tselected\t\t= false;\n    \n\n    /**\n     * @author timbo\n     *\n     * @code_status Alpha\n     * \n     * Deals with pairs of criteria entries.\n     *\n     */\n\n    private class CriteriaPair extends JPanel\n    {\n        protected JTextField text1;\n        protected JTextField text2;\n        protected JLabel connectorText;\n        protected JPanel rangePanel;\n        protected JTextField text;\n        protected boolean showingPair = false;\n        \n        /**\n         * Constructor\n         */\n        public CriteriaPair(final KeyListener listener)\n        {\n            super();\n            buildUI(listener);\n        }\n        \n        /**\n         * Creates the UI components.\n         */\n        protected void buildUI(final KeyListener listener)\n        {        \t\n        \ttext1 = createTextField(\"1\");\n        \ttext1.addKeyListener(listener);\n            text2 = createTextField(\"2\");\n            text2.addKeyListener(listener);\n            connectorText = new JLabel(\" \" + getResourceString(\"AND\") + \" \");\n            \n            rangePanel = new JPanel();\n            PanelBuilder pb = new PanelBuilder(new FormLayout(\"f:p:g, f:p, f:p:g\", \"f:p\"), rangePanel);\n            CellConstraints cc = new CellConstraints();\n            pb.add(text1, cc.xy(1, 1));\n            pb.add(connectorText, cc.xy(2, 1));\n            pb.add(text2, cc.xy(3, 1));\n            rangePanel.validate();\n            \n            setLayout(new CardLayout());\n            text = createTextField(\"3\");\n            text.addKeyListener(listener);\n            add(\"text\", text);\n            add(\"rangePanel\", rangePanel);\n            validate();\n        }   \n\n        /* (non-Javadoc)\n    \t * @see javax.swing.JComponent#getPreferredSize()\n    \t */\n    \t@Override\n    \tpublic Dimension getPreferredSize() \n    \t{\n    \t\tDimension result = super.getPreferredSize();\n    \t\tresult.setSize(Math.min((sortCheckbox.getX() - 4) - (operatorCBX.getX() + operatorCBX.getWidth() + 4), result.getWidth()), result.getHeight());\n    \t\treturn result;\n    \t}\n\n        \n\t\t/**\n         * @param entry\n         * @param op\n         * \n         * Sets the criteria text, modifying the layout if necessary.\n         */\n        public void setCriteriaText(final String entry, final String entry2, final OperatorType op)\n        {\n            if (op != null && op.equals(OperatorType.BETWEEN))\n            {\n                //Currently between operator is not allowed for string fields, so assume no quotes \n                //and no commas but the one separating the two limits.\n                //Also assuming (more or less) valid entry. \n                setShowingPair(true);\n                String[] entries; \n                if (StringUtils.isBlank(entry2))\n                {\n                \tentries = entry.split(\",\");\n                } else\n                {\n                \tentries = new String[2];\n                \tentries[0] = entry;\n                \tentries[1] = entry2;\n                }\n                if (entries.length > 0)\n                {\n                \ttext1.setText(entries[0]);\n                \tif (entries.length > 1)\n                \t{\n                \t\ttext2.setText(entries[1]);\n                \t}\n                \telse\n                \t{\n                \t\ttext2.setText(null);\n                \t}\n                }\n                else\n                {\n                \ttext1.setText(null);\n                }\n            }\n            else\n            {\n                setShowingPair(false);\n                text.setText(entry);\n            }\n            \n        }\n        \n        /**\n         * @return a String representation of the entered criteria, parseable by the QueryBuilder.\n         */\n        public String getCriteriaText()\n        {\n            //Assuming isValidPairEntry() is true\n            if (showingPair)\n            {\n                return text1.getText() + \",\" + text2.getText();\n            }\n            \n            return text.getText();\n        }\n        \n//        /**\n//         * @return true unless the entered criteria is really messed up.\n//         */\n//        public boolean isValidPairEntry()\n//        {\n//            if (showingPair)\n//            {\n//                return (StringUtils.isBlank(text1.getText()) && StringUtils.isBlank(text2.getText()))\n//                    || (!StringUtils.isBlank(text1.getText()) && !StringUtils.isBlank(text2.getText()));\n//            }\n//            \n//            return true;\n//        }   \n//        \n//        /**\n//         * @return showingPair.\n//         */\n//        public boolean isShowingPair()\n//        {\n//            return showingPair;\n//        }\n        \n        /**\n         * @param showingPair\n         * \n         * Switches the UI from single to double criteria controls based on value of showingPair.\n         */\n        public void setShowingPair(final boolean showingPair)\n        {\n            if (this.showingPair != showingPair)\n            {\n                this.showingPair = showingPair;\n                if (showingPair)\n                {\n                    ((CardLayout )getLayout()).last(this);\n                }\n                else\n                {\n                    ((CardLayout )getLayout()).first(this);\n                }\n                \n                //clear old entries, for now.\n                text.setText(null);\n                text1.setText(null);\n                text2.setText(null);\n                \n                validate();\n            }\n        }\n    }\n    \n    protected PickListDBAdapterIFace buildPickList()\n    {\n        if (fieldQRI instanceof RelQRI)\n        {\n        \tPickListDBAdapterIFace pl = PickListDBAdapterFactory.getInstance().create(fieldQRI.getTableInfo().getName(), false);\n        \tif (pl instanceof PickListTableAdapter)\n        \t{\n        \t\treturn pl;\n        \t}\n        \treturn null;\n\n        }\n    \tif (fieldQRI != null && fieldQRI.getTableInfo() != null && fieldQRI.getFieldInfo() != null) \n        {\n            \n    \t\tPickListDBAdapterIFace typeCodeList = RecordTypeCodeBuilder.getTypeCode(fieldQRI.getFieldInfo());\n    \t\tif (typeCodeList != null)\n    \t\t{\n    \t\t\treturn typeCodeList;\n    \t\t}\n    \t\t//XXX unfortunately this doesn't work because currently picklist defs are only setup via form view defs\n            if (StringUtils.isNotEmpty(fieldQRI.getFieldInfo().getPickListName()))\n            {\n                //pickList = ((edu.ku.brc.specify.ui.db.PickListDBAdapterFactory)PickListDBAdapterFactory.getInstance()).create(fieldQRI.getFieldInfo().getPickListName(), false);\n                return PickListDBAdapterFactory.getInstance().create(fieldQRI.getFieldInfo().getPickListName(), false);\n            }\n            //else\n            //return RecordTypeCodeBuilder.getTypeCode(fieldQRI.getFieldInfo());\n        }\n        return null;\n    }\n    \n\n\n    /**\n     * @param ownerQuery\n     * @param fieldQRI\n     * @param columnDefStr\n     * @param saveBtn\n     * @param queryField\n     * @param schemaMapping\n     */\n    public QueryFieldPanel(final QueryFieldPanelContainerIFace ownerQuery,\n            final FieldQRI      fieldQRI, \n            final String        columnDefStr,\n            final Component       saveBtn,\n            final SpQueryField  queryField,\n            final SpExportSchemaMapping schemaMapping)\n    {\n    \tthis(ownerQuery, fieldQRI, IconManager.IconSize.Std24, columnDefStr, saveBtn, queryField, schemaMapping, null);\n    }\n \n    /**\n     * @param ownerQuery\n     * @param fieldQRI\n     * @param columnDefStr\n     * @param saveBtn\n     * @param queryField\n     */\n    public QueryFieldPanel(final QueryFieldPanelContainerIFace ownerQuery,\n                           final FieldQRI      fieldQRI, \n                           final String        columnDefStr,\n                           final Component       saveBtn,\n                           final SpQueryField  queryField)\n    {\n    \tthis(ownerQuery, fieldQRI, IconManager.IconSize.Std24, columnDefStr, saveBtn, queryField, null, null);\n    }\n\n    /**\n     * @param ownerQuery\n     * @param fieldQRI\n     * @param columnDefStr\n     * @param saveBtn\n     * @param queryField\n     * @param schemaMapping\n     * @param schemaItem\n     */\n    public QueryFieldPanel(final QueryFieldPanelContainerIFace ownerQuery,\n            final FieldQRI      fieldQRI, \n            final String        columnDefStr,\n            final Component       saveBtn,\n            final SpQueryField  queryField,\n            final SpExportSchemaMapping schemaMapping,\n            final SpExportSchemaItem schemaItem)\n    {\n    \tthis(ownerQuery, fieldQRI, IconManager.IconSize.Std24, columnDefStr, saveBtn, queryField, schemaMapping, schemaItem);\n    }\n\n    /**\n     * @param ownerQuery\n     * @param fieldQRI\n     * @param iconSize\n     * @param columnDefStr\n     * @param saveBtn\n     * @param queryField\n     * @param schemaMapping\n     * @param schemaItem\n     */\n    public QueryFieldPanel(final QueryFieldPanelContainerIFace ownerQuery,\n                           final FieldQRI      fieldQRI, \n                           final IconManager.IconSize iconSize,\n                           final String        columnDefStr,\n                           final Component       saveBtn,\n                           final SpQueryField  queryField,\n                           final SpExportSchemaMapping schemaMapping,\n                           final SpExportSchemaItem schemaItem)\n    {        \n        this.ownerQuery = ownerQuery;\n        this.schemaMapping = schemaMapping;\n        this.schemaItem = schemaItem;\n        boolean isForSchema = this.schemaMapping != null;\n        if (this.ownerQuery.isPromptMode())\n        {\n            if (!isForSchema)\n            {\n            \tlabelStrs = new String[]{ \" \",\n                    UIRegistry.getResourceString(\"QB_FIELD\"), UIRegistry.getResourceString(\"QB_NOT\"),\n                    UIRegistry.getResourceString(\"QB_OPERATOR\"),\n                    UIRegistry.getResourceString(\"QB_CRITERIA\"), UIRegistry.getResourceString(\"QB_SORT\"),\n                    //UIRegistry.getResourceString(\"QB_DISPLAY\"), getResourceString(\"QB_PROMPT\"), \n                    //\" \", \" \" \n                    };\n            } else\n            {\n            \tlabelStrs = new String[]{UIRegistry.getResourceString(\"QB_SCHEMAITEM\"), \" \",\n                        UIRegistry.getResourceString(\"QB_FIELD\"), UIRegistry.getResourceString(\"QB_NOT\"),\n                        UIRegistry.getResourceString(\"QB_OPERATOR\"),\n                        UIRegistry.getResourceString(\"QB_CRITERIA\"), UIRegistry.getResourceString(\"QB_SORT\"), UIRegistry.getResourceString(\"QB_ALLOW_NULL\"),\n                        //UIRegistry.getResourceString(\"QB_DISPLAY\"), getResourceString(\"QB_PROMPT\"), \n                        //\" \", \" \" \n                        };\n            }\n        }\n        else\n        {\n            if (!isForSchema)\n            {\n            \tlabelStrs = new String[]{ \" \",\n                    /*UIRegistry.getResourceString(\"QB_FIELD\")*/\" \", UIRegistry.getResourceString(\"QB_NOT\"),\n                    UIRegistry.getResourceString(\"QB_OPERATOR\"),\n                    UIRegistry.getResourceString(\"QB_CRITERIA\"), UIRegistry.getResourceString(\"QB_SORT\"),\n                    UIRegistry.getResourceString(\"QB_DISPLAY\"), getResourceString(\"QB_PROMPT\"), getResourceString(\"QB_ALWAYS_ENFORCE\"), \" \", \" \" };\n            }\n            else\n            {\n            \tlabelStrs = new String[]{ UIRegistry.getResourceString(\"QB_SCHEMAITEM\"), \" \",\n                        /*UIRegistry.getResourceString(\"QB_FIELD\")*/\" \", UIRegistry.getResourceString(\"QB_NOT\"),\n                        UIRegistry.getResourceString(\"QB_OPERATOR\"),\n                        UIRegistry.getResourceString(\"QB_CRITERIA\"), UIRegistry.getResourceString(\"QB_SORT\"), \n                        UIRegistry.getResourceString(\"QB_DISPLAY\"), getResourceString(\"QB_ALLOW_NULL\"), \" \", \" \" };\n            }\n        }\n        this.iconSize = iconSize;\n        this.fieldQRI      = fieldQRI;\n        if (fieldQRI != null && (fieldQRI.getDataClass().equals(Calendar.class) || fieldQRI.getDataClass().equals(java.sql.Timestamp.class)))\n        {\n            dateConverter = new DateConverter();\n        }\n        \n        pickList = buildPickList();\n        \n        this.columnDefStr  = columnDefStr;\n        \n        thisItem = this;\n        \n        validator = new FormValidator(null);\n        if (saveBtn != null)\n        {\n            validator.addEnableItem(saveBtn, FormValidator.EnableType.ValidAndChangedItems);\n        }\n        validator.setEnabled(true);\n        \n        boolean createAsHeader = StringUtils.isEmpty(columnDefStr);\n        \n        int[] widths = buildControlLayout(iconSize, createAsHeader, saveBtn);\n        if (createAsHeader)\n        {\n            removeAll();\n            buildLabelLayout(widths);\n            ownerQuery.setColumnDefStr(this.columnDefStr);\n        }\n        \n        setQueryField(queryField);\n        if (!createAsHeader && getFieldInfo() != null /*this means relationships and tree levels won't get qualified*/)\n        {\n            setToolTipText(getQualifiedLabel(fieldQRI.getTableTree(), true));\n        }\n}\n    \n    public void updateQueryField()\n    {\n        updateQueryField(queryField);\n    }\n    \n    /**\n     * @param useValues\n     * @return the text contained in the criteria control.\n     */\n    public String getCriteriaText(final boolean useValues)\n    {\n        if (criteria instanceof JTextField)\n        {\n            return ((JTextField)criteria).getText();\n        }\n        if (criteria instanceof PickListCriteriaCombo)\n        {\n            return ((PickListCriteriaCombo)criteria).getText(useValues);\n        }\n        if (criteria instanceof CriteriaPair)\n        {\n            return ((CriteriaPair )criteria).getCriteriaText();\n        }\n        throw new RuntimeException(\"Unrecognized criteria component: \" + criteria.getClass());\n    }\n    \n    \n    public void updateQueryField(final SpQueryField qField)\n    {\n        boolean isForSchema = schemaMapping != null;\n    \tif (qField != null && !ownerQuery.isPromptMode() && !ownerQuery.isForSchemaExport())\n        {\n            qField.setIsDisplay(isDisplayedCkbx.isSelected());\n            qField.setIsPrompt(isPromptCkbx.isSelected());\n            if (isForSchema)\n            {\n            \tqField.setAllowNulls(isEnforcedCkbx.isSelected());\n            } else\n            {\n            \tqField.setAlwaysFilter(isEnforcedCkbx.isSelected());\n            }\n            qField.setIsNot(isNotCheckbox.isSelected());\n            if (validator.hasChanged() && qField.getSpQueryFieldId() != null)\n            {\n                FormHelper.updateLastEdittedInfo(qField);\n            }\n            \n            qField.setSortType((byte)sortCheckbox.getState());\n            \n            qField.setOperStart(((SpQueryField.OperatorType)operatorCBX.getSelectedItem()).getOrdinal());\n           \n            qField.setStartValue(getCriteriaText(false));\n            String lbl = this.getLabel();\n            if (fieldQRI instanceof RelQRI)\n            {\n                lbl = RelQRI.stripDescriptiveStuff(lbl);    \n            }\n            qField.setContextTableIdent(fieldQRI.getTableInfo().getTableId());\n            qField.setColumnAliasTitle(lbl, fieldQRI instanceof TreeLevelQRI);\n            qField.setIsRelFld(fieldQRI instanceof RelQRI);\n            \n            Vector<Integer> idList = new Vector<Integer>();\n            TableQRI parent = fieldQRI.getTable();\n            while (parent != null)\n            {\n                idList.add(parent.getTableInfo().getTableId());\n                parent = parent.getTableTree().getParent().getTableQRI();\n            }\n            \n            String tablesIds = fieldQRI.getTableTree().getPathFromRootAsString();\n            log.debug(tablesIds);\n            qField.setTableList(tablesIds);\n            qField.setStringId(getStringId());\n            \n            if (schemaItemCBX != null)\n            {\n            \tSpExportSchemaItemMapping mapping = qField.getMapping();\n            \tif (mapping != null)\n            \t{\n            \t\tschemaItem = (SpExportSchemaItem )schemaItemCBX.getSelectedItem();\n            \t\tif (schemaItem.getId() == null)\n            \t\t{\n            \t\t\tmapping.setExportSchemaItem(null);\n            \t\t\tString exportName = schemaItemCBX.getEditor().getItem().toString();\n            \t\t\tif (exportName == null || exportName.equals(getResourceString(\"QueryBldrPane.UnmappedSchemaItemName\")))            \t\t\t\n            \t\t\t{\n            \t\t\t\tmapping.setExportedFieldName(getDefaultExportedFieldName());\n            \t\t\t} else\n            \t\t\t{\n            \t\t\t\tmapping.setExportedFieldName(exportName);\n            \t\t\t}\n            \t\t} else\n            \t\t{\n            \t\t\tmapping.setExportSchemaItem(schemaItem);\n            \t\t}\n            \t}\n            }\n        } else\n        {\n            log.error(\"QueryField is null or ownerQuery is prompt only. Unable to update database object.\");\n        }\n    }\n    \n    /**\n     * @return customized fieldname/column header for schema mapping items that are not mapped to a concept.\n     */\n    protected String getExportedFieldName()\n    {\n    \tSpExportSchemaItemMapping mi = this.getItemMapping();\n    \tif (mi == null || mi.getExportedFieldName() == null)\n    \t{\n    \t\treturn getDefaultExportedFieldName();\n    \t} else\n    \t{\n    \t\treturn mi.getExportedFieldName();\n    \t}\n    }\n    \n    protected String getDefaultExportedFieldName()\n    {\n    \tif (queryField != null) {\n    \t\treturn queryField.getColumnAlias();\n    \t} else {\n    \t\treturn fieldQRI.getTitle();\n    \t}\n    }\n    \n    /**\n     * @return the queryField\n     */\n    public SpQueryField getQueryField()\n    {\n        return queryField;\n    }\n\n    /**\n     * @param text the criteria\n     * @param text2 the end criteria in case of BETWEEN op\n     * @param op the operator\n     */\n    protected void setCriteriaText(final String text, final String text2, final OperatorType op)\n    {\n        if (op != null && op.equals(OperatorType.BETWEEN) && !(criteria instanceof CriteriaPair))\n        {\n            //Probably nothing bad will result but, log situation, in case.\n            log.error(\"operator is 'BETWEEN' but criteria control is not CriteriaPair\");\n        }\n        if (criteria instanceof JTextField)\n        {\n            ((JTextField)criteria).setText(text);\n        }\n        else if (criteria instanceof PickListCriteriaCombo)\n        {\n            ((PickListCriteriaCombo)criteria).setSelections(text);\n        }\n        else if (criteria instanceof CriteriaPair)\n        {\n            ((CriteriaPair )criteria).setCriteriaText(text, text2, op);\n        }\n        else\n        {\n            throw new RuntimeException(\"Unrecognized criteria component: \" + criteria.getClass());\n        }\n        \n    }\n    \n//    private SpQueryField.OperatorType getOperatorType(final SpQueryField fld)\n//    {\n//    \tTimestamp fldTimeStamp = fld.getTimeStampModified();\n//    \t\n//    }\n    \n    /**\n     * @param queryField\n     */\n    public void setQueryFieldForAutomapping(SpQueryField queryField)\n    {\n    \tjustSetTheQueryField(queryField);\n    }\n    \n    /**\n     * @param queryField\n     */\n    public void justSetTheQueryField(SpQueryField queryField) {\n    \tthis.queryField = queryField;\n    }\n    \n    /**\n     * @param queryField the queryField to set\n     */\n    private void setQueryField(SpQueryField queryField)\n    {\n        this.queryField = queryField;\n        boolean isForSchema = schemaMapping != null;\n        //if (!ownerQuery.isPromptMode()) {\n        \tif (queryField != null)\n        \t{\n        \t\tif (queryField.getSpQueryFieldId() != null)\n        \t\t{\n        \t\t\tisNotCheckbox.setSelected(queryField.getIsNot());\n        \t\t\ttry\n        \t\t\t{\n        \t\t\t\tOperatorType o = OperatorType.values()[queryField.getOperStart()];\n        \t\t\t\toperatorCBX.setSelectedItem(o);\n        \t\t\t} catch(IllegalArgumentException ex)\n        \t\t\t{\n        \t\t\t\tlog.error(\"unable to set operator index for \" + queryField.getStringId() + \": \" + ex);\n        \t\t\t\toperatorCBX.setSelectedIndex(0);\n        \t\t\t}\n        \t\t\tsetCriteriaText(queryField.getStartValue(), queryField.getEndValue(), (OperatorType )operatorCBX.getSelectedItem());\n        \t\t\tsortCheckbox.setState(queryField.getSortType());\n        \t\t\tsortCheckbox.setEnabled(queryField.getIsDisplay());\n        \t\t\tif (!ownerQuery.isPromptMode())\n        \t\t\t{\n        \t\t\t\tisDisplayedCkbx.setSelected(queryField.getIsDisplay());\n        \t\t\t\tisPromptCkbx.setSelected(queryField.getIsPrompt() == null ? true : queryField.getIsPrompt());\n        \t\t\t\tif (isForSchema)\n        \t\t\t\t{\n        \t\t\t\t\tisEnforcedCkbx.setSelected(queryField.getAllowNulls() == null ? false : queryField.getAllowNulls());\n        \t\t\t\t} else\n        \t\t\t\t{\n        \t\t\t\t\tisEnforcedCkbx.setSelected(queryField.getAlwaysFilter() == null ? true : queryField.getAlwaysFilter());\n        \t\t\t\t}\n        \t\t\t}                \n        \t\t\tvalidator.setHasChanged(false);\n        \t\t} else\n        \t\t{\n        \t\t\tvalidator.reset(true); // tells it it is a new data object\n        \t\t\tvalidator.setHasChanged(true);\n        \t\t\tthis.queryField.setStringId(fieldQRI.getStringId());\n        \t\t}\n        \t\tvalidator.validateForm();\n        \t\tvalidator.wasValidated(null);\n        \t}\n        //}\n    }\n    \n    /**\n     * @param fqri\n     * @param qf\n     * \n     * Sets new field and updates UI to display properties for new field.\n     */\n    public void setField(final FieldQRI fqri, final SpQueryField qf)\n    {\n        fieldQRI = fqri;\n        if (fieldQRI != null && (fieldQRI.getDataClass().equals(Calendar.class) || fieldQRI.getDataClass().equals(java.sql.Timestamp.class)))\n        {\n            dateConverter = new DateConverter();\n        }\n \n        if (fieldQRI != null)\n        {\n            icon = IconManager.getIcon(fieldQRI.getTableInfo().getName(), iconSize);\n            setIcon(icon);\n        }\n \n        pickList = buildPickList();\n    \tcomparators = getComparatorList(fieldQRI);\n        String fieldLabelText = fieldQRI != null ? fieldQRI.getTitle() : null;\n        if (fieldQRI instanceof RelQRI)\n        {\n            DBRelationshipInfo.RelationshipType relType = ((RelQRI)fieldQRI).getRelationshipInfo().getType();\n            if (relType.equals(DBRelationshipInfo.RelationshipType.OneToMany) || \n                    relType.equals(DBRelationshipInfo.RelationshipType.ManyToMany))\n            {\n                fieldLabelText += \" \" + UIRegistry.getResourceString(\"QB_AGGREGATED\");\n            }\n            else\n            {\n                fieldLabelText += \" \" + UIRegistry.getResourceString(\"QB_FORMATTED\");\n            }\n                \n        }\n        fieldLabel.setText(fieldLabelText);\n        boolean isBool = fieldQRI != null && fieldQRI.getDataClass().equals(Boolean.class);\n\t\tboolean isRel = fieldQRI != null && fieldQRI instanceof RelQRI;\n\t\tboolean isTreeLevel = fieldQRI instanceof TreeLevelQRI;\n\t\t\n\t\toperatorCBX.setModel(new DefaultComboBoxModel(comparators));\n\t\t//XXX need to set up criteria to support 'between' if necessary\n\t\t\n\t\tfor (int c = 1; c < comps.length; c++)\n\t\t{\n\t\t\tif (comps[c] != null)\n\t\t\t{\n\t\t\t\tcomps[c].setVisible(fieldQRI != null);\n\t\t\t}\n\t\t}\n\t\t\n\t\tisNotCheckbox.setVisible(fieldQRI != null && !isRel);\n\t\toperatorCBX.setVisible(fieldQRI != null && !isRel);\n\t\tcriteria.setVisible(fieldQRI != null && !isRel && !isBool);\n\t\tif (schemaMapping != null)\n\t\t{\n\t\t\tthis.sortCheckbox.setVisible(!(isTreeLevel || isRel));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!isRel)\n\t\t\t{\n\t\t\t\tthis.sortCheckbox.setVisible(fieldQRI != null);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tthis.sortCheckbox\n\t\t\t\t\t.setVisible(((RelQRI) fieldQRI).getRelationshipInfo()\n\t\t\t\t\t\t\t.getType() != RelationshipType.OneToMany);\n\t\t\t}\n\t\t}\n\n\t\tif (schemaMapping != null)\n\t\t{\n\t\t\t\tisPromptCkbx.setVisible(false);\n\t\t} else if (!ownerQuery.isPromptMode())\n\t\t{\n\t\t\t\tisDisplayedCkbx.setVisible(fieldQRI != null && !isRel);\n\t\t\t\tisPromptCkbx.setVisible(fieldQRI != null && !isRel);\n\t\t\t\tisEnforcedCkbx.setVisible(fieldQRI != null && !isRel);\n\t\t}\n    \tsetQueryField(qf);\n    }\n    /**\n     * \n     */\n    public void resetValidator()\n    {\n        validator.reset(true);\n    }\n\n    /**\n     * @param field\n     * @return list of comparators appropriate for field.\n     */\n    protected SpQueryField.OperatorType[] getComparatorList(final FieldQRI field)\n    {\n        if (field ==  null)\n        {\n            return new SpQueryField.OperatorType[]{};\n        }\n        return getComparatorList(field instanceof TreeLevelQRI, pickList != null, field.getFieldInfo(),\n        \t\tfield.getDataClass());\n    }    \n\n    /**\n     * @return the format name.\n     */\n    protected String getFormatName()\n    {\n    \treturn getQueryField() != null \n    \t\t\t? (StringUtils.isEmpty(getQueryField().getFormatName()) ? null : getQueryField().getFormatName()) \n    \t\t\t: null;\n    }\n    \n    /**\n     * @param field\n     * @return list of comparators appropriate for field.\n     */\n    public static SpQueryField.OperatorType[] getComparatorList(boolean isTreeLevel, boolean isPickList, \n    \t\tDBFieldInfo fieldInfo, Class<?> dataClass)\n    {\n        if (isPickList)\n        {\n            return new SpQueryField.OperatorType[] {\n                    SpQueryField.OperatorType.EQUALS,\n                    SpQueryField.OperatorType.IN,\n                    SpQueryField.OperatorType.EMPTY};\n        }\n        //CatalogNumber needs special treatment - works better as a number.\n        //And other fields? Not sure how to tell. Maybe the formatter?????\n        if (fieldInfo != null && fieldInfo.getName().equalsIgnoreCase(\"catalognumber\") \n                && fieldInfo.getTableInfo().getClassObj().equals(CollectionObject.class))\n        {\n            if (fieldInfo.getFormatter() != null && fieldInfo.getFormatter().isNumeric())\n            {\n            \treturn getComparatorListForClass(Number.class);\n            }\n            OperatorType[] stringCmps = getComparatorListForClass(String.class);\n            OperatorType[] result = new OperatorType[stringCmps.length + 2];\n            int c = 0;\n            for (OperatorType ot : stringCmps)\n            {\n            \tresult[c++] = ot;\n            }\n            result[c++] = SpQueryField.OperatorType.GREATERTHAN;\n            result[c++] = SpQueryField.OperatorType.LESSTHAN;\n            //result[c++] = SpQueryField.OperatorType.BETWEEN;\n            return result;\n        }\n        //else\n        return getComparatorListForClass(dataClass, isTreeLevel);\n    }\n    \n    /**\n     * @param classObj\n     * @return\n     */\n    public static SpQueryField.OperatorType[] getComparatorListForClass(final Class<?> classObj) {\n        if (classObj != null)\n\t\t{\n\t\t\tif (classObj.equals(String.class))\n\t\t\t{\n\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.CONTAINS,\n\t\t\t\t\t\tSpQueryField.OperatorType.LIKE,\n\t\t\t\t\t\tSpQueryField.OperatorType.EQUALS,\n\t\t\t\t\t\tSpQueryField.OperatorType.IN,\n\t\t\t\t\t\tSpQueryField.OperatorType.BETWEEN,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t}\n\t\t\tif (classObj.equals(Boolean.class))\n\t\t\t{\n\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.DONTCARE,\n\t\t\t\t\t\tSpQueryField.OperatorType.TRUE,\n\t\t\t\t\t\tSpQueryField.OperatorType.FALSE,\n\t\t\t\t\t\tSpQueryField.OperatorType.TRUEORNULL,\n\t\t\t\t\t\tSpQueryField.OperatorType.FALSEORNULL,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t}\n\t\t\tif (classObj.equals(java.sql.Timestamp.class))\n\t\t\t{\n\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.EQUALS,\n\t\t\t\t\t\tSpQueryField.OperatorType.GREATERTHAN,\n\t\t\t\t\t\tSpQueryField.OperatorType.LESSTHAN,\n\t\t\t\t\t\tSpQueryField.OperatorType.BETWEEN,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t}\n\t\t}\n        return new SpQueryField.OperatorType[] {SpQueryField.OperatorType.EQUALS,\n                SpQueryField.OperatorType.GREATERTHAN,\n                SpQueryField.OperatorType.LESSTHAN,\n                SpQueryField.OperatorType.GREATERTHANEQUALS,\n                SpQueryField.OperatorType.LESSTHANEQUALS,\n                SpQueryField.OperatorType.BETWEEN,\n                SpQueryField.OperatorType.IN,\n                SpQueryField.OperatorType.EMPTY};\n    }\n\n    /**\n     * @param classObj\n     * @param isTreeLevel\n     * @return\n     */\n    public static SpQueryField.OperatorType[] getComparatorListForClass(final Class<?> classObj, boolean isTreeLevel)\n    {\n        if (classObj != null)\n\t\t{\n\t\t\tif (classObj.equals(String.class))\n\t\t\t{\n\t\t\t\tif (!isTreeLevel) {\n\t\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.CONTAINS,\n\t\t\t\t\t\tSpQueryField.OperatorType.LIKE,\n\t\t\t\t\t\tSpQueryField.OperatorType.EQUALS,\n\t\t\t\t\t\tSpQueryField.OperatorType.IN,\n\t\t\t\t\t\tSpQueryField.OperatorType.BETWEEN,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t\t} else {\n\t\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\t\tSpQueryField.OperatorType.CONTAINS,\n\t\t\t\t\t\t\tSpQueryField.OperatorType.LIKE,\n\t\t\t\t\t\t\tSpQueryField.OperatorType.EQUALS,\n\t\t\t\t\t\t\tSpQueryField.OperatorType.IN,\n\t\t\t\t\t\t\tSpQueryField.OperatorType.BETWEEN};\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (classObj.equals(Boolean.class))\n\t\t\t{\n\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.DONTCARE,\n\t\t\t\t\t\tSpQueryField.OperatorType.TRUE,\n\t\t\t\t\t\tSpQueryField.OperatorType.FALSE,\n\t\t\t\t\t\tSpQueryField.OperatorType.TRUEORNULL,\n\t\t\t\t\t\tSpQueryField.OperatorType.FALSEORNULL,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t}\n\t\t\tif (classObj.equals(java.sql.Timestamp.class))\n\t\t\t{\n\t\t\t\treturn new SpQueryField.OperatorType[] {\n\t\t\t\t\t\tSpQueryField.OperatorType.EQUALS,\n\t\t\t\t\t\tSpQueryField.OperatorType.GREATERTHAN,\n\t\t\t\t\t\tSpQueryField.OperatorType.LESSTHAN,\n\t\t\t\t\t\tSpQueryField.OperatorType.BETWEEN,\n\t\t\t\t\t\tSpQueryField.OperatorType.EMPTY };\n\t\t\t}\n\t\t}\n        return new SpQueryField.OperatorType[] {SpQueryField.OperatorType.EQUALS,\n                SpQueryField.OperatorType.GREATERTHAN,\n                SpQueryField.OperatorType.LESSTHAN,\n                SpQueryField.OperatorType.GREATERTHANEQUALS,\n                SpQueryField.OperatorType.LESSTHANEQUALS,\n                SpQueryField.OperatorType.BETWEEN,\n                SpQueryField.OperatorType.IN,\n                SpQueryField.OperatorType.EMPTY};\n    }\n    \n    /**\n     * @return\n    */\n    public SortElement getOrderSpec(int pos)\n    {\n        Byte sortType;\n        if (ownerQuery.isPromptMode())\n        {\n            sortType = (byte)sortCheckbox.getState();\n        }\n        else\n        {\n            sortType = queryField.getSortType();\n        }\n        if (sortType.equals(SpQueryField.SORT_NONE)) { return null; }\n        \n        int direction = sortType.equals(SpQueryField.SORT_ASC) ? SortElement.ASCENDING : SortElement.DESCENDING;\n        return new SortElement(pos, direction);\n    }\n    \n    /**\n     * @return true if a condition has been specified for the field.\n     */\n    protected boolean hasCriteria()\n    {\n        if (fieldQRI.getDataClass().equals(Boolean.class))\n        {\n            return !operatorCBX.getSelectedItem().equals(SpQueryField.OperatorType.DONTCARE);\n        }\n        if (operatorCBX.getSelectedItem().equals(SpQueryField.OperatorType.EMPTY))\n        {\n        \treturn true;\n        }\n        return StringUtils.isNotEmpty(getCriteriaText(false).trim());\n    }\n \n    \n   /**\n     * @param criteriaEntry - String of comma-delimited entries\n     * @return Array of formatted criteria\n     * @throws ParseException\n     */\n    protected Object[] parseCriteria(final String origCriteriaEntry) throws ParseException\n    {\n        String[] raw;\n        UIFieldFormatterIFace formatter = fieldQRI.getFormatter();\n        boolean isNumericCatNum = (formatter instanceof CatalogNumberUIFieldFormatter && ((CatalogNumberUIFieldFormatter )formatter).isNumeric());\n        String criteriaEntry = origCriteriaEntry;\n        if (isNumericCatNum) {\n        \tcriteriaEntry = CatalogNumberFormatter.preParseNumericCatalogNumbersWithSeries(origCriteriaEntry, formatter);\n        }\n        if (operatorCBX.getSelectedItem() == SpQueryField.OperatorType.BETWEEN \n                || operatorCBX.getSelectedItem() == SpQueryField.OperatorType.IN \n                || formatter instanceof CatalogNumberUIFieldFormatter) //',' in numeric catnums cause stack traces, and they are invalid in string catnums so don't allow them)\n        {\n        \traw = criteriaEntry.split(\",\");\n        }\n        else\n        {\n            raw = new String[1];\n            raw[0] = criteriaEntry;\n        }\n        \n        \n        if (operatorCBX.getSelectedItem() == SpQueryField.OperatorType.BETWEEN)\n        {\n            if (raw.length != 2)\n            {\n                throw new ParseException(getLabel() + \" - \" + UIRegistry.getResourceString(\"QB_INVALID_CRITERIA\"), -1);\n            }\n        }\n        else if (operatorCBX.getSelectedItem() != SpQueryField.OperatorType.IN)\n        {\n            if (raw.length != 1)\n            {\n                throw new ParseException(getLabel() + \" - \" + UIRegistry.getResourceString(\"QB_INVALID_CRITERIA\"), -1);\n            }\n        }\n        \n        Object[] result = new Object[raw.length];\n        for (int e=0; e<raw.length; e++)\n        {\n            try\n            {\n                if (isNumericCatNum) {\n                \tPair<String, String> series = getSerStartEnd(raw[e].trim());\n                \tformatter.formatFromUI(series.getFirst());\n                \tformatter.formatFromUI(series.getSecond());\n                \tif (!series.getSecond().equals(raw[e].trim())) {\n                \t\tresult[e] = series;\n                \t} else {\n                \t\tresult[e] = series.getFirst();\n                \t}\n                } else {\n                \tresult[e] = formatter != null ? formatter.formatFromUI(raw[e].trim()) : raw[e].trim();\n                }\n            }\n            catch (Exception ex)\n            {\n                throw new ParseException(getLabel() + \" - \" \n                        + String.format(UIRegistry.getResourceString(\"QB_PARSE_ERROR\"), ex.getLocalizedMessage()), -1);\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * @param ser\n     * @return\n     * @throws Exception\n     */\n    protected Pair<String, String> getSerStartEnd(String ser) throws Exception {\n    \tString start = null;\n    \tString end = null;\n    \tif (!ser.contains(\"-\")) {\n    \t\tstart = ser;\n    \t\tend = ser;\n    \t} else if (ser.endsWith(\"-\")) {\n    \t\tthrow new Exception(\"Bad series format.\");\n    \t} else {\n    \t\tString[] parts = ser.split(\"-\");\n    \t\tif (parts.length != 2) {\n    \t\t\tthrow new Exception(\"Bad series format.\");\n    \t\t} \n    \t\tstart = parts[0];\n    \t\tif (parts[1].length() >= parts[0].length()) {\n    \t\t\tend = parts[1];\n    \t\t} else {\n    \t\t\tend = start.substring(0, start.length() - parts[1].length()) + parts[1];\n    \t\t}\n    \t}\n    \treturn new Pair<String, String>(start, end);\n    }\n    \n    /**\n     * @param escapee\n     * @param escaper\n     * WRONG:@return escapee with occurrences of escapee preceded by '\\'. Pike's Peak -> Pike\\'s Peak\n     * @return escapee with occurrences of escapee doubled. Pike's Peak -> Pike''s Peak\n     * \n     * This actually only works for \"'\". \n     * Hibernate (but not MySQL) complains when % and \\' are both contained in a criteriummmm\n     * \n     * Too bad if the escaper is already escaped.\n     */\n    protected Object escape(final Object escapee, final char escaper)\n    {\n        //XXX may be MySQL -specific?\n        if (escaper == ' ')\n        {\n            return escapee;\n        }\n        if (!(escapee instanceof String))\n        {\n            throw new RuntimeException(\"Escapee is not a String!\");\n        }\n        String escapeeStr = (String)escapee;\n        StringBuilder result = new StringBuilder();\n        for (int c = 0; c < escapeeStr.length(); c++)\n        {\n            if (escapeeStr.charAt(c) == escaper)\n            {\n                result.append(escaper);\n            }\n            result.append(escapeeStr.charAt(c));\n        }\n        return result.toString();\n    }\n    /**\n     * @param criteriaObjs\n     * @param operatorStr\n     * @param quote - if true then items will be surrounded with single quotes.\n     * @return comma-delimited list of items in criteriaObjs.\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected String concatCriteria(final Object[] criteriaObjs, final String operatorStr, final boolean quote, final TableAbbreviator ta)\n    {\n        //XXX '%' as wildcard may be db vendor -specific??\n        \n        char quoteStr = quote ? '\\'' : ' ';\n        String result = quoteStr + escape(criteriaObjs[0], quoteStr).toString() + quoteStr;\n        if (SpQueryField.OperatorType.getOrdForOp(operatorStr) == SpQueryField.OperatorType.LIKE.getOrdinal()\n                || SpQueryField.OperatorType.getOrdForOp(operatorStr) == SpQueryField.OperatorType.CONTAINS.getOrdinal())\n        {\n            //for Specify 5 compatibility...?\n            //replaced unescaped '*' with '%'\n            if (result.contains(\"*\"))\n            {\n                //grrrrrrrr\n                StringBuilder newResult = new StringBuilder();\n                int skip = -1;\n                for (int s = 0; s < result.length(); s++)\n                {\n                  \n                    if (skip != s && result.charAt(s) == '\\\\')\n                    {\n                        skip = s+1;\n                    }\n                    if (skip != s && result.charAt(s) == '*')\n                    {\n                        newResult.append('%');\n                    }\n                    else\n                    {\n                        newResult.append(result.charAt(s));\n                    }\n                    if (skip == s)\n                    {\n                        skip = -1;\n                    }\n                }\n                result = newResult.toString();\n            }\n            \n            boolean unEscapedWildcard = false;\n            boolean skip = false;\n            int s = 0;\n            while (!unEscapedWildcard && s < result.length())\n            {\n                if (skip)\n                {\n                    skip = false;\n                }\n                else if (result.charAt(s) == '\\\\')\n                {\n                    skip = true;\n                }\n                else if (result.charAt(s) == '%')\n                {\n                    unEscapedWildcard = true;\n                }\n                s++;\n            }\n            \n            if (SpQueryField.OperatorType.getOrdForOp(operatorStr) == SpQueryField.OperatorType.CONTAINS.getOrdinal())\n            {\n                //if user didn't purposely include a wildcard then add them\n                result = quoteStr + \"%\" + result.substring(1, result.length()-1) + \"%\" + quoteStr;\n            }\n\n        }\n        else if (SpQueryField.OperatorType.getOrdForOp(operatorStr) == SpQueryField.OperatorType.BETWEEN.getOrdinal())\n        {\n            result += \" and \" + quoteStr + escape(criteriaObjs[1], quoteStr) + quoteStr;\n        }\n        else if (SpQueryField.OperatorType.getOrdForOp(operatorStr) == SpQueryField.OperatorType.IN.getOrdinal())\n        {\n            result = \"\";\n            List<Pair<String,String>> sers = new ArrayList<Pair<String, String>>();\n            for (int p = 0; p < criteriaObjs.length; p++) {\n            \tif (criteriaObjs[p] instanceof String) {\n            \t\tif (!\"\".equals(result)) {\n            \t\t\tresult += \",\";\n            \t\t}\n            \t\tresult += \"\" + quoteStr + escape(criteriaObjs[p], quoteStr) + quoteStr;\n            \t} else {\n            \t\tPair<String, String> ser = (Pair<String, String>)criteriaObjs[p];\n            \t\tser.setFirst(\"\" + quoteStr + escape(ser.getFirst(), quoteStr) + quoteStr);\n            \t\tser.setSecond(\"\" + quoteStr + escape(ser.getSecond(), quoteStr) + quoteStr);\n            \t\tsers.add(ser);\n            \t}\n            }\n            if (!\"\".equals(result) && !(fieldQRI instanceof TreeLevelQRI)) {\n            \tresult = fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()) + \" \" + operatorStr + \"(\" + result + \")\";\n            }\n            for (Pair<String, String> ser : sers) {\n            \tif (!\"\".equals(result)) {\n            \t\tresult += \" OR \";\n            \t}\n            \tresult += fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()) + \" BETWEEN \" + ser.getFirst() + \" AND \" + ser.getSecond();\n            }\n            result = \"(\" + result + \")\";\n        }\n        return result;\n    }\n    \n    /**\n     * @return\n     */\n    public boolean isNegated()\n    {\n    \treturn isNotCheckbox != null && isNotCheckbox.isSelected();\n    }\n\n    /**\n     * @return true if criteria entries should be handled as numeric cat nums for hql/sql\n     * \n     * NOTE: \"where catalogNumber = 1000\" works in hql even though catalogNumber is a string field.\n     * This MAY be because MySQL will automatically convert string/numeric types when necessary.\n     * If we switch to another sql dbms, catalogNumbers may have to be treated as strings.\n     * \n     */\n    protected boolean isNumericCatalogNumber() \n    {\n    \tUIFieldFormatterIFace formatter = fieldQRI.getFormatter();\n    \treturn formatter instanceof CatalogNumberUIFieldFormatter && ((CatalogNumberUIFieldFormatter )formatter).isNumeric();    \t\n    }\n\n    /**\n     * @return true is the the 'Empty' operator criteria operator is selected\n     */\n    public boolean isEmptyCriterion()\n    {\n    \treturn operatorCBX.getSelectedItem().equals(SpQueryField.OperatorType.EMPTY);\n    }\n    \n    /**\n     * @param op\n     * @return\n     */\n    protected String getOperatorQLText()\n    {\n    \treturn SpQueryField.OperatorType.getOp(((SpQueryField.OperatorType)operatorCBX.getSelectedItem()).getOrdinal());\n    }\n\n    \n    /**\n     * @return\n     */\n    @SuppressWarnings(\"unchecked\")\n    public String getCriteriaFormula(final TableAbbreviator ta,\n                                     final List<Pair<String, Object>> paramList)\n            throws ParseException\n    {\n        if (operatorCBX.getSelectedItem().equals(SpQueryField.OperatorType.EMPTY)) {\n            boolean isNot = isNotCheckbox.isSelected();\n            String nullCond = fieldQRI.getNullCondition(ta, schemaItem != null, isNot, getFormatName());\n            if (fieldQRI.getDataClass().equals(String.class)) {\n                String fieldSpec = fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()); \n                return \"(\" + nullCond + (isNot ? \" and \" : \" or \") + fieldSpec + (isNot ? \" <> \" : \" = \") + \"'')\";\n            }\n        \treturn nullCond;\n        }\n\n        \n        if (hasCriteria()) {\n            boolean addNullConjunction = false;\n            boolean nullPick = criteria instanceof PickListCriteriaCombo && ((PickListCriteriaCombo)criteria).nullItemIsPicked();\n        \tObject[] criteriaStrs = parseCriteria(getCriteriaText(true).trim());\n            String criteriaFormula = \"\";\n            //String operStr = operatorCBX.getSelectedItem().toString();\n            String operStr = getOperatorQLText();\n            if (!(criteriaStrs[0] instanceof String) && !(criteriaStrs[0] instanceof Pair)) {\n                //XXX - If the field has a formatter and it returned non-String data\n                // then assume all parsing and conversion has been accomplished??\n                //(hopefully this will never occur)\n                log.info(fieldQRI.getFieldInfo() + \": formatter returned non-string data.\");\n                criteriaFormula = concatCriteria(criteriaStrs, operStr, false, ta);\n            } else {\n                if (fieldQRI.getDataClass().equals(Boolean.class)) {\n                    if (operStr.equals(SpQueryField.OperatorType\n                            .getOp(SpQueryField.OperatorType.TRUE.getOrdinal())) ||\n                            operStr.equals(SpQueryField.OperatorType\n                                    .getOp(SpQueryField.OperatorType.TRUEORNULL.getOrdinal())) ) {\n                        criteriaFormula = \"true\";\n                    } else {\n                        criteriaFormula = \"false\";\n                    }\n                    addNullConjunction = operStr.equals(SpQueryField.OperatorType\n                                    .getOp(SpQueryField.OperatorType.FALSEORNULL.getOrdinal())) ||\n                            operStr.equals(SpQueryField.OperatorType\n                                    .getOp(SpQueryField.OperatorType.TRUEORNULL.getOrdinal()));\n                    operStr = \"=\";\n                } else if (fieldQRI.getDataClass().equals(String.class) && !isNumericCatalogNumber()) {\n                    criteriaFormula = concatCriteria(criteriaStrs, operStr, !(pickList instanceof PickListTableAdapter), ta);\n                } else if (fieldQRI.getDataClass().equals(Calendar.class) || fieldQRI.getDataClass().equals(java.sql.Timestamp.class)) {\n                \tfor (int p = 0; p < criteriaStrs.length; p++) {\n                \t\tString paramName = \"spparam\" + paramList.size();\n                        try {\n                            if (fieldQRI instanceof DateAccessorQRI) {\n                            \tnew Integer((String )criteriaStrs[p]);\n                            } else {\n                            \tObject arg = dateConverter.convert((String)criteriaStrs[p]);\n                            \tif (fieldQRI.getDataClass().equals(java.sql.Timestamp.class)) {\n                            \t\targ = new java.sql.Timestamp(((Calendar)arg).getTimeInMillis());\n                            \t}\n                            \tparamList.add(new Pair<String, Object>(paramName, arg));\n                            }\n                        } catch (ParseException ex) {\n                            throw new ParseException(getLabel()\n                                    + \" - \"\n                                    + String.format(UIRegistry.getResourceString(\"QB_PARSE_ERROR\"),\n                                            ex.getLocalizedMessage()), -1);\n                        }\n                        if (p > 0) {\n                            if (operatorCBX.getSelectedItem() == SpQueryField.OperatorType.BETWEEN) {\n                                criteriaFormula += \" and \";\n                            } else {\n                                criteriaFormula += \", \";\n                            }\n                        }\n                        if (fieldQRI instanceof DateAccessorQRI) {\n                        \tcriteriaFormula += (String )criteriaStrs[p];\n                        } else {\n                        \tcriteriaFormula += \":\" + paramName;\n                        }\n                    }\n                    if (SpQueryField.OperatorType.getOrdForOp(operStr) == SpQueryField.OperatorType.IN\n                            .getOrdinal()) {\n                        criteriaFormula = \"(\" + criteriaFormula + \")\";\n                    }\n                } else if (Number.class.isAssignableFrom(fieldQRI.getDataClass()) || isNumericCatalogNumber()) {\n                    Constructor<?> tester;\n                    try {\n                        tester = isNumericCatalogNumber() ? BigInteger.class.getConstructor(String.class)\n                        \t\t: fieldQRI.getDataClass().getConstructor(String.class);\n                        for (int s = 0; s < criteriaStrs.length; s++) {\n                            Object critter = criteriaStrs[s];\n                            List<String> strs = new ArrayList<String>(2);\n                            if (critter instanceof String) {\n                            \tstrs.add(critter.toString());\n                            } else {\n                            \t//seriesPresent = true;\n                            \tif (!operStr.equals(SpQueryField.OperatorType\n                                    .getOp(SpQueryField.OperatorType.IN.getOrdinal()))) {\n                                    throw new ParseException(getLabel()\n                                            + \" - \"\n                                            + UIRegistry.getResourceString(\"QB_INVALID_CRITERIA\"), -1);\n                            \t}\n                            \tstrs.add(((Pair<String, String>)critter).getFirst());\n                            \tstrs.add(((Pair<String, String>)critter).getSecond());\n                            }\n                            List<String> newStrs = new ArrayList<String>(2);\n                            for (String str : strs) {\n                            \ttester.newInstance(str);\n                            \n                            \t//remove leading zeroes\n                            \tString newString = str;\n                            \tboolean isZeroes = false;\n                            \twhile (newString.startsWith(\"0\")) {\n                            \t\tnewString = newString.substring(1);\n                            \t\tisZeroes = true;\n                            \t}\n                            \tif (isZeroes && StringUtils.isBlank(newString)) {\n                            \t\tnewString = \"0\";\n                            \t}\n                            \tnewStrs.add(newString);\n                            }\n                            if (newStrs.size() == 2) {\n                            \t((Pair<String, String>)criteriaStrs[s]).setFirst(newStrs.get(0));\n                            \t((Pair<String, String>)criteriaStrs[s]).setSecond(newStrs.get(1));\n                            } else {\n                            \tcriteriaStrs[s] = newStrs.get(0);\n                            }\n                        }\n                    } catch (NoSuchMethodException ex) {\n                        edu.ku.brc.af.core.UsageTracker.incrHandledUsageCount();\n                        edu.ku.brc.exceptions.ExceptionTracker.getInstance().capture(QueryFieldPanel.class, ex);\n                        // this will never happen. trust me.\n                        throw new RuntimeException(ex);\n                    } catch (InvocationTargetException ex) {\n                        if (ex.getTargetException() instanceof NumberFormatException) {\n                            String msg = ex.getTargetException().getLocalizedMessage();\n                            if (StringUtils.isBlank(msg)) {\n                                msg = ex.getTargetException().getClass().getSimpleName();\n                               \n                            }\n                            throw new ParseException(getLabel()\n                                    + \" - \"\n                                    + String.format(UIRegistry.getResourceString(\"QB_PARSE_ERROR\"), msg), -1);\n                        }\n                        throw new RuntimeException(ex);\n                    } catch (IllegalAccessException ex) {\n                        edu.ku.brc.af.core.UsageTracker.incrHandledUsageCount();\n                        edu.ku.brc.exceptions.ExceptionTracker.getInstance().capture(QueryFieldPanel.class, ex);\n                        throw new RuntimeException(ex);\n                    } catch (InstantiationException ex) {\n                        edu.ku.brc.af.core.UsageTracker.incrHandledUsageCount();\n                        edu.ku.brc.exceptions.ExceptionTracker.getInstance().capture(QueryFieldPanel.class, ex);\n                        throw new RuntimeException(ex);\n                    } catch (NumberFormatException ex) {\n                        String msg = ex.getLocalizedMessage();\n                        if (StringUtils.isBlank(msg)) {\n                            msg = ex.getClass().getSimpleName();\n                        }\n                        throw new ParseException(getLabel()\n                                + \" - \"\n                                + String.format(UIRegistry.getResourceString(\"QB_PARSE_ERROR\"), msg), -1);\n                    }\n                    criteriaFormula = concatCriteria(criteriaStrs, operStr, false, ta);\n                }\n            }\n            if (operStr.equals(SpQueryField.OperatorType\n                            .getOp(SpQueryField.OperatorType.CONTAINS.getOrdinal()))) {\n                operStr = \"Like\";\n            }\n                            \n            if (criteriaFormula.length() > 0 || nullPick || fieldQRI instanceof TreeLevelQRI) {\n                if (fieldQRI instanceof TreeLevelQRI) {\n                    try {\n                    \treturn ((TreeLevelQRI)fieldQRI).getNodeNumberCriteria(criteriaFormula, ta, operStr, isNotCheckbox.isSelected());\n                    } catch (ParseException pe) {\n                        throw new ParseException(getLabel()\n                                + \" - \"\n                                + String.format(UIRegistry.getResourceString(\"QB_PARSE_ERROR\"),\n                                        pe.getLocalizedMessage()), -1);\n                   \t\n                    }\n                }\n                    \n                StringBuilder str = new StringBuilder();\n\n                str.append(isNotCheckbox.isSelected() ? \"(NOT \" : \"\");\n                if (!operStr.equals(SpQueryField.OperatorType\n                        .getOp(SpQueryField.OperatorType.IN.getOrdinal()))) {\n                \tstr.append(fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()) + \" \");\n                }\n                if (nullPick && \"=\".equals(operStr)) {\n                \tstr.append(\" is null \");\n                } else if (!operStr.equals(SpQueryField.OperatorType\n                        .getOp(SpQueryField.OperatorType.IN.getOrdinal()))) {\n                \tstr.append(operStr);\n                }\n                str.append(\" \");\n                if (!(nullPick && \"=\".equals(operStr))) {\n                \tstr.append(criteriaFormula);\n                }\n                if (isNotCheckbox.isSelected()) {\n                    if (!operStr.equals(SpQueryField.OperatorType\n                            .getOp(SpQueryField.OperatorType.EMPTY.getOrdinal()))) {\n                        str.append(\" or \" + fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()) + \" is null\");\n                    }\n                    str.append(\")\");\n                }\n                String result =  str.toString();\n                if (addNullConjunction \n                \t\t|| (StringUtils.isNotBlank(result) && isEnforcedCkbx != null && isEnforcedCkbx.isSelected() && schemaMapping != null)\n                \t\t|| (nullPick && !\"=\".equals(operStr)))\n                {\n                \t//Currently, when the null value is picked with the IN condition, a '' entry is included in the IN list\n                \t//This is not technically correct, but probably will never matter, and possibly produce more desirable \n                \t//results then the technically correct criteria \n                \tresult = \"(\" + result + \" or \" + fieldQRI.getSQLFldSpec(ta, true, schemaItem != null, getFormatName()) + \" is null)\";\n                }\n                if (fieldQRI instanceof DateAccessorQRI) {\n                    result = ((DateAccessorQRI)fieldQRI).refineCriteria(ta, isNotCheckbox.isSelected(), result);\n                }\n                return result;\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * @return the fieldQRI\n     */\n    public FieldQRI getFieldQRI()\n    {\n        return fieldQRI;\n    }\n    \n    protected JTextField createTextField(final String id)\n    {\n        ValTextField textField = new ValTextField();\n        textField.setRequired(false);\n        validator.hookupTextField(textField, id, false, UIValidator.Type.Changed, \"\", true);\n        return textField;\n    }\n    \n    protected PickListCriteriaCombo createPickList(final Component saveBtn)\n    {\n        PickListCriteriaCombo result = new PickListCriteriaCombo(pickList);\n        if (!ownerQuery.isPromptMode())\n        {\n            result.addActionListener(new ActionListener() {\n\n                /* (non-Javadoc)\n                 * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n                 */\n                @Override\n                public void actionPerformed(ActionEvent e)\n                {\n                    if (e.getID() == 1001/*ComboBoxChanged*/)\n                    {\n                        if (saveBtn != null)\n                        {\n                        \tsaveBtn.setEnabled(true);\n                        }\n                    }\n                }\n            \n            });\n        }\n        return result;\n    }\n    \n    protected JCheckBox createCheckBox(final String id)\n    {\n        ValCheckBox checkbox = new ValCheckBox(\"\", false, false);\n        DataChangeNotifier dcn = validator.createDataChangeNotifer(id, checkbox, null);\n        checkbox.addActionListener(dcn);\n        return checkbox;\n    }\n    \n    protected JComboBox createComboBox(SpQueryField.OperatorType[] items)\n    {\n        ValComboBox cbx = new ValComboBox(items, false);\n        DataChangeNotifier dcn = validator.hookupComponent(cbx, \"cbx\",  UIValidator.Type.Changed, \"\", true);\n        cbx.getComboBox().addActionListener(dcn);\n        return cbx.getComboBox();\n    }\n\n    /**\n     * @param iconSize\n     * @param returnWidths\n     * @return\n     */\n    protected int[] buildControlLayout(final IconManager.IconSize iconSize,\n                                       final boolean returnWidths, final Component saveBtn)\n    {\n        FocusListener focusListener = new FocusListener()\n        {\n\n            /*\n             * (non-Javadoc)\n             * \n             * @see java.awt.event.FocusListener#focusGained(java.awt.event.FocusEvent)\n             */\n            // @Override\n            public void focusGained(FocusEvent e)\n            {\n                //Checking oppositeComponent to work around\n                //weird behavior after addBtn is clicked which\n                //causes top queryFieldPanel to be selected.\n                if (ownerQuery.getAddBtn() != null && e.getOppositeComponent() != ownerQuery.getAddBtn())\n                {\n                    ownerQuery.selectQFP(QueryFieldPanel.this);\n                }\n\n            }\n\n\n            /*\n             * (non-Javadoc)\n             * \n             * @see java.awt.event.FocusListener#focusLost(java.awt.event.FocusEvent)\n             */\n            // @Override\n            public void focusLost(FocusEvent e)\n            {\n                // nada\n            }\n\n        };\n\n        KeyListener enterListener = new KeyListener(){\n\n\t\t\t@Override\n\t\t\tpublic void keyPressed(KeyEvent arg0) {\n\t\t\t\t//nuthin\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void keyReleased(KeyEvent arg0) {\n\t\t\t\t//nuthin\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void keyTyped(KeyEvent arg0) {\n\t\t\t\tif (arg0.getKeyChar() == KeyEvent.VK_ENTER && ownerQuery != null)\n\t\t\t\t{\n\t\t\t\t\townerQuery.doSearch();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n        \t\n        };\n        \n        comparators = getComparatorList(fieldQRI);\n        //XXX need to build schemaItem for header panel too...\n        if (schemaMapping != null)\n        {\n        \tschemaItemCBX = edu.ku.brc.ui.UIHelper.createComboBox();\n        \tschemaItemCBX.addItem(\"empty\"); //to work around validator blow up for empty lists.\n            DataChangeNotifier dcnsi = validator.hookupComponent(schemaItemCBX, \"sicbx\",\n                    UIValidator.Type.Changed, \"\", true);\n            schemaItemCBX.addActionListener(dcnsi);\n        \t\n            schemaItemCBX.addItemListener(new ItemListener() {\n                @Override\n                public void itemStateChanged(ItemEvent e)\n                {\n                    if (!QueryFieldPanel.this.ownerQuery.isUpdatingAvailableConcepts())\n                    {\n                    \tif (e.getStateChange() == ItemEvent.SELECTED)\n                    \t{\n                    \t\tif (e.getItem() instanceof SpExportSchemaItem)\n                    \t\t{\n                    \t\t\tQueryFieldPanel.this.schemaItem = (SpExportSchemaItem )e.getItem();\n                    \t\t} else\n                    \t\t{\n                    \t\t\tSpExportSchemaItemMapping m = QueryFieldPanel.this.getItemMapping(); \n                    \t\t\tSpExportSchemaItem si = QueryFieldPanel.this.schemaItem;\n                    \t\t\tString item = e.getItem().toString();\n                    \t\t\tif (StringUtils.isNotBlank(item) && ownerQuery.isAvailableExportFieldName(QueryFieldPanel.this, item))\n                    \t\t\t{\n                    \t\t\t\tif (m != null)\n                    \t\t\t\t{\n                    \t\t\t\t\tm.setExportedFieldName(e.getItem().toString());\n                    \t\t\t\t}\n                    \t\t\t\tif (si != null)\n                    \t\t\t\t{\n                    \t\t\t\t\tsi.setFieldName(e.getItem().toString());\n                    \t\t\t\t}\n                    \t\t\t} else\n                    \t\t\t{\n                    \t\t\t\tif (StringUtils.isBlank(item))\n                    \t\t\t\t{\n                    \t\t\t\t\tUIRegistry.displayErrorDlgLocalized(\"QueryFieldPanel.ExportFieldNameInvalid\", item);\n                    \t\t\t\t} else\n                    \t\t\t\t{\n                    \t\t\t\t\tUIRegistry.displayErrorDlgLocalized(\"QueryFieldPanel.ExportFieldNameAlreadyUsed\", item);\n                    \t\t\t\t}\n                    \t\t\t\tschemaItemCBX.setSelectedIndex(0);\n                    \t\t\t}\n                    \t\t}\n                    \t\townerQuery.updateAvailableConcepts();\n                    \t}\n                    }\n                }\n            });\n        } else\n        {\n        \tschemaItemCBX = null;\n        }\t\n        \n        iconLabel = new JLabel(icon);\n        iconLabel.addFocusListener(focusListener);\n        String fieldLabelText = fieldQRI != null ? fieldQRI.getTitle() : \"WXYZ\";\n        if (fieldQRI instanceof RelQRI)\n        {\n            DBRelationshipInfo.RelationshipType relType = ((RelQRI)fieldQRI).getRelationshipInfo().getType();\n            if (relType.equals(DBRelationshipInfo.RelationshipType.OneToMany) || \n                    relType.equals(DBRelationshipInfo.RelationshipType.ManyToMany))\n            {\n                fieldLabelText += \" \" + UIRegistry.getResourceString(\"QB_AGGREGATED\");\n            }\n            else\n            {\n                fieldLabelText += \" \" + UIRegistry.getResourceString(\"QB_FORMATTED\");\n            }\n                \n        }\n        fieldLabel = createLabel(fieldLabelText);\n        fieldLabel.addFocusListener(focusListener);\n        fieldLabel.addKeyListener(enterListener);\n        isNotCheckbox = createCheckBox(\"isNotCheckbox\");\n        isNotCheckbox.addFocusListener(focusListener);\n        isNotCheckbox.addKeyListener(enterListener);\n        operatorCBX = createComboBox(comparators);\n        operatorCBX.addFocusListener(focusListener);\n        operatorCBX.addKeyListener(enterListener);\n        boolean isBool = fieldQRI != null && fieldQRI.getDataClass().equals(Boolean.class);\n        if (!isBool)\n        {\n            operatorCBX.addItemListener(new ItemListener() {\n                @Override\n                public void itemStateChanged(ItemEvent e)\n                {\n                    if (e.getStateChange() == ItemEvent.SELECTED)\n                    {\n                        criteria.setVisible(!operatorCBX.getSelectedItem().equals(SpQueryField.OperatorType.EMPTY));\n                    }\n                }\n            });\n        }\n        if (pickList == null)\n        {\n            boolean hasBetweenOp = false;\n            for (int o=0; o < comparators.length; o++)\n            {\n                if (comparators[o].equals(OperatorType.BETWEEN))\n                {\n                    hasBetweenOp = true;\n                    break;\n                }\n            }\n            if (hasBetweenOp)\n            {\n                criteria = new CriteriaPair(enterListener);\n                operatorCBX.addActionListener(this);\n            }\n            else\n            {\n                criteria = createTextField(\"1\");\n                criteria.addKeyListener(enterListener);\n            }\n        }\n        else\n        {\n            criteria = createPickList(saveBtn);\n            if (!ownerQuery.isPromptMode())\n            {\n                ((PickListCriteriaCombo) criteria).setCurrentOp((SpQueryField.OperatorType) operatorCBX.getModel().getElementAt(0));\n            }\n            criteria.addKeyListener(enterListener);\n            operatorCBX.addItemListener(new ItemListener()\n            {\n\n                /*\n                 * (non-Javadoc)\n                 * \n                 * @see javax.swing.event.ListSelectionListener#valueChanged(javax.swing.event.ListSelectionEvent)\n                 */\n                //@Override\n                public void itemStateChanged(ItemEvent e)\n                {\n                    if (e.getStateChange() == ItemEvent.SELECTED)\n                    {\n                        // System.out.println(\"setting curront op\");\n                        ((PickListCriteriaCombo) criteria)\n                                .setCurrentOp((SpQueryField.OperatorType) operatorCBX\n                                        .getSelectedItem());\n                    }\n                }\n\n            });\n        }\n        //criteria.addFocusListener(focusListener);\n        \n        sortCheckbox = new MultiStateIconButon(new ImageIcon[] {\n                IconManager.getImage(\"GrayDot\", IconManager.IconSize.Std16),\n                IconManager.getImage(\"UpArrow\", IconManager.IconSize.Std16),\n                IconManager.getImage(\"DownArrow\", IconManager.IconSize.Std16) });\n        DataChangeNotifier dcn = validator.hookupComponent(sortCheckbox, \"scb\",\n                UIValidator.Type.Changed, \"\", true);\n        sortCheckbox.addFocusListener(focusListener);\n        sortCheckbox.addActionListener(dcn);\n        sortCheckbox.addKeyListener(enterListener);\n        if (!this.ownerQuery.isPromptMode())\n        {\n            isEnforcedCkbx = createCheckBox(\"isEnforcedCkbx\");\n            dcn = validator.hookupComponent(isEnforcedCkbx, \"iecb\",\n                    UIValidator.Type.Changed, \"\", true);\n            isEnforcedCkbx.addActionListener(dcn);\n            isEnforcedCkbx.addFocusListener(focusListener);\n            isEnforcedCkbx.addKeyListener(enterListener);\n        }\n        if (!this.ownerQuery.isPromptMode())\n        {\n            isDisplayedCkbx = createCheckBox(\"isDisplayedCkbx\");\n            dcn = validator.hookupComponent(isDisplayedCkbx, \"idcb\",\n                    UIValidator.Type.Changed, \"\", true);\n            isDisplayedCkbx.addFocusListener(focusListener);\n            isDisplayedCkbx.addKeyListener(enterListener);\n            isDisplayedCkbx.addActionListener(dcn);\n            isDisplayedCkbx.addActionListener(new ActionListener() {\n\n\t\t\t\t/* (non-Javadoc)\n\t\t\t\t * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n\t\t\t\t */\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent arg0)\n\t\t\t\t{\n\t\t\t\t\tSwingUtilities.invokeLater(new Runnable() {\n\n\t\t\t\t\t\t/* (non-Javadoc)\n\t\t\t\t\t\t * @see java.lang.Runnable#run()\n\t\t\t\t\t\t */\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsortCheckbox.setEnabled(isDisplayedCkbx.isSelected());\n\t\t\t\t\t\t\townerQuery.changeNotification(QueryFieldPanel.this);\n                            if (!isDisplayedCkbx.isSelected()) {\n                                schemaItemCBX.setSelectedIndex(0);\n                            }\n                            schemaItemCBX.setEnabled(isDisplayedCkbx.isSelected());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n            });\n            isPromptCkbx = createCheckBox(\"isPromptCkbx\");\n            dcn = validator.hookupComponent(isPromptCkbx, \"ipcb\",\n                    UIValidator.Type.Changed, \"\", true);\n            isPromptCkbx.addActionListener(dcn);\n            isPromptCkbx.addFocusListener(focusListener);\n            isPromptCkbx.addKeyListener(enterListener);\n            closeBtn = edu.ku.brc.ui.UIHelper.createIconBtn(\"Close\", \"QB_REMOVE_FLD\", new ActionListener()\n            {\n                public void actionPerformed(ActionEvent ae)\n                {\n            \t\tboolean clearIt = schemaItem != null;\n                \townerQuery.removeQueryFieldItem((QueryFieldPanel) ((JComponent) ae.getSource())\n                        .getParent());\n                \tif (clearIt)\n                \t{\n                 \t\tsetField(null, null);\n                \t}\n                }\n            });\n            closeBtn.setEnabled(true);\n            closeBtn.setFocusable(false);\n            closeBtn.addMouseListener(new MouseAdapter() {\n\n                @Override\n                public void mouseEntered(MouseEvent e)\n                {\n                    ((JButton)e.getSource()).setIcon(IconManager.getIcon(\"CloseHover\"));\n                    super.mouseEntered(e);\n                }\n\n                @Override\n                public void mouseExited(MouseEvent e)\n                {\n                    ((JButton)e.getSource()).setIcon(IconManager.getIcon(\"Close\"));\n                    super.mouseExited(e);\n                }\n                \n            });\n        }\n        else\n        {\n            isDisplayedCkbx = null;\n            this.isPromptCkbx = null;\n            this.isEnforcedCkbx = null;            \n            this.closeBtn = null;\n    \t}\n\n        JComponent[] qComps = {iconLabel, fieldLabel, isNotCheckbox, operatorCBX, criteria,\n                sortCheckbox, isDisplayedCkbx, isPromptCkbx, isEnforcedCkbx, closeBtn, null };\n        JComponent[] sComps = { schemaItemCBX, iconLabel, fieldLabel, isNotCheckbox, operatorCBX, criteria,\n                sortCheckbox, isDisplayedCkbx, isEnforcedCkbx, closeBtn, null };\n        // 0 1 2 3 4 5 6 7 8 9\n        if (schemaMapping == null)\n        {\n        \tcomps = qComps;\n        }\n        else\n        {\n        \tcomps = sComps;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        Integer[] qFixedCmps = {300};\n        Integer[] sFixedCmps = {268, 300};\n        Integer[] fixedCmps;\n        if (schemaMapping != null) \n        {\n        \tfixedCmps = sFixedCmps;\n        } else\n        {\n        \tfixedCmps = qFixedCmps;\n        }\n        if (columnDefStr == null)\n        {\n            for (int i = 0; i < comps.length; i++)\n            {\n                sb.append(i == 0 ? \"\" : \",\");\n                if (isCenteredComp(i))\n                    sb.append(\"c:\");\n                if (i >= fixedCmps.length)\n                {\n                \tsb.append(\"p\");\n                }\n                else\n                {\n                \tsb.append(fixedCmps[i] + \"px\");\n                }\n                if (isGrowComp(i))\n                    sb.append(\":g\");\n                sb.append(\",4px\");\n            }\n        }\n        else\n        {\n            sb.append(columnDefStr);\n        }\n\n        PanelBuilder builder = new PanelBuilder(new FormLayout(\"3px, \" + sb.toString() + \", 3px\", \"3px, p, 3px\"), this);\n        CellConstraints cc = new CellConstraints();\n\n        int col = 1;\n        for (JComponent comp : comps)\n        {\n            if (comp != null)\n            {\n                builder.add(comp, cc.xy(col+1, 2));\n            }\n            col += 2;\n        }\n\n        if (fieldQRI != null)\n        {\n            icon = IconManager.getIcon(fieldQRI.getTableInfo().getName(), iconSize);\n            setIcon(icon);\n        }\n        if (!ownerQuery.isPromptMode())\n        {\n            isDisplayedCkbx.setSelected(true);\n            isPromptCkbx.setSelected(!(fieldQRI instanceof RelQRI));\n            isEnforcedCkbx.setSelected(false);\n        }\n\n        if (fieldQRI == null && !returnWidths)\n        {\n        \tfor (int c = 1; c < comps.length; c++)\n        \t{\n        \t\tif (comps[c] != null)\n        \t\t{\n        \t\t\tcomps[c].setVisible(false);\n        \t\t}\n        \t}\n        }\n        else\n        {\n\t\t\t// for now\n\t\t\tboolean isRel = fieldQRI != null && fieldQRI instanceof RelQRI;\n\t\t\tboolean isTreeLevel = fieldQRI instanceof TreeLevelQRI;\n\t\t\tisNotCheckbox.setVisible(!isRel || pickList != null);\n\t\t\toperatorCBX.setVisible(!isRel || pickList != null);\n\t\t\tcriteria.setVisible((!isRel && !isBool) || pickList != null);\n\t\t\tif (schemaMapping != null)\n\t\t\t{\n\t\t\t\tthis.sortCheckbox.setVisible(!(isTreeLevel || isRel));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!isRel)\n\t\t\t\t{\n\t\t\t\t\tthis.sortCheckbox.setVisible(true);\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tthis.sortCheckbox\n\t\t\t\t\t\t.setVisible(((RelQRI) fieldQRI).getRelationshipInfo()\n\t\t\t\t\t\t\t\t.getType() != RelationshipType.OneToMany);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!ownerQuery.isPromptMode())\n\t\t\t{\n\t\t\t\tisDisplayedCkbx.setVisible(!isRel);\n\t\t\t\tisPromptCkbx.setVisible(!isRel);\n\t\t\t\tisEnforcedCkbx.setVisible(!isRel);\n\t\t\t}\n\t\t}\n        validate();\n        doLayout();\n\n        int[] widths = null;\n        if (returnWidths)\n        {\n            widths = new int[comps.length];\n            for (int i = 0; i < comps.length; i++)\n            {\n                widths[i] = comps[i] != null ? comps[i].getSize().width : 0;\n            }\n            if (this.schemaMapping == null)\n            {\n            \twidths[0] = iconSize.size();\n            \twidths[1] = 200;\n            }\n            else\n            {\n            \twidths[1] = iconSize.size();\n            \twidths[2] = 200;\n            }\n        }\n        return widths;\n    }\n    \n    /**\n     * @param compIdx\n     * @return true if comps[compIdx] should be centered\n     */\n    protected boolean isCenteredComp(int compIdx)\n    {\n        if (schemaMapping == null)\n        {\n        \treturn compIdx == 1 || compIdx == 2 || compIdx == 5 || compIdx == 6 || compIdx == 7;\n        }\n        else\n        {\n        \treturn compIdx == 2 || compIdx == 3 || compIdx == 6 || compIdx == 7 || compIdx == 8;\n        }\n\n    }\n    \n    /**\n     * @param compIdx\n     * @return true if comps[compIdx] should grow.\n     */\n    protected boolean isGrowComp(int compIdx)\n    {\n    \treturn schemaMapping == null ? compIdx == 4 : compIdx == 5;\n    }\n    \n    /**\n     * @param iconSize\n     * @param widths\n     */\n    protected void buildLabelLayout(final int[] widths)\n    {\n        \n        StringBuilder sb     = new StringBuilder();\n        JLabel[] labels      = new JLabel[labelStrs.length];\n        int[]    labelWidths = new int[labelStrs.length];\n        for (int i=0;i<labels.length;i++)\n        {\n            labels[i] = createLabel(labelStrs[i], SwingConstants.CENTER);\n            labelWidths[i] = Math.max(widths[i], labels[i].getPreferredSize().width);\n            //System.out.println(labelStrs[i]+\"  \"+labelWidths[i]);\n        }\n\n        for (int i=0;i<labels.length;i++)\n        {\n            sb.append(i == 0 ? \"\" : \",\");\n            if (isCenteredComp(i)) sb.append(\"c:\");\n            sb.append(\"max(\");\n            sb.append(labelWidths[i]);\n            sb.append(\";p)\");\n            if (isGrowComp(i)) sb.append(\":g\");\n            sb.append(\",4px\");\n        }\n\n        //System.out.println(sb.toString());\n        columnDefStr = sb.toString();\n        \n        \n        PanelBuilder    builder = new PanelBuilder(new FormLayout(sb.toString(), \"p\"), this);\n        CellConstraints cc      = new CellConstraints();\n\n\n        int x = 1;\n        for (JLabel label : labels)\n        {\n            builder.add(label, cc.xy(x, 1));\n            x += 2;\n        }          \n    }\n    \n    /**\n     * Split apart the name keying on upper case\n     * @param nameToFix the name of the field\n     * @return the split apart name\n     */\n    protected String fixName(final String nameToFix)\n    {\n        StringBuilder s = new StringBuilder();\n        for (int i=0;i<nameToFix.length();i++)\n        {\n            if (i == 0) \n            {\n                s.append(Character.toUpperCase(nameToFix.charAt(i)));\n            } else\n            {\n                char c = nameToFix.charAt(i);\n                if (Character.isUpperCase(c))\n                {\n                    s.append(' ');\n                }\n                s.append(c);\n            }\n        }\n        return s.toString();  \n    }\n\n\n    /**\n     * @param icon\n     */\n    public void setIcon(ImageIcon icon)\n    {\n        this.icon = icon == null ? blankIcon : icon;\n        iconLabel.setIcon(this.icon);\n    }\n\n    /**\n     * @return the TableInfo object\n     */\n    public DBFieldInfo getFieldInfo()\n    {\n        if (fieldQRI != null)\n        {\n        \treturn fieldQRI.getFieldInfo();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the field name.\n     * @return the field name.\n     */\n    public String getFieldName()\n    {\n        return fieldLabel.getText();\n    }\n    \n    /**\n     * @return true if field is displayed in results\n     */\n    public boolean isForDisplay()\n    {\n        if (ownerQuery.isPromptMode()) {\n        \tif (queryField != null) {\n        \t\treturn queryField.getIsDisplay();\n        \t} else {\n        \t\treturn true;\n        \t}\n        } else {\n        \treturn isDisplayedCkbx.isSelected();\n        }\n    }\n    \n    /**\n     * @return the field label text\n     */\n    public String getLabel()\n    {\n        return this.fieldLabel.getText();\n    }\n\n    /**\n     * @return the schemaItem combo box\n     */\n    public JComboBox getSchemaItemCBX()\n    {\n    \treturn this.schemaItemCBX;\n    }\n    \n    /**\n     * @return the labelQualified\n     */\n    public boolean isLabelQualified()\n    {\n        return labelQualified;\n    }\n\n    /**\n     * @param otherLabels\n     * @param unQualify if true then label is un-qualified.\n     * @return a label for the field that is 'qualified' to distinguish it from other labels with the same title.\n     */\n    public String qualifyLabel(final List<String> otherLabels, final boolean unQualify)\n    {\n        boolean needToQualify;\n        List<String> labels;\n        //the following block is not currently used, but keeping it here in case the current strategy\n        //doesn't work out.\n        if (otherLabels == null)\n        {\n            needToQualify = false;\n            labels = new ArrayList<String>(ownerQuery.getFields()-1);\n            for (int i = 0; i < this.ownerQuery.getFields(); i++)\n            {\n                QueryFieldPanel p = ownerQuery.getField(i);\n                if (this != p)\n                {\n                    labels.add(p.getLabel());\n                    if (p.getFieldTitle().equals(getFieldTitle()))\n                    {\n                        needToQualify = true;\n                    }\n                }\n            }\n        }\n        else\n        {\n            needToQualify = !unQualify;\n            labels = otherLabels;\n        }\n        \n        if (needToQualify)\n        {\n            String newLabel = getFieldTitle();\n            TableTree parent = fieldQRI.getTableTree();\n            int checkParent = 1;\n            do\n            {\n                newLabel = getQualifiedLabel(parent, checkParent-- > 0);\n                parent = parent.getParent();\n            } while (parent != null && labels.indexOf(newLabel) != -1 && !parent.getName().equals(\"root\"));\n            \n            labelQualified = true;\n            fieldLabel.setText(newLabel);\n        }\n        else\n        {\n            labelQualified = false;\n            fieldLabel.setText(getFieldTitle());\n        }\n        return fieldLabel.getText();\n    }\n\n    /**\n     * @return the title of the field.\n     */\n    protected String getFieldTitle()\n    {\n        if (fieldQRI != null)\n        {\n            return fieldQRI.getTitle();\n        }\n        return null;\n    }\n    \n    \n    \n    /**\n     * @param parent\n     * @param checkParent\n     * @return\n     */\n    protected String getQualifiedLabel(final TableTree parent, final boolean checkParent)\n    {\n        TableTree reParent = parent;\n        if (checkParent && reParent.getTableInfo().getClassObj().equals(Agent.class)\n                && (StringUtils.isEmpty(reParent.getField()) || reParent.getName().equalsIgnoreCase(reParent.getField())) \n                && reParent.getParent().getTableQRI() != null)\n        // agent (and what others??) generally offers no informative distinguishing info\n        {\n            reParent = reParent.getParent();\n        }\n        return reParent.getTableQRI().getTitle() + \"/\" + getFieldTitle();\n    }\n    \n    /* (non-Javadoc)\n     * @see javax.swing.JComponent#paint(java.awt.Graphics)\n     */\n    @Override\n    public void paint(Graphics g)\n    {\n        // TODO Auto-generated method stub\n        super.paint(g);\n\n        if (selected)\n        {\n            //this block was copied from RolloverCommand.paintComp()\n            \n            g.setColor(RolloverCommand.getActiveColor());\n            Insets insets = getInsets();\n            insets.set(1, 1, 1, 1);\n            Dimension size = getSize();\n            Graphics2D g2d = (Graphics2D) g;\n            g2d\n                    .setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                            RenderingHints.VALUE_ANTIALIAS_ON);\n            RoundRectangle2D.Double rr = new RoundRectangle2D.Double(insets.left, insets.top,\n                    size.width - insets.right - insets.left, size.height - insets.bottom\n                            - insets.top, 10, 10);\n            g2d.draw(rr);\n            rr = new RoundRectangle2D.Double(insets.left + 1, insets.top + 1, size.width\n                    - insets.right - insets.left - 2, size.height - insets.bottom - insets.top - 2,\n                    10, 10);\n            g2d.draw(rr);\n        }\n    }\n\n    /**\n     * @return the selected\n     */\n    public boolean isSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param selected the selected to set\n     */\n    public void setSelected(boolean selected)\n    {\n        this.selected = selected;\n    }\n    \n    /**\n     * @return true if this field's criteria should ALWAYS be applied.\n     */\n    public boolean isEnforced()\n    {\n        if (isEnforcedCkbx != null)\n        {\n            return isEnforcedCkbx.isSelected();\n        }\n        if (queryField != null)\n        {\n            return queryField.getAlwaysFilter();\n        }\n        return false;\n    }\n    \n    /**\n     * @return true if nulls are allowed. i.e: if 'or is null' should be appended to the field's criteria.\n     */\n    public boolean isAllowNulls()\n    {\n    \t//XXX until/if allowNulls is added to general queries, the isEnforcedCkbx is being used to \n    \t//access it\n    \tif (isEnforcedCkbx != null) \n        {\n            return isEnforcedCkbx.isSelected();\n        }\n        if (queryField != null)\n        {\n            return queryField.getAllowNulls();\n        }\n        return false;\n    }\n    \n    /**\n     * @return a string identifier unique to this field within the query that is independent of the field's title.\n     */\n    public String getStringId()\n    {\n        return fieldQRI.getStringId();\n    }\n\n    /**\n     * @return the pickList\n     */\n    public PickListDBAdapterIFace getPickList()\n    {\n        return pickList;\n    }\n\n    /* (non-Javadoc)\n     * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n     */\n    @Override\n    public void actionPerformed(ActionEvent e)\n    {\n        if (e.getSource().equals(operatorCBX))\n        {\n            OperatorType op = (OperatorType )operatorCBX.getSelectedItem();\n            if (op != null && op.equals(OperatorType.BETWEEN))\n            {\n                ((CriteriaPair )criteria).setShowingPair(true);\n            }\n            else\n            {\n                if (criteria instanceof CriteriaPair)\n                {\n                    ((CriteriaPair )criteria).setShowingPair(false);\n                }\n            }\n        }\n    }\n\n\t/**\n\t * @return the schemaItem\n\t */\n\tpublic SpExportSchemaItem getSchemaItem()\n\t{\n\t\treturn schemaItem;\n\t}\n\n\t/**\n\t * @return the itemMapping\n\t */\n\tpublic SpExportSchemaItemMapping getItemMapping()\n\t{\n\t\treturn queryField != null ? queryField.getMapping() : null;\n\t}\n\n\n\t/**\n\t * @return the autoMapped\n\t */\n\tpublic boolean isAutoMapped() \n\t{\n\t\treturn autoMapped;\n\t}\n\n\n\t/**\n\t * @param autoMapped the autoMapped to set\n\t */\n\tpublic void setAutoMapped(boolean autoMapped) \n\t{\n\t\tthis.autoMapped = autoMapped;\n\t}\n    \n\t\n}\n"},
{"Line": "=>69", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[]", "Content": "=>if (windowFrameDefinition != null) { this.windowFrameDefinition = windowFrameDefinition; }else { this.windowFrameDefinition = io.crate.analyze.WindowDefinition.DEFAULT_WINDOW_FRAME; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/7787/buggy-version/sql.src.main.java.io.crate.analyze.WindowDefinition.java", "BodyUseAPI": [], "Fixed commit": "92d7dc033b1915fffad7e88c0aca1cd422cc3a11", "Url": "https://api.github.com/repos/crate/crate", "Date": "2018-12-16T23:13:41Z", "Source Code Diff": "@@ -30,7 +30,6 @@\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.io.stream.Writeable;\n \n-import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n import java.io.IOException;\n import java.util.List;\n@@ -54,7 +53,6 @@ public class WindowDefinition implements Writeable {\n     private final List<Symbol> partitions;\n     @Nullable\n     private final OrderBy orderBy;\n-    @Nonnull\n     private final WindowFrameDefinition windowFrameDefinition;\n \n     public WindowDefinition(StreamInput in) throws IOException {\n@@ -65,15 +63,14 @@ public WindowDefinition(StreamInput in) throws IOException {\n \n     public WindowDefinition(List<Symbol> partitions,\n                             @Nullable OrderBy orderBy,\n-                            @Nonnull WindowFrameDefinition windowFrameDefinition) {\n+                            @Nullable WindowFrameDefinition windowFrameDefinition) {\n         this.partitions = partitions;\n         this.orderBy = orderBy;\n-        this.windowFrameDefinition = windowFrameDefinition;\n-    }\n-\n-    public WindowDefinition(List<Symbol> partitions,\n-                            @Nullable OrderBy orderBy) {\n-        this(partitions, orderBy, DEFAULT_WINDOW_FRAME);\n+        if (windowFrameDefinition != null) {\n+            this.windowFrameDefinition = windowFrameDefinition;\n+        } else {\n+            this.windowFrameDefinition = DEFAULT_WINDOW_FRAME;\n+        }\n     }\n \n     public List<Symbol> partitions() {", "Complete After Code": "/*\n * Licensed to Crate under one or more contributor license agreements.\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.  Crate licenses this file\n * to you under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied.  See the License for the specific language governing\n * permissions and limitations under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial\n * agreement.\n */\n\npackage io.crate.analyze;\n\n\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.expression.symbol.Symbols;\nimport io.crate.planner.ExplainLeaf;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.io.stream.Writeable;\n\nimport javax.annotation.Nullable;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static io.crate.sql.tree.FrameBound.Type.CURRENT_ROW;\nimport static io.crate.sql.tree.FrameBound.Type.UNBOUNDED_PRECEDING;\nimport static io.crate.sql.tree.WindowFrame.Type.RANGE;\n\n/**\n * Representation of a window used to describe the window function calls target.\n */\npublic class WindowDefinition implements Writeable {\n\n    public  static final WindowFrameDefinition DEFAULT_WINDOW_FRAME = new WindowFrameDefinition(\n        RANGE,\n        new FrameBoundDefinition(UNBOUNDED_PRECEDING),\n        new FrameBoundDefinition(CURRENT_ROW)\n    );\n\n    private final List<Symbol> partitions;\n    @Nullable\n    private final OrderBy orderBy;\n    private final WindowFrameDefinition windowFrameDefinition;\n\n    public WindowDefinition(StreamInput in) throws IOException {\n        partitions = Symbols.listFromStream(in);\n        orderBy = in.readOptionalWriteable(OrderBy::new);\n        windowFrameDefinition = in.readOptionalWriteable(WindowFrameDefinition::new);\n    }\n\n    public WindowDefinition(List<Symbol> partitions,\n                            @Nullable OrderBy orderBy,\n                            @Nullable WindowFrameDefinition windowFrameDefinition) {\n        this.partitions = partitions;\n        this.orderBy = orderBy;\n        if (windowFrameDefinition != null) {\n            this.windowFrameDefinition = windowFrameDefinition;\n        } else {\n            this.windowFrameDefinition = DEFAULT_WINDOW_FRAME;\n        }\n    }\n\n    public List<Symbol> partitions() {\n        return partitions;\n    }\n\n    @Nullable\n    public OrderBy orderBy() {\n        return orderBy;\n    }\n\n    public WindowFrameDefinition windowFrameDefinition() {\n        return windowFrameDefinition;\n    }\n\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeVInt(partitions.size());\n        for (Symbol partition : partitions) {\n            Symbols.toStream(partition, out);\n        }\n        out.writeOptionalWriteable(orderBy);\n        out.writeOptionalWriteable(windowFrameDefinition);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WindowDefinition that = (WindowDefinition) o;\n        return Objects.equals(partitions, that.partitions) &&\n               Objects.equals(orderBy, that.orderBy) &&\n               Objects.equals(windowFrameDefinition, that.windowFrameDefinition);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(partitions, orderBy, windowFrameDefinition);\n    }\n\n    @Override\n    public String toString() {\n        return \"WindowDefinition{\" +\n               \"partitions=\" + partitions +\n               \", orderBy=\" + orderBy +\n               \", windowFrame=\" + windowFrameDefinition +\n               '}';\n    }\n\n    public String representation() {\n        StringBuilder sb = new StringBuilder(\"Window{\");\n        if (partitions.size() > 0) {\n            sb.append(\"PARTITION BY \");\n            for (ExplainLeaf partition : partitions) {\n                sb.append(partition.representation());\n            }\n        }\n        if (orderBy != null) {\n            sb.append(\" \");\n            sb.append(orderBy.toString());\n        }\n\n        if (windowFrameDefinition != null) {\n            sb.append(\" \");\n            sb.append(windowFrameDefinition.toString());\n        }\n\n        sb.append(\"}\");\n        return sb.toString();\n    }\n\n}\n"},
{"Line": "=>111", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["edu.cofc.csis614.f18.ssdsim.machine.system.cache.CacheResponse.getRequest()"], "Type": "Insert", "BugDetectionTag": "[IfNull, IfRet, IfDep]", "Content": "=>if ((request != null) && ((request.getType()) == (edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequestType.READ))) { system.receiveIoRequestContinuingFromCache(request); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/3882/buggy-version/edu.cofc.csis614.f18.ssdsim.machine.system.cache.Cache.java", "BodyUseAPI": ["java.lang.System.receiveIoRequestContinuingFromCache(edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequest)"], "Fixed commit": "7bf34993b034ac19a403258c92515414ff023e48", "Url": "https://api.github.com/repos/csis656f18k/simssd614", "Date": "2018-12-08T17:01:46Z", "Source Code Diff": "@@ -10,6 +10,7 @@\n import edu.cofc.csis614.f18.ssdsim.DiskPerformanceSimulator;\n import edu.cofc.csis614.f18.ssdsim.Utils;\n import edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequest;\n+import edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequestType;\n import edu.cofc.csis614.f18.ssdsim.machine.ioop.IoResponse;\n import edu.cofc.csis614.f18.ssdsim.machine.system.System;\n import edu.cofc.csis614.f18.ssdsim.machine.system.disk.DiskConstants;\n@@ -30,7 +31,7 @@\n public class Cache {\n \tpublic static final int DEBUG_SIZE = 2;\n \t\n-\tpublic static final int DEFAULT_SIZE = 500;\n+\tpublic static final int DEFAULT_SIZE = 50; // Was briefly 500\n \n     public static final int DEBUG_READ_LATENCY = 1;\n     public static final int DEBUG_WRITE_LATENCY = 2;\n@@ -68,6 +69,14 @@ public Cache(System system, Timer timer) {\n         operationsInProgress = new TreeMap<Long, Set<CacheResponse>>();\n         operationsInProgressCount = 0;\n \t}\n+    \n+    public int getReadLatency() {\n+        return readLatency;\n+    }\n+    \n+    public int getWriteLatency() {\n+        return writeLatency;\n+    }\n \n     /**\n      * This gets run at the start of every time tick.\n@@ -96,11 +105,17 @@ public void cleanUpOldTasks() {\n         \n         operationsInProgressCount -= completedOperations.size();\n         for(CacheResponse cr : completedOperations) {\n-            // If this contains a request it just means the request has been written to cache; no action needed here\n+            // If this contains a write request it just means the request has been written to cache; no action needed here\n+            // If this contains a read request it looked in cache but failed; needs to be passed on to disk\n+            IoRequest request = cr.getRequest();\n+            if(request != null && request.getType() == IoRequestType.READ) {\n+                system.receiveIoRequestContinuingFromCache(request);\n+            }\n+            \n             // If this contains a completed response, hand it back to the system\n             IoResponse response = cr.getResponse();\n             if(response != null) {\n-              system.receiveCompletedIoOperationInfo(response);\n+                system.receiveCompletedIoOperationInfo(response);\n             }\n         }\n     }", "Complete After Code": "package edu.cofc.csis614.f18.ssdsim.machine.system.cache;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport edu.cofc.csis614.f18.ssdsim.DiskPerformanceSimulator;\nimport edu.cofc.csis614.f18.ssdsim.Utils;\nimport edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequest;\nimport edu.cofc.csis614.f18.ssdsim.machine.ioop.IoRequestType;\nimport edu.cofc.csis614.f18.ssdsim.machine.ioop.IoResponse;\nimport edu.cofc.csis614.f18.ssdsim.machine.system.System;\nimport edu.cofc.csis614.f18.ssdsim.machine.system.disk.DiskConstants;\nimport edu.cofc.csis614.f18.ssdsim.timer.Timer;\n\n/**\n * A place for the system to store memoized operations. Logically, this would be RAM or some other type of memory that is much faster than disk (either HDD or SSD).\n * \n * Stores the new values of the most recent n write operations.\n * If and when n is exceeded, the oldest item is evicted.\n * \n * If a read or write request comes in for a memoized piece of memory, it reads from the cache instead of disk.\n * If a write request comes in for memoized information, the memoized value is overwritten.\n * When a memoized request is used, its time is reset.\n * \n * When a memoized request is evicted from cache, it is added to the standard IO request queue.\n */\npublic class Cache {\n\tpublic static final int DEBUG_SIZE = 2;\n\t\n\tpublic static final int DEFAULT_SIZE = 50; // Was briefly 500\n\n    public static final int DEBUG_READ_LATENCY = 1;\n    public static final int DEBUG_WRITE_LATENCY = 2;\n\n    public static final int DEFAULT_READ_LATENCY = DiskConstants.RAM.getReadLatency();\n    public static final int DEFAULT_WRITE_LATENCY = DiskConstants.RAM.getWriteLatency();\n\t\n\tprivate Timer timer;\n    \n    System system;\n\t\n\t// The contents of the actual cache. Sorted in ascending order, i.e. the element that hasn't been used in the longest time is first (index 0)\n\tCacheItem[] contents;\n\tprivate int maxSize;\n\tprivate int cacheSpacesUsed;\n\t\n\tint readLatency;\n\tint writeLatency;\n    \n\t// Operations currently being done to the cache itself (e.g. saving a write request), organized by time of completion\n    SortedMap<Long, Set<CacheResponse>> operationsInProgress;\n    int operationsInProgressCount;\n\t\n\tpublic Cache(System system, Timer timer) {\n\t    this.timer = timer;\n        this.system = system;\n\t    \n        cacheSpacesUsed = 0;\n\t    maxSize = DiskPerformanceSimulator.DEBUG_MODE ? DEBUG_SIZE : DEFAULT_SIZE;\n        contents = new CacheItem[maxSize];\n\t    \n\t    readLatency = DiskPerformanceSimulator.DEBUG_MODE ? DEBUG_READ_LATENCY : DEFAULT_READ_LATENCY;\n\t    writeLatency = DiskPerformanceSimulator.DEBUG_MODE ? DEBUG_WRITE_LATENCY : DEFAULT_WRITE_LATENCY;\n\t    \n        operationsInProgress = new TreeMap<Long, Set<CacheResponse>>();\n        operationsInProgressCount = 0;\n\t}\n    \n    public int getReadLatency() {\n        return readLatency;\n    }\n    \n    public int getWriteLatency() {\n        return writeLatency;\n    }\n\n    /**\n     * This gets run at the start of every time tick.\n     * Check to see if anything in progress has finished, and if so, send a response or forward to disk as appropriate. \n     * \n     * Once this stuff is done, the cache can accept new incoming requests for this time tick.\n     */\n    public void updateTime() {\n        Utils.debugPrint(\"Requests being processed by cache at time \" + timer.getTime() + \": \");\n        for(long time : operationsInProgress.keySet()) {\n            Utils.debugPrint(\"Scheduled to complete at time \" + time + \":\");\n            for(CacheResponse response : operationsInProgress.get(time)) {\n                Utils.debugPrint(\"- \" + response);\n            }\n        }\n        \n        cleanUpOldTasks();\n    }\n    \n    public void cleanUpOldTasks() {\n        Set<CacheResponse> completedOperations = operationsInProgress.remove(timer.getTime());\n\n        if(completedOperations == null) {\n            return;\n        }\n        \n        operationsInProgressCount -= completedOperations.size();\n        for(CacheResponse cr : completedOperations) {\n            // If this contains a write request it just means the request has been written to cache; no action needed here\n            // If this contains a read request it looked in cache but failed; needs to be passed on to disk\n            IoRequest request = cr.getRequest();\n            if(request != null && request.getType() == IoRequestType.READ) {\n                system.receiveIoRequestContinuingFromCache(request);\n            }\n            \n            // If this contains a completed response, hand it back to the system\n            IoResponse response = cr.getResponse();\n            if(response != null) {\n                system.receiveCompletedIoOperationInfo(response);\n            }\n        }\n    }\n\t\n\tpublic void handleIoRequest(IoRequest request) {\n\t    switch(request.getType()) {\n\t        case READ:\n                handleReadRequest(request);\n                break;\n\t        case WRITE:\n                handleWriteRequest(request);\n                break;\n            default:\n                // FUTURE: this should never happen, implement an exception\n                break;\n\t    }\n\t}\n\n    public void handleReadRequest(IoRequest request) {\n        // If cache is empty, hand the request off immediately\n        if(cacheSpacesUsed == 0) {\n            system.receiveIoRequestContinuingFromCache(request);\n            return;\n        }\n\n        // Otherwise, there is a cache; loop through it to see if the desired value is present\n        // If found, read from cache, and after cache read time, signal that the I/O request is complete\n        int requestLatency = 0;\n        long completionTime = -1;\n        for(int cacheIndex = maxSize - 1; cacheIndex >= maxSize - cacheSpacesUsed; cacheIndex--) {\n            requestLatency += readLatency;\n            \n            if(request.referencesSameMemory(contents[cacheIndex].getRequest())) {\n                contents[cacheIndex].setLastReferencedTime(timer.getTime());\n                completionTime = timer.getTime() + requestLatency;\n                addInProgressCacheOperation(new CacheResponse(null, new IoResponse(request, completionTime), completionTime));\n                return;\n            }\n        }\n\n        // At this point the entire cache has been searched and the value wasn't found; signal that the request needs to be handed off to disk after cache read time\n        completionTime = timer.getTime() + requestLatency;\n        addInProgressCacheOperation(new CacheResponse(request, null, completionTime));\n    }\n\n    public void handleWriteRequest(IoRequest request) {\n        // When there is a cache, loop through it to see if the desired value is present\n        // If found, the old request is obsolete; replace it with the new one and silently drop the old one\n        int requestLatency = 0;\n        for(int cacheIndex = maxSize - 1; cacheIndex >= (maxSize - cacheSpacesUsed); cacheIndex--) {\n            IoRequest cachedRequest = contents[cacheIndex].getRequest();\n            requestLatency += readLatency;\n            \n            if(request.referencesSameMemory(cachedRequest)) {\n                evict(cacheIndex);\n                addToCache(cacheIndex, request, requestLatency);\n                \n                return;\n            }\n        }\n\n        // If the value isn't found anywhere in the cache, cache the new request\n        if(cacheSpacesUsed < maxSize) {\n            addToCache(0, request, requestLatency);\n            cacheSpacesUsed++;\n            return;\n        }\n        \n        // At this point, the value wasn't found in the cache but the cache was full; need to evict least used and hand it off to disk before caching the new request\n        IoRequest evictedIoRequest = evict(0);\n        system.receiveIoRequestContinuingFromCache(evictedIoRequest);\n        addToCache(0, request, requestLatency);\n    }\n\t\n\tprivate void addToCache(int index, IoRequest request, int requestLatency) {\n\t    contents[index] = new CacheItem(request, timer.getTime());\n\t    Arrays.sort(contents, new CacheComparator());\n\n\t    long completionTime = timer.getTime() + requestLatency + writeLatency;\n        addInProgressCacheOperation(new CacheResponse(request, null, completionTime));\n\t}\n\t\n\tprivate void addInProgressCacheOperation(CacheResponse cr) {\n\t    Set<CacheResponse> existingResponsesForCompletionTime = operationsInProgress.get(cr.getCompletionTime());\n        if(existingResponsesForCompletionTime == null) {\n            Set<CacheResponse> newSet = new HashSet<CacheResponse>();\n            newSet.add(cr);\n            operationsInProgress.put(cr.getCompletionTime(), newSet);\n        } else {\n            existingResponsesForCompletionTime.add(cr);\n        }\n        operationsInProgressCount++;\n\t}\n\n    // FUTURE: might want to somehow track evictions later\n\tprivate IoRequest evict(int indexToEvict) {\n\t    IoRequest evictedIoRequest = contents[indexToEvict].getRequest();\n\t    \n\t    // Evictee may still be in progress; loop through in-progress ops to check, and if found, drop it\n        Set<Long> inProgressKeys = operationsInProgress.keySet();\n        outerLoop:\n        for(long key : inProgressKeys) {\n            Set<CacheResponse> crSet = operationsInProgress.get(key);\n            for(CacheResponse cr : crSet) {\n                if(evictedIoRequest.referencesSameMemory(cr.getRequest())) {\n                    crSet.remove(cr);\n                    operationsInProgressCount--;\n                    break outerLoop;\n                }\n            }\n        }\n\t    \n\t    contents[indexToEvict] = null;\n\t    \n\t    return evictedIoRequest;\n\t}\n\t\n\tpublic boolean isOperationsQueued() {\n\t    return operationsInProgressCount > 0;\n\t}\n\t\n\t// A null-friendly comparator to use with the cache\n\tclass CacheComparator implements Comparator<CacheItem> {\n        @Override\n        public int compare(CacheItem o1, CacheItem o2) {\n            if (o1 == null && o2 == null) {\n                return 0;\n            }\n            if (o1 == null) {\n                return -1;\n            }\n            if (o2 == null) {\n                return 1;\n            }\n            \n            return o1.compareTo(o2);\n        }\n    }\n}\n"},
{"Line": "=>23", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((role == null) || (role.isEmpty())) { return false; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/9707/buggy-version/src.main.java.team.balam.security.jwt.access.AccessRole.java", "BodyUseAPI": [], "Fixed commit": "1cd3e5f7cd92f95b8c52eb4f33d856db715af236", "Url": "https://api.github.com/repos/KNero/jwt-security", "Date": "2018-12-24T11:58:40Z", "Source Code Diff": "@@ -20,6 +20,10 @@ void allAccessible() {\n     }\n \n     boolean containsRole(String role) {\n+        if (role == null || role.isEmpty()) {\n+            return false;\n+        }\n+\n         return isAllAccessible || roles.contains(role);\n     }\n }", "Complete After Code": "package team.balam.security.jwt.access;\n\nimport lombok.ToString;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n@ToString\nclass AccessRole {\n    private boolean isAllAccessible;\n    private Set<String> roles = new HashSet<>();\n\n    AccessRole addRole(String role) {\n        roles.add(role);\n        return this;\n    }\n\n    void allAccessible() {\n        isAllAccessible = true;\n    }\n\n    boolean containsRole(String role) {\n        if (role == null || role.isEmpty()) {\n            return false;\n        }\n\n        return isAllAccessible || roles.contains(role);\n    }\n}\n"},
{"Line": "=>80", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["java.util.Map<team.balam.security.jwt.access.AccessTarget, team.balam.security.jwt.access.AccessRole>.get(team.balam.security.jwt.access.AccessTarget)"], "Type": "Insert", "BugDetectionTag": "[IfNull, IfRet, IfDep]", "Content": "=>if (accessRole == null) { throw new team.balam.security.jwt.access.AuthorizationException((\"not has access authorization. jwt is empty -> \" + accessTarget)); }else if (!(accessRole.containsRole(role))) { throw new team.balam.security.jwt.access.AuthorizationException((((\"not has access authorization. \" + role) + \" -> \") + accessTarget)); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/9707/buggy-version/src.main.java.team.balam.security.jwt.access.AccessController.java", "BodyUseAPI": ["team.balam.security.jwt.access.AccessRole.containsRole(java.lang.String)"], "Fixed commit": "1cd3e5f7cd92f95b8c52eb4f33d856db715af236", "Url": "https://api.github.com/repos/KNero/jwt-security", "Date": "2018-12-24T11:58:40Z", "Source Code Diff": "@@ -6,7 +6,6 @@\n import org.reflections.util.ConfigurationBuilder;\n import org.reflections.util.FilterBuilder;\n \n-import javax.accessibility.AccessibleRelation;\n import java.lang.reflect.Method;\n import java.util.*;\n \n@@ -78,7 +77,9 @@ public void checkAuthorization(AccessTarget accessTarget, String role) throws Au\n             if (accessTarget.containsPrefix(prefix)) {\n                 AccessRole accessRole = accessInfoRepository.get(accessTarget);\n \n-                if (accessRole == null || !accessRole.containsRole(role)) {\n+                if (accessRole == null) { // RestAccess \uac00 \uc5c6\ub2e4\uba74 admin \ub9cc \uc811\uadfc \uac00\ub2a5\n+                    throw new AuthorizationException(\"not has access authorization. jwt is empty -> \" + accessTarget);\n+                } else if (!accessRole.containsRole(role)) { // RestAccess \uc5d0 role \uc774 \uc815\ud574\uc838 \uc788\ub2e4\uba74 \ud544\ud130\ub9c1\ud55c\ub2e4.\n                     throw new AuthorizationException(\"not has access authorization. \" + role + \" -> \" + accessTarget);\n                 }\n             }", "Complete After Code": "package team.balam.security.jwt.access;\n\nimport org.reflections.Reflections;\nimport org.reflections.scanners.MethodAnnotationsScanner;\nimport org.reflections.util.ClasspathHelper;\nimport org.reflections.util.ConfigurationBuilder;\nimport org.reflections.util.FilterBuilder;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\npublic class AccessController {\n    private Map<AccessTarget, AccessRole> accessInfoRepository = new HashMap<>();\n    private Set<String> adminRole = new HashSet<>();\n    private List<String> prefixList = new ArrayList<>();\n\n    public void addPrefix(String prefix) {\n        this.prefixList.add(prefix);\n    }\n\n    public void init(String... packages) throws AccessInfoExistsException {\n        for (String p : packages) {\n            Reflections reflections = new Reflections(new ConfigurationBuilder()\n                    .setUrls(ClasspathHelper.forPackage(p))\n                    .setScanners(new MethodAnnotationsScanner())\n                    .filterInputsBy(new FilterBuilder().includePackage(p)));\n\n            Set<Method> methodSet = reflections.getMethodsAnnotatedWith(PathAccess.class);\n            for (Method m : methodSet) {\n                PathAccess pathAccess = m.getAnnotation(PathAccess.class);\n                addNewAccessInfo(new AccessTarget(pathAccess.path()), pathAccess.all(), pathAccess.role());\n            }\n\n            methodSet = reflections.getMethodsAnnotatedWith(MethodAccess.class);\n            for (Method m: methodSet) {\n                MethodAccess methodAccess = m.getAnnotation(MethodAccess.class);\n                addNewAccessInfo(new AccessTarget(m.getDeclaringClass(), m.getName()), methodAccess.all(), methodAccess.role());\n            }\n\n            methodSet = reflections.getMethodsAnnotatedWith(RestAccess.class);\n            for (Method m: methodSet) {\n                RestAccess restAccess = m.getAnnotation(RestAccess.class);\n                addNewAccessInfo(new AccessTarget(restAccess.uri(), restAccess.method()), restAccess.all(), restAccess.role());\n            }\n        }\n    }\n\n    public void addAdminRole(String adminRole) {\n        this.adminRole.add(adminRole);\n    }\n\n    private void addNewAccessInfo(AccessTarget target, boolean isAllAccessible, String... roles) throws AccessInfoExistsException {\n        for (String role : roles) {\n            AccessRole accessRole = accessInfoRepository.get(target);\n\n            if (accessRole == null) {\n                accessRole = new AccessRole();\n                accessInfoRepository.put(target, accessRole);\n            }\n\n            if (isAllAccessible) {\n                accessRole.allAccessible();\n            } else if (!role.isEmpty() && !accessRole.containsRole(role)) {\n                accessRole.addRole(role);\n            } else if (accessRole.containsRole(role)) {\n                throw new AccessInfoExistsException(target.toString());\n            }\n        }\n    }\n\n    public void checkAuthorization(AccessTarget accessTarget, String role) throws AuthorizationException {\n        if (adminRole.contains(role)) {\n            return;\n        }\n\n        for (String prefix : prefixList) {\n            if (accessTarget.containsPrefix(prefix)) {\n                AccessRole accessRole = accessInfoRepository.get(accessTarget);\n\n                if (accessRole == null) { // RestAccess \uac00 \uc5c6\ub2e4\uba74 admin \ub9cc \uc811\uadfc \uac00\ub2a5\n                    throw new AuthorizationException(\"not has access authorization. jwt is empty -> \" + accessTarget);\n                } else if (!accessRole.containsRole(role)) { // RestAccess \uc5d0 role \uc774 \uc815\ud574\uc838 \uc788\ub2e4\uba74 \ud544\ud130\ub9c1\ud55c\ub2e4.\n                    throw new AuthorizationException(\"not has access authorization. \" + role + \" -> \" + accessTarget);\n                }\n            }\n        }\n\n        AccessRole accessRole = accessInfoRepository.get(accessTarget);\n        if (accessRole != null && !accessRole.containsRole(role)) {\n            throw new AuthorizationException(\"not has access authorization. \" + role + \" -> \" + accessTarget);\n        }\n    }\n}\n"},
{"Line": "=>58", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (isConnected) { if (!(kc.checkLicenseActivationState())) { android.util.Log.d(deviceadmin.harmann.com.adminapp.KnoxHandler.NetworkSchedulerService.TAG, \"Knox license is not Active. Send request to activate the license\"); kc.activateKnoxLicense(this); }else { android.util.Log.d(deviceadmin.harmann.com.adminapp.KnoxHandler.NetworkSchedulerService.TAG, \"Knox license is Active\"); if ((kc.checkUnrestrictedNetworkAccessToCBS()) == false) { kc.enableUnrestrictednetworkAccess(ApplicationConstants.KODIAK_PACKAGE_ID); } } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/205/buggy-version/app.src.main.java.deviceadmin.harmann.com.adminapp.KnoxHandler.NetworkSchedulerService.java", "BodyUseAPI": [], "Fixed commit": "104b8cbc3bbbba51b2b7b2b7b8f65d16ef232fc3", "Url": "https://api.github.com/repos/p711kumar/harmanapp", "Date": "2018-11-06T11:18:04Z"},
{"Line": "=>58", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((name) != null) return name.trim();", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/640/buggy-version/ccri-database.src.main.java.uk.nhs.careconnect.ri.database.entity.endpoint.EndpointEntity.java", "BodyUseAPI": [], "Fixed commit": "eb0555b025f36c4cb08d668d45b288d836060552", "Url": "https://api.github.com/repos/nhsconnect/careconnect-reference-implementation", "Date": "2018-11-01T11:36:22Z", "Source Code Diff": "@@ -55,7 +55,8 @@ public void setId(Long id) {\n \t}\n \n \tpublic String getName() {\n-\t\treturn name.trim();\n+\t\tif (name != null) return name.trim();\n+\t\treturn name;\n \t}\n \n \tpublic void setName(String name) {", "Complete After Code": "package uk.nhs.careconnect.ri.database.entity.endpoint;\n\nimport org.hl7.fhir.dstu3.model.Endpoint;\nimport uk.nhs.careconnect.ri.database.entity.BaseResource;\nimport uk.nhs.careconnect.ri.database.entity.Terminology.ConceptEntity;\nimport uk.nhs.careconnect.ri.database.entity.organization.OrganisationEntity;\n\nimport javax.persistence.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Entity\n@Table(name = \"EndPoint\",indexes =\n\t\t{\n\t\t\t\t@Index(name = \"IDX_ENDPOINT_NAME\", columnList=\"ENDPOINT_NAME\")\n\n\t\t})\npublic class EndpointEntity extends BaseResource {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name=\"ENDPOINT_ID\")\n\tprivate Long id;\n\n    \n    @Column(name = \"ENDPOINT_NAME\")\n\tprivate String name;\n\n\t@OneToMany(mappedBy=\"endpointEntity\", targetEntity=EndpointIdentifier.class)\n\n\tprivate List<EndpointIdentifier> identifiers;\n\n\t@Column(name = \"STATUS\")\n\t@Enumerated(EnumType.ORDINAL)\n\tprivate Endpoint.EndpointStatus status;\n\n\t@ManyToOne(fetch = FetchType.LAZY)\n\t@JoinColumn(name=\"CONNECTION_TYPE_CONCEPT_ID\",foreignKey= @ForeignKey(name=\"FK_CONNECTION_TYPE_CONCEPT\"))\n\tprivate ConceptEntity connectionType;\n\n\t@ManyToOne(fetch = FetchType.LAZY)\n\t@JoinColumn(name=\"MANAGING_ORGANISATION_ID\",foreignKey= @ForeignKey(name=\"FK_ENDPOINT_ORGANISATION\"))\n\n\tprivate OrganisationEntity managingOrganisation;\n\n\t@Column(name = \"ADDRESS\")\n\tprivate String address;\n\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\tif (name != null) return name.trim();\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t// EndPoint IDENTIFIERS\n\n\tpublic void setIdentifiers(List<EndpointIdentifier> identifiers) {\n\t\tthis.identifiers = identifiers;\n\t}\n\tpublic List<EndpointIdentifier> getIdentifiers( ) {\n\t\tif (identifiers == null) {\n\t\t\tidentifiers = new ArrayList<EndpointIdentifier>();\n\t\t}\n\t\treturn this.identifiers;\n\t}\n\tpublic List<EndpointIdentifier> addIdentifier(EndpointIdentifier pi) {\n\t\tidentifiers.add(pi);\n\t\treturn identifiers; }\n\n\tpublic List<EndpointIdentifier> removeIdentifier(EndpointIdentifier identifier){\n\t\tidentifiers.remove(identifiers); return identifiers; }\n\n\t// EndPoint Address\n\n\t\n\tpublic OrganisationEntity getManagingOrganisation() {\n\t\treturn managingOrganisation;\n\t}\n\n\tpublic EndpointEntity setManagingOrganisation(OrganisationEntity managingOrganisation) {\n\t\tthis.managingOrganisation = managingOrganisation;\n\t\treturn this;\n\t}\n\n\tpublic Endpoint.EndpointStatus getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic EndpointEntity setStatus(Endpoint.EndpointStatus status) {\n\t\tthis.status = status;\n\t\treturn this;\n\t}\n\n\tpublic ConceptEntity getConnectionType() {\n\t\treturn connectionType;\n\t}\n\n\tpublic void setConnectionType(ConceptEntity connectionType) {\n\t\tthis.connectionType = connectionType;\n\t}\n\n\tpublic String getAddress() {\n\t\treturn address;\n\t}\n\n\tpublic EndpointEntity setAddress(String address) {\n\t\tthis.address = address;\n\t\treturn this;\n\t}\n}\n"},
{"Line": "=>93", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((segments.length) == 0) { return parser.parse(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/3030/buggy-version/src.main.java.com.alibaba.fastjson.JSONPath.java", "BodyUseAPI": [], "Fixed commit": "93f763e1ecdc591dda6cba6bed61c2573a9e69f9", "Url": "https://api.github.com/repos/VictorZeng/fastjson", "Date": "2018-11-29T11:55:54Z", "Source Code Diff": "@@ -90,6 +90,10 @@ public Object extract(DefaultJSONParser parser) {\n             return this.eval(root);\n         }\n \n+        if (segments.length == 0) {\n+            return parser.parse();\n+        }\n+\n         Context context = null;\n         for (int i = 0; i < segments.length; ++i) {\n             Segment segment = segments[i];", "Complete After Code": "package com.alibaba.fastjson;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.alibaba.fastjson.parser.*;\nimport com.alibaba.fastjson.parser.deserializer.FieldDeserializer;\nimport com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer;\nimport com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;\nimport com.alibaba.fastjson.serializer.FieldSerializer;\nimport com.alibaba.fastjson.serializer.JavaBeanSerializer;\nimport com.alibaba.fastjson.serializer.ObjectSerializer;\nimport com.alibaba.fastjson.serializer.SerializeConfig;\nimport com.alibaba.fastjson.util.IOUtils;\nimport com.alibaba.fastjson.util.TypeUtils;\n\n/**\n * @author wenshao[szujobs@hotmail.com]\n * @since 1.2.0\n */\npublic class JSONPath implements JSONAware {\n    private static ConcurrentMap<String, JSONPath> pathCache  = new ConcurrentHashMap<String, JSONPath>(128, 0.75f, 1);\n\n    private final String                           path;\n    private Segment[]                              segments;\n    private boolean                                hasRefSegment;\n\n    private SerializeConfig                        serializeConfig;\n    private ParserConfig                           parserConfig;\n\n    public JSONPath(String path){\n        this(path, SerializeConfig.getGlobalInstance(), ParserConfig.getGlobalInstance());\n    }\n\n    public JSONPath(String path, SerializeConfig serializeConfig, ParserConfig parserConfig){\n        if (path == null || path.length() == 0) {\n            throw new JSONPathException(\"json-path can not be null or empty\");\n        }\n\n        this.path = path;\n        this.serializeConfig = serializeConfig;\n        this.parserConfig = parserConfig;\n    }\n\n    protected void init() {\n        if (segments != null) {\n            return;\n        }\n\n        if (\"*\".equals(path)) {\n            this.segments = new Segment[] { WildCardSegment.instance };\n        } else {\n            JSONPathParser parser = new JSONPathParser(path);\n            this.segments = parser.explain();\n            this.hasRefSegment = parser.hasRefSegment;\n        }\n    }\n\n    public Object eval(Object rootObject) {\n        if (rootObject == null) {\n            return null;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        for (int i = 0; i < segments.length; ++i) {\n            Segment segment = segments[i];\n            currentObject = segment.eval(this, rootObject, currentObject);\n        }\n        return currentObject;\n    }\n\n    public Object extract(DefaultJSONParser parser) {\n        if (parser == null) {\n            return null;\n        }\n\n        init();\n\n        if (hasRefSegment) {\n            Object root = parser.parse();\n            return this.eval(root);\n        }\n\n        if (segments.length == 0) {\n            return parser.parse();\n        }\n\n        Context context = null;\n        for (int i = 0; i < segments.length; ++i) {\n            Segment segment = segments[i];\n            boolean last = i == segments.length - 1;\n\n            if (context != null && context.object != null) {\n                return segment.eval(this, null, context.object);\n            }\n\n            boolean eval;\n\n            if (!last) {\n                Segment nextSegment = segments[i + 1];\n                if (segment instanceof PropertySegment\n                        && ((PropertySegment) segment).deep\n                        && (nextSegment instanceof ArrayAccessSegment\n                            || nextSegment instanceof MultiIndexSegment\n                            || nextSegment instanceof MultiPropertySegment\n                            || nextSegment instanceof SizeSegment\n                            || nextSegment instanceof PropertySegment\n                            || nextSegment instanceof FilterSegment))\n                {\n                    eval = true;\n                } else if (nextSegment instanceof ArrayAccessSegment\n                        && ((ArrayAccessSegment) nextSegment).index < 0) {\n                    eval = true;\n                } else if (nextSegment instanceof FilterSegment) {\n                    eval = true;\n                } else {\n                    eval = false;\n                }\n            } else {\n                eval = true;\n            }\n\n            context = new Context(context, eval);\n            segment.extract(this, parser, context);\n        }\n\n        return context.object;\n    }\n\n    private static class Context {\n        final Context parent;\n        final boolean eval;\n        Object object;\n\n        public Context(Context parent, boolean eval) {\n            this.parent = parent;\n            this.eval = eval;\n        }\n    }\n\n    public boolean contains(Object rootObject) {\n        if (rootObject == null) {\n            return false;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        for (int i = 0; i < segments.length; ++i) {\n            Object parentObject = currentObject;\n            currentObject = segments[i].eval(this, rootObject, currentObject);\n            if (currentObject == null) {\n                return false;\n            }\n\n            if (currentObject == Collections.EMPTY_LIST && parentObject instanceof List) {\n                return ((List) parentObject).contains(currentObject);\n            }\n        }\n\n        return true;\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    public boolean containsValue(Object rootObject, Object value) {\n        Object currentObject = eval(rootObject);\n\n        if (currentObject == value) {\n            return true;\n        }\n\n        if (currentObject == null) {\n            return false;\n        }\n\n        if (currentObject instanceof Iterable) {\n            Iterator it = ((Iterable) currentObject).iterator();\n            while (it.hasNext()) {\n                Object item = it.next();\n                if (eq(item, value)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        return eq(currentObject, value);\n    }\n\n    public int size(Object rootObject) {\n        if (rootObject == null) {\n            return -1;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        for (int i = 0; i < segments.length; ++i) {\n            currentObject = segments[i].eval(this, rootObject, currentObject);\n        }\n\n        return evalSize(currentObject);\n    }\n\n    /**\n     * Extract keySet or field names from rootObject on this JSONPath.\n     * \n     * @param rootObject Can be a map or custom object. Array and Collection are not supported.\n     * @return Set of keys, or <code>null</code> if not supported.\n     */\n    public Set<?> keySet(Object rootObject) {\n        if (rootObject == null) {\n            return null;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        for (int i = 0; i < segments.length; ++i) {\n            currentObject = segments[i].eval(this, rootObject, currentObject);\n        }\n\n        return evalKeySet(currentObject);\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public void arrayAdd(Object rootObject, Object... values) {\n        if (values == null || values.length == 0) {\n            return;\n        }\n\n        if (rootObject == null) {\n            return;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        Object parentObject = null;\n        for (int i = 0; i < segments.length; ++i) {\n            if (i == segments.length - 1) {\n                parentObject = currentObject;\n            }\n            currentObject = segments[i].eval(this, rootObject, currentObject);\n        }\n\n        Object result = currentObject;\n\n        if (result == null) {\n            throw new JSONPathException(\"value not found in path \" + path);\n        }\n\n        if (result instanceof Collection) {\n            Collection collection = (Collection) result;\n            for (Object value : values) {\n                collection.add(value);\n            }\n            return;\n        }\n\n        Class<?> resultClass = result.getClass();\n\n        Object newResult;\n        if (resultClass.isArray()) {\n            int length = Array.getLength(result);\n            Object descArray = Array.newInstance(resultClass.getComponentType(), length + values.length);\n\n            System.arraycopy(result, 0, descArray, 0, length);\n            for (int i = 0; i < values.length; ++i) {\n                Array.set(descArray, length + i, values[i]);\n\n            }\n            newResult = descArray;\n        } else {\n            throw new JSONException(\"unsupported array put operation. \" + resultClass);\n        }\n\n        Segment lastSegment = segments[segments.length - 1];\n        if (lastSegment instanceof PropertySegment) {\n            PropertySegment propertySegment = (PropertySegment) lastSegment;\n            propertySegment.setValue(this, parentObject, newResult);\n            return;\n        }\n\n        if (lastSegment instanceof ArrayAccessSegment) {\n            ((ArrayAccessSegment) lastSegment).setValue(this, parentObject, newResult);\n            return;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n    \n    public boolean remove(Object rootObject) {\n        if (rootObject == null) {\n            return false;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        Object parentObject = null;\n        for (int i = 0; i < segments.length; ++i) {\n            if (i == segments.length - 1) {\n                parentObject = currentObject;\n                break;\n            }\n            currentObject = segments[i].eval(this, rootObject, currentObject);\n            if (currentObject == null) {\n                break;\n            }\n        }\n\n        if (parentObject == null) {\n            return false;\n        }\n\n        Segment lastSegment = segments[segments.length - 1];\n        if (lastSegment instanceof PropertySegment) {\n            PropertySegment propertySegment = (PropertySegment) lastSegment;\n\n            if (parentObject instanceof Collection) {\n                if (segments.length > 1) {\n                    Segment parentSegment = segments[segments.length - 2];\n                    if (parentSegment instanceof RangeSegment || parentSegment instanceof MultiIndexSegment) {\n                        Collection collection = (Collection) parentObject;\n                        boolean removedOnce = false;\n                        for (Object item : collection) {\n                            boolean removed = propertySegment.remove(this, item);\n                            if (removed) {\n                                removedOnce = true;\n                            }\n                        }\n                        return removedOnce;\n                    }\n                }\n            }\n            return propertySegment.remove(this, parentObject);\n        }\n\n        if (lastSegment instanceof ArrayAccessSegment) {\n            return ((ArrayAccessSegment) lastSegment).remove(this, parentObject);\n        }\n\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean set(Object rootObject, Object value) {\n        return set(rootObject, value, true);\n    }\n\n    public boolean set(Object rootObject, Object value, boolean p) {\n        if (rootObject == null) {\n            return false;\n        }\n\n        init();\n\n        Object currentObject = rootObject;\n        Object parentObject = null;\n        for (int i = 0; i < segments.length; ++i) {\n//            if (i == segments.length - 1) {\n//                parentObject = currentObject;\n//                break;\n//            }\n//            \n            parentObject = currentObject;\n            Segment segment = segments[i];\n            currentObject = segment.eval(this, rootObject, currentObject);\n            if (currentObject == null) {\n                Segment nextSegment = null;\n                if (i < segments.length - 1) {\n                    nextSegment = segments[i + 1];\n                }\n\n                Object newObj = null;\n                if (nextSegment instanceof PropertySegment) {\n                    JavaBeanDeserializer beanDeserializer = null;\n                    Class<?> fieldClass = null;\n                    if (segment instanceof PropertySegment) {\n                        String propertyName = ((PropertySegment) segment).propertyName;\n                        Class<?> parentClass = parentObject.getClass();\n                        JavaBeanDeserializer parentBeanDeserializer = getJavaBeanDeserializer(parentClass);\n                        if (parentBeanDeserializer != null) {\n                            FieldDeserializer fieldDeserializer = parentBeanDeserializer.getFieldDeserializer(propertyName);\n                            fieldClass = fieldDeserializer.fieldInfo.fieldClass;\n                            beanDeserializer = getJavaBeanDeserializer(fieldClass);\n                        }\n                    }\n\n                    if (beanDeserializer != null) {\n\n                        if (beanDeserializer.beanInfo.defaultConstructor != null) {\n                            newObj = beanDeserializer.createInstance(null, fieldClass);\n                        } else {\n                            return false;\n                        }\n                    } else {\n                        newObj = new JSONObject();\n                    }\n                } else if (nextSegment instanceof ArrayAccessSegment) {\n                    newObj = new JSONArray();\n                }\n                \n                if (newObj != null) {\n                    if (segment instanceof PropertySegment) {\n                        PropertySegment propSegement = (PropertySegment) segment;\n                        propSegement.setValue(this, parentObject, newObj);\n                        currentObject = newObj;\n                        continue;\n                    } else if (segment instanceof ArrayAccessSegment) {\n                        ArrayAccessSegment arrayAccessSegement = (ArrayAccessSegment) segment;\n                        arrayAccessSegement.setValue(this, parentObject, newObj);\n                        currentObject = newObj;\n                        continue;\n                    }\n                }\n                \n                break;\n            }\n        }\n\n        if (parentObject == null) {\n            return false;\n        }\n\n        Segment lastSegment = segments[segments.length - 1];\n        if (lastSegment instanceof PropertySegment) {\n            PropertySegment propertySegment = (PropertySegment) lastSegment;\n            propertySegment.setValue(this, parentObject, value);\n            return true;\n        }\n\n        if (lastSegment instanceof ArrayAccessSegment) {\n            return ((ArrayAccessSegment) lastSegment).setValue(this, parentObject, value);\n        }\n\n        throw new UnsupportedOperationException();\n    }\n\n    public static Object eval(Object rootObject, String path) {\n        JSONPath jsonpath = compile(path);\n        return jsonpath.eval(rootObject);\n    }\n\n    public static int size(Object rootObject, String path) {\n        JSONPath jsonpath = compile(path);\n        Object result = jsonpath.eval(rootObject);\n        return jsonpath.evalSize(result);\n    }\n\n    /**\n     * Compile jsonPath and use it to extract keySet or field names from rootObject.\n     * \n     * @param rootObject Can be a map or custom object. Array and Collection are not supported.\n     * @param path JSONPath string to be compiled.\n     * @return Set of keys, or <code>null</code> if not supported.\n     */\n    public static Set<?> keySet(Object rootObject, String path) {\n        JSONPath jsonpath = compile(path);\n        Object result = jsonpath.eval(rootObject);\n        return jsonpath.evalKeySet(result);\n    }\n\n    public static boolean contains(Object rootObject, String path) {\n        if (rootObject == null) {\n            return false;\n        }\n\n        JSONPath jsonpath = compile(path);\n        return jsonpath.contains(rootObject);\n    }\n\n    public static boolean containsValue(Object rootObject, String path, Object value) {\n        JSONPath jsonpath = compile(path);\n        return jsonpath.containsValue(rootObject, value);\n    }\n\n    public static void arrayAdd(Object rootObject, String path, Object... values) {\n        JSONPath jsonpath = compile(path);\n        jsonpath.arrayAdd(rootObject, values);\n    }\n\n    public static boolean set(Object rootObject, String path, Object value) {\n        JSONPath jsonpath = compile(path);\n        return jsonpath.set(rootObject, value);\n    }\n    \n    public static boolean remove(Object root, String path) {\n        JSONPath jsonpath = compile(path);\n        return jsonpath.remove(root);\n    }\n\n    public static JSONPath compile(String path) {\n        if (path == null) {\n            throw new JSONPathException(\"jsonpath can not be null\");\n        }\n        \n        JSONPath jsonpath = pathCache.get(path);\n        if (jsonpath == null) {\n            jsonpath = new JSONPath(path);\n            if (pathCache.size() < 1024) {\n                pathCache.putIfAbsent(path, jsonpath);\n                jsonpath = pathCache.get(path);\n            }\n        }\n        return jsonpath;\n    }\n\n    /**\n     * @since 1.2.9\n     * @param json\n     * @param path\n     * @return\n     */\n    public static Object read(String json, String path) {\n        return compile(path)\n                .eval(\n                        JSON.parse(json)\n                );\n    }\n\n    /**\n     * @since 1.2.51\n     * @param json\n     * @param path\n     * @return\n     */\n    public static Object extract(String json, String path, ParserConfig config, int features, Feature... optionFeatures) {\n        features |= Feature.OrderedField.mask;\n        DefaultJSONParser parser = new DefaultJSONParser(json, config, features);\n        JSONPath jsonPath = compile(path);\n        Object result = jsonPath.extract(parser);\n        parser.lexer.close();\n        return result;\n    }\n\n    public static Object extract(String json, String path) {\n        return extract(json, path, ParserConfig.global, JSON.DEFAULT_PARSER_FEATURE);\n    }\n\n    public static Map<String, Object> paths(Object javaObject) {\n        return paths(javaObject, SerializeConfig.globalInstance);\n    }\n    \n    public static Map<String, Object> paths(Object javaObject, SerializeConfig config) {\n        Map<Object, String> values = new IdentityHashMap<Object, String>();\n        Map<String, Object> paths = new HashMap<String, Object>();\n\n        paths(values, paths, \"/\", javaObject, config);\n        return paths;\n    }\n\n    private static void paths(Map<Object, String> values, Map<String, Object> paths, String parent, Object javaObject, SerializeConfig config) {\n        if (javaObject == null) {\n            return;\n        }\n\n        String p = values.put(javaObject, parent);\n        if (p != null) {\n            boolean basicType =  javaObject instanceof String\n                    || javaObject instanceof Number\n                    || javaObject instanceof Date\n                    || javaObject instanceof UUID;\n\n            if (!basicType) {\n                return;\n            }\n        }\n\n        paths.put(parent, javaObject);\n\n        if (javaObject instanceof Map) {\n            Map map = (Map) javaObject;\n\n            for (Object entryObj : map.entrySet()) {\n                Map.Entry entry = (Map.Entry) entryObj;\n                Object key = entry.getKey();\n\n                if (key instanceof String) {\n                    String path = parent.equals(\"/\") ?  \"/\" + key : parent + \"/\" + key;\n                    paths(values, paths, path, entry.getValue(), config);\n                }\n            }\n            return;\n        }\n\n        if (javaObject instanceof Collection) {\n            Collection collection = (Collection) javaObject;\n\n            int i = 0;\n            for (Object item : collection) {\n                String path = parent.equals(\"/\") ?  \"/\" + i : parent + \"/\" + i;\n                paths(values, paths, path, item, config);\n                ++i;\n            }\n\n            return;\n        }\n\n        Class<?> clazz = javaObject.getClass();\n\n        if (clazz.isArray()) {\n            int len = Array.getLength(javaObject);\n\n            for (int i = 0; i < len; ++i) {\n                Object item = Array.get(javaObject, i);\n\n                String path = parent.equals(\"/\") ?  \"/\" + i : parent + \"/\" + i;\n                paths(values, paths, path, item, config);\n            }\n\n            return;\n        }\n\n        if (ParserConfig.isPrimitive2(clazz) || clazz.isEnum()) {\n            return;\n        }\n\n        ObjectSerializer serializer = config.getObjectWriter(clazz);\n        if (serializer instanceof JavaBeanSerializer) {\n            JavaBeanSerializer javaBeanSerializer = (JavaBeanSerializer) serializer;\n\n            try {\n                Map<String, Object> fieldValues = javaBeanSerializer.getFieldValuesMap(javaObject);\n                for (Map.Entry<String, Object> entry : fieldValues.entrySet()) {\n                    String key = entry.getKey();\n\n                    if (key instanceof String) {\n                        String path = parent.equals(\"/\") ?  \"/\" + key : parent + \"/\" + key;\n                        paths(values, paths, path, entry.getValue(), config);\n                    }\n                }\n            } catch (Exception e) {\n                throw new JSONException(\"toJSON error\", e);\n            }\n            return;\n        }\n\n        return;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    static class JSONPathParser {\n\n        private final String path;\n        private int          pos;\n        private char         ch;\n        private int          level;\n        private boolean      hasRefSegment;\n\n        public JSONPathParser(String path){\n            this.path = path;\n            next();\n        }\n\n        void next() {\n            ch = path.charAt(pos++);\n        }\n\n        char getNextChar() {\n            return path.charAt(pos);\n        }\n\n        boolean isEOF() {\n            return pos >= path.length();\n        }\n\n        Segment readSegement() {\n            if (level == 0 && path.length() == 1) {\n                if (isDigitFirst(ch)) {\n                    int index = ch - '0';\n                    return new ArrayAccessSegment(index);\n                } else if ((ch >= 'a' && ch <= 'z') || ((ch >= 'A' && ch <= 'Z'))) {\n                    return new PropertySegment(Character.toString(ch), false);\n                }\n            }\n            while (!isEOF()) {\n                skipWhitespace();\n\n                if (ch == '$') {\n                    next();\n                    continue;\n                }\n\n                if (ch == '.' || ch == '/') {\n                    int c0 = ch;\n                    boolean deep = false;\n                    next();\n                    if (c0 == '.' && ch == '.') {\n                        next();\n                        deep = true;\n                        if (path.length() > pos + 3\n                                && ch == '['\n                                && path.charAt(pos) == '*'\n                                && path.charAt(pos + 1) == ']'\n                                && path.charAt(pos + 2) == '.') {\n                            next();\n                            next();\n                            next();\n                            next();\n                        }\n                    }\n                    if (ch == '*') {\n                        if (!isEOF()) {\n                            next();\n                        }\n\n                        return deep ? WildCardSegment.instance_deep : WildCardSegment.instance;\n                    }\n                    \n                    if (isDigitFirst(ch)) {\n                        return parseArrayAccess(false);\n                    }\n\n                    String propertyName = readName();\n                    if (ch == '(') {\n                        next();\n                        if (ch == ')') {\n                            if (!isEOF()) {\n                                next();\n                            }\n\n                            if (\"size\".equals(propertyName) || \"length\".equals(propertyName)) {\n                                return SizeSegment.instance;\n                            } else if (\"max\".equals(propertyName)) {\n                                return MaxSegment.instance;\n                            } else if (\"min\".equals(propertyName)) {\n                                return MinSegment.instance;\n                            } else if (\"keySet\".equals(propertyName)) {\n                                return KeySetSegment.instance;\n                            }\n\n                            throw new JSONPathException(\"not support jsonpath : \" + path);\n                        }\n\n                        throw new JSONPathException(\"not support jsonpath : \" + path);\n                    }\n\n                    return new PropertySegment(propertyName, deep);\n                }\n\n                if (ch == '[') {\n                    return parseArrayAccess(true);\n                }\n\n                if (level == 0) {\n                    String propertyName = readName();\n\n                    return new PropertySegment(propertyName, false);\n                }\n\n                throw new JSONPathException(\"not support jsonpath : \" + path);\n            }\n\n            return null;\n        }\n\n        public final void skipWhitespace() {\n            for (;;) {\n                if (ch <= ' ' && (ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '\\f' || ch == '\\b')) {\n                    next();\n                    continue;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        Segment parseArrayAccess(boolean acceptBracket) {\n            Object object = parseArrayAccessFilter(acceptBracket);\n            if (object instanceof Segment) {\n                return ((Segment) object);\n            }\n            return new FilterSegment((Filter) object);\n        }\n\n        Object parseArrayAccessFilter(boolean acceptBracket) {\n            if (acceptBracket) {\n                accept('[');\n            }\n\n            boolean predicateFlag = false;\n\n            if (ch == '?') {\n                next();\n                accept('(');\n                predicateFlag = true;\n            }\n\n            if (predicateFlag || IOUtils.firstIdentifier(ch) || ch == '\\\\' || ch == '@') {\n                boolean self = false;\n                if (ch == '@') {\n                    next();\n                    accept('.');\n                    self = true;\n                }\n                String propertyName = readName();\n\n                skipWhitespace();\n\n                if (predicateFlag && ch == ')') {\n                    next();\n\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                if (acceptBracket && ch == ']') {\n                    next();\n                    Filter filter = new NotNullSegement(propertyName);\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    accept(')');\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n                    return filter;\n                }\n\n                Operator op = readOp();\n\n                skipWhitespace();\n\n                if (op == Operator.BETWEEN || op == Operator.NOT_BETWEEN) {\n                    final boolean not = (op == Operator.NOT_BETWEEN);\n\n                    Object startValue = readValue();\n\n                    String name = readName();\n\n                    if (!\"and\".equalsIgnoreCase(name)) {\n                        throw new JSONPathException(path);\n                    }\n\n                    Object endValue = readValue();\n\n                    if (startValue == null || endValue == null) {\n                        throw new JSONPathException(path);\n                    }\n\n                    if (isInt(startValue.getClass()) && isInt(endValue.getClass())) {\n                        Filter filter = new IntBetweenSegement(propertyName\n                                , TypeUtils.longExtractValue((Number) startValue)\n                                , TypeUtils.longExtractValue((Number) endValue)\n                                , not);\n                        return filter;\n                    }\n\n                    throw new JSONPathException(path);\n                }\n\n                if (op == Operator.IN || op == Operator.NOT_IN) {\n                    final boolean not = (op == Operator.NOT_IN);\n                    accept('(');\n\n                    List<Object> valueList = new JSONArray();\n                    {\n                        Object value = readValue();\n                        valueList.add(value);\n\n                        for (;;) {\n                            skipWhitespace();\n                            if (ch != ',') {\n                                break;\n                            }\n                            next();\n\n                            value = readValue();\n                            valueList.add(value);\n                        }\n                    }\n\n                    boolean isInt = true;\n                    boolean isIntObj = true;\n                    boolean isString = true;\n                    for (Object item : valueList) {\n                        if (item == null) {\n                            if (isInt) {\n                                isInt = false;\n                            }\n                            continue;\n                        }\n\n                        Class<?> clazz = item.getClass();\n                        if (isInt && !(clazz == Byte.class || clazz == Short.class || clazz == Integer.class\n                                       || clazz == Long.class)) {\n                            isInt = false;\n                            isIntObj = false;\n                        }\n\n                        if (isString && clazz != String.class) {\n                            isString = false;\n                        }\n                    }\n\n                    if (valueList.size() == 1 && valueList.get(0) == null) {\n                        Filter filter;\n                        if (not) {\n                            filter = new NotNullSegement(propertyName);\n                        } else {\n                            filter = new NullSegement(propertyName);\n                        }\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isInt) {\n                        if (valueList.size() == 1) {\n                            long value = TypeUtils.longExtractValue((Number) valueList.get(0));\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new IntOpSegement(propertyName, value, intOp);\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        long[] values = new long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            values[i] = TypeUtils.longExtractValue((Number) valueList.get(i));\n                        }\n\n                        Filter filter = new IntInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isString) {\n                        if (valueList.size() == 1) {\n                            String value = (String) valueList.get(0);\n\n                            Operator intOp = not ? Operator.NE : Operator.EQ;\n                            Filter filter = new StringOpSegement(propertyName, value, intOp);\n\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n\n                            accept(')');\n                            if (predicateFlag) {\n                                accept(')');\n                            }\n\n                            if (acceptBracket) {\n                                accept(']');\n                            }\n\n                            return filter;\n                        }\n\n                        String[] values = new String[valueList.size()];\n                        valueList.toArray(values);\n\n                        Filter filter = new StringInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    if (isIntObj) {\n                        Long[] values = new Long[valueList.size()];\n                        for (int i = 0; i < values.length; ++i) {\n                            Number item = (Number) valueList.get(i);\n                            if (item != null) {\n                                values[i] = TypeUtils.longExtractValue(item);\n                            }\n                        }\n\n                        Filter filter = new IntObjInSegement(propertyName, values, not);\n\n                        while (ch == ' ') {\n                            next();\n                        }\n\n                        if (ch == '&' || ch == '|') {\n                            filter = filterRest(filter);\n                        }\n\n                        accept(')');\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n\n                        if (acceptBracket) {\n                            accept(']');\n                        }\n\n                        return filter;\n                    }\n\n                    throw new UnsupportedOperationException();\n                }\n\n                if (ch == '\\'' || ch == '\"') {\n                    String strValue = readString();\n\n                    Filter filter = null;\n                    if (op == Operator.RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, false);\n                    } else if (op == Operator.NOT_RLIKE) {\n                        filter = new RlikeSegement(propertyName, strValue, true);\n                    } else  if (op == Operator.LIKE || op == Operator.NOT_LIKE) {\n                        while (strValue.indexOf(\"%%\") != -1) {\n                            strValue = strValue.replaceAll(\"%%\", \"%\");\n                        }\n\n                        final boolean not = (op == Operator.NOT_LIKE);\n\n                        int p0 = strValue.indexOf('%');\n                        if (p0 == -1) {\n                            if (op == Operator.LIKE) {\n                                op = Operator.EQ;\n                            } else {\n                                op = Operator.NE;\n                            }\n                            filter = new StringOpSegement(propertyName, strValue, op);\n                        } else {\n                            String[] items = strValue.split(\"%\");\n\n                            String startsWithValue = null;\n                            String endsWithValue = null;\n                            String[] containsValues = null;\n                            if (p0 == 0) {\n                                if (strValue.charAt(strValue.length() - 1) == '%') {\n                                    containsValues = new String[items.length - 1];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                } else {\n                                    endsWithValue = items[items.length - 1];\n                                    if (items.length > 2) {\n                                        containsValues = new String[items.length - 2];\n                                        System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                    }\n                                }\n                            } else if (strValue.charAt(strValue.length() - 1) == '%') {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else {\n                                    containsValues = items;\n                                }\n                            } else {\n                                if (items.length == 1) {\n                                    startsWithValue = items[0];\n                                } else if (items.length == 2) {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[1];\n                                } else {\n                                    startsWithValue = items[0];\n                                    endsWithValue = items[items.length - 1];\n                                    containsValues = new String[items.length - 2];\n                                    System.arraycopy(items, 1, containsValues, 0, containsValues.length);\n                                }\n                            }\n\n                            filter = new MatchSegement(propertyName, startsWithValue, endsWithValue,\n                                    containsValues, not);\n                        }\n                    } else {\n                        filter = new StringOpSegement(propertyName, strValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n                    \n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (isDigitFirst(ch)) {\n                    long value = readLongValue();\n                    double doubleValue = 0D;\n                    if (ch == '.') {\n                        doubleValue = readDoubleValue(value);\n                        \n                    }\n\n                    Filter filter;\n\n                    if (doubleValue == 0) {\n                        filter = new IntOpSegement(propertyName, value, op);\n                    } else {\n                        filter = new DoubleOpSegement(propertyName, doubleValue, op);\n                    }\n\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (ch == '&' || ch == '|') {\n                        filter = filterRest(filter);\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '$') {\n                    Segment segment = readSegement();\n                    RefOpSegement filter = new RefOpSegement(propertyName, segment, op);\n                    hasRefSegment = true;\n                    while (ch == ' ') {\n                        next();\n                    }\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                } else if (ch == '/') {\n                    int flags = 0;\n                    StringBuilder regBuf = new StringBuilder();\n                    for (;;) {\n                        next();\n                        if (ch == '/') {\n                            next();\n                            if (ch == 'i') {\n                                next();\n                                flags |= Pattern.CASE_INSENSITIVE;\n                            }\n                            break;\n                        }\n\n                        if (ch == '\\\\') {\n                            next();\n                            regBuf.append(ch);\n                        } else {\n                            regBuf.append(ch);\n                        }\n                    }\n\n                    Pattern pattern = Pattern.compile(regBuf.toString(), flags);\n                    RegMatchSegement filter = new RegMatchSegement(propertyName, pattern, op);\n\n                    if (predicateFlag) {\n                        accept(')');\n                    }\n\n                    if (acceptBracket) {\n                        accept(']');\n                    }\n\n                    return filter;\n                }\n\n                if (ch == 'n') {\n                    String name = readName();\n                    if (\"null\".equals(name)) {\n                        Filter filter = null;\n                        if (op == Operator.EQ) {\n                            filter = new NullSegement(propertyName);\n                        } else if (op == Operator.NE) {\n                            filter = new NotNullSegement(propertyName);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 't') {\n                    String name = readName();\n                    \n                    if (\"true\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.TRUE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (ch == 'f') {\n                    String name = readName();\n                    \n                    if (\"false\".equals(name)) {\n                        Filter filter = null;\n\n                        if (op == Operator.EQ) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, true);\n                        } else if (op == Operator.NE) {\n                            filter = new ValueSegment(propertyName, Boolean.FALSE, false);\n                        }\n\n                        if (filter != null) {\n                            while (ch == ' ') {\n                                next();\n                            }\n\n                            if (ch == '&' || ch == '|') {\n                                filter = filterRest(filter);\n                            }\n                        }\n\n                        if (predicateFlag) {\n                            accept(')');\n                        }\n                        accept(']');\n\n                        if (filter != null) {\n                            return filter;\n                        }\n\n                        throw new UnsupportedOperationException();\n                    }\n                }\n\n                throw new UnsupportedOperationException();\n                // accept(')');\n            }\n\n            int start = pos - 1;\n            while (ch != ']' && ch != '/' && !isEOF()) {\n                if (ch == '.' //\n                        && (!predicateFlag) // \n                        && !predicateFlag) {\n                    break;\n                }\n                \n                if (ch == '\\\\') {\n                    next();\n                }\n                next();\n            }\n            \n            int end;\n            if (acceptBracket) {\n                end = pos - 1;\n            } else {\n                if (ch == '/' || ch == '.') {\n                    end = pos - 1;\n                } else {\n                    end = pos;\n                }\n            }\n            \n            String text = path.substring(start, end);\n            \n            if (text.indexOf(\"\\\\.\") != -1) {\n                String propName = text.replaceAll(\"\\\\\\\\\\\\.\",\"\\\\.\");\n                if (propName.indexOf(\"\\\\-\") != -1) {\n                    propName = propName.replaceAll(\"\\\\\\\\-\",\"-\");\n                }\n\n                if (predicateFlag) {\n                    accept(')');\n                }\n                return new PropertySegment(propName, false);\n            }\n\n            Segment segment = buildArraySegement(text);\n\n            if (acceptBracket && !isEOF()) {\n                accept(']');\n            }\n\n            return segment;\n        }\n\n        Filter filterRest(Filter filter) {\n            boolean and = ch == '&';\n            if ((ch == '&' && getNextChar() == '&') || (ch == '|' && getNextChar() == '|')) {\n                next();\n                next();\n\n                while (ch == ' ') {\n                    next();\n                }\n\n                Filter right = (Filter) parseArrayAccessFilter(false);\n\n                filter = new FilterGroup(filter, right, and);\n            }\n            return filter;\n        }\n\n        protected long readLongValue() {\n            int beginIndex = pos - 1;\n            if (ch == '+' || ch == '-') {\n                next();\n            }\n\n            while (ch >= '0' && ch <= '9') {\n                next();\n            }\n\n            int endIndex = pos - 1;\n            String text = path.substring(beginIndex, endIndex);\n            long value = Long.parseLong(text);\n            return value;\n        }\n        \n        protected double readDoubleValue(long longValue) {\n            int beginIndex = pos - 1;\n\n            next();\n            while (ch >= '0' && ch <= '9') {\n                next();\n            }\n\n            int endIndex = pos - 1;\n            String text = path.substring(beginIndex, endIndex);\n            double value = Double.parseDouble(text);\n            value += longValue;\n            return value;\n        }\n\n        protected Object readValue() {\n            skipWhitespace();\n\n            if (isDigitFirst(ch)) {\n                return readLongValue();\n            }\n\n            if (ch == '\"' || ch == '\\'') {\n                return readString();\n            }\n\n            if (ch == 'n') {\n                String name = readName();\n\n                if (\"null\".equals(name)) {\n                    return null;\n                } else {\n                    throw new JSONPathException(path);\n                }\n            }\n\n            throw new UnsupportedOperationException();\n        }\n\n        static boolean isDigitFirst(char ch) {\n            return ch == '-' || ch == '+' || (ch >= '0' && ch <= '9');\n        }\n\n        protected Operator readOp() {\n            Operator op = null;\n            if (ch == '=') {\n                next();\n                if (ch == '~') {\n                    next();\n                    op = Operator.REG_MATCH;\n                } else if (ch == '=') {\n                    next();\n                    op = Operator.EQ;\n                } else {\n                    op = Operator.EQ;\n                }\n            } else if (ch == '!') {\n                next();\n                accept('=');\n                op = Operator.NE;\n            } else if (ch == '<') {\n                next();\n                if (ch == '=') {\n                    next();\n                    op = Operator.LE;\n                } else {\n                    op = Operator.LT;\n                }\n            } else if (ch == '>') {\n                next();\n                if (ch == '=') {\n                    next();\n                    op = Operator.GE;\n                } else {\n                    op = Operator.GT;\n                }\n            }\n\n            if (op == null) {\n                String name = readName();\n\n                if (\"not\".equalsIgnoreCase(name)) {\n                    skipWhitespace();\n\n                    name = readName();\n\n                    if (\"like\".equalsIgnoreCase(name)) {\n                        op = Operator.NOT_LIKE;\n                    } else if (\"rlike\".equalsIgnoreCase(name)) {\n                        op = Operator.NOT_RLIKE;\n                    } else if (\"in\".equalsIgnoreCase(name)) {\n                        op = Operator.NOT_IN;\n                    } else if (\"between\".equalsIgnoreCase(name)) {\n                        op = Operator.NOT_BETWEEN;\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                } else if (\"nin\".equalsIgnoreCase(name)) {\n                    op = Operator.NOT_IN;\n                } else {\n                    if (\"like\".equalsIgnoreCase(name)) {\n                        op = Operator.LIKE;\n                    } else if (\"rlike\".equalsIgnoreCase(name)) {\n                        op = Operator.RLIKE;\n                    } else if (\"in\".equalsIgnoreCase(name)) {\n                        op = Operator.IN;\n                    } else if (\"between\".equalsIgnoreCase(name)) {\n                        op = Operator.BETWEEN;\n                    } else {\n                        throw new UnsupportedOperationException();\n                    }\n                }\n            }\n            return op;\n        }\n\n        String readName() {\n            skipWhitespace();\n\n            if (ch != '\\\\' && !Character.isJavaIdentifierStart(ch)) {\n                throw new JSONPathException(\"illeal jsonpath syntax. \" + path);\n            }\n\n            StringBuilder buf = new StringBuilder();\n            while (!isEOF()) {\n                if (ch == '\\\\') {\n                    next();\n                    buf.append(ch);\n                    if (isEOF()) {\n                        return buf.toString();\n                    }\n                    next();\n                    continue;\n                }\n\n                boolean identifierFlag = Character.isJavaIdentifierPart(ch);\n                if (!identifierFlag) {\n                    break;\n                }\n                buf.append(ch);\n                next();\n            }\n\n            if (isEOF() && Character.isJavaIdentifierPart(ch)) {\n                buf.append(ch);\n            }\n\n            return buf.toString();\n        }\n\n        String readString() {\n            char quoate = ch;\n            next();\n\n            int beginIndex = pos - 1;\n            while (ch != quoate && !isEOF()) {\n                next();\n            }\n\n            String strValue = path.substring(beginIndex, isEOF() ? pos : pos - 1);\n\n            accept(quoate);\n\n            return strValue;\n        }\n\n        void accept(char expect) {\n            if (ch != expect) {\n                throw new JSONPathException(\"expect '\" + expect + \", but '\" + ch + \"'\");\n            }\n\n            if (!isEOF()) {\n                next();\n            }\n        }\n\n        public Segment[] explain() {\n            if (path == null || path.length() == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            Segment[] segments = new Segment[8];\n\n            for (;;) {\n                Segment segment = readSegement();\n                if (segment == null) {\n                    break;\n                }\n\n                if (segment instanceof PropertySegment) {\n                    PropertySegment propertySegment = (PropertySegment) segment;\n                    if ((!propertySegment.deep) && propertySegment.propertyName.equals(\"*\")) {\n                        continue;\n                    }\n                }\n\n                if (level == segments.length) {\n                    Segment[] t = new Segment[level * 3 / 2];\n                    System.arraycopy(segments, 0, t, 0, level);\n                    segments = t;\n                }\n                segments[level++] = segment;\n            }\n\n            if (level == segments.length) {\n                return segments;\n            }\n\n            Segment[] result = new Segment[level];\n            System.arraycopy(segments, 0, result, 0, level);\n            return result;\n        }\n\n        Segment buildArraySegement(String indexText) {\n            final int indexTextLen = indexText.length();\n            final char firstChar = indexText.charAt(0);\n            final char lastChar = indexText.charAt(indexTextLen - 1);\n\n            int commaIndex = indexText.indexOf(',');\n\n            if (indexText.length() > 2 && firstChar == '\\'' && lastChar == '\\'') {\n\n                if (commaIndex == -1) {\n                    String propertyName = indexText.substring(1, indexTextLen - 1);\n                    return new PropertySegment(propertyName, false);\n                }\n\n                String[] indexesText = indexText.split(\",\");\n                String[] propertyNames = new String[indexesText.length];\n                for (int i = 0; i < indexesText.length; ++i) {\n                    String indexesTextItem = indexesText[i];\n                    propertyNames[i] = indexesTextItem.substring(1, indexesTextItem.length() - 1);\n                }\n\n                return new MultiPropertySegment(propertyNames);\n            }\n\n            int colonIndex = indexText.indexOf(':');\n\n            if (commaIndex == -1 && colonIndex == -1) {\n                if (TypeUtils.isNumber(indexText)) {\n                    try {\n                        int index = Integer.parseInt(indexText);\n                        return new ArrayAccessSegment(index);\n                    }catch (NumberFormatException ex){\n                        return new PropertySegment(indexText, false); // fix ISSUE-1208\n                    }\n                } else {\n                    if (indexText.charAt(0) == '\"' && indexText.charAt(indexText.length() - 1) == '\"') {\n                        indexText = indexText.substring(1, indexText.length() - 1);\n                    }\n                    return new PropertySegment(indexText, false);\n                }\n            }\n\n            if (commaIndex != -1) {\n                String[] indexesText = indexText.split(\",\");\n                int[] indexes = new int[indexesText.length];\n                for (int i = 0; i < indexesText.length; ++i) {\n                    indexes[i] = Integer.parseInt(indexesText[i]);\n                }\n                return new MultiIndexSegment(indexes);\n            }\n\n            if (colonIndex != -1) {\n                String[] indexesText = indexText.split(\":\");\n                int[] indexes = new int[indexesText.length];\n                for (int i = 0; i < indexesText.length; ++i) {\n                    String str = indexesText[i];\n                    if (str.length() == 0) {\n                        if (i == 0) {\n                            indexes[i] = 0;\n                        } else {\n                            throw new UnsupportedOperationException();\n                        }\n                    } else {\n                        indexes[i] = Integer.parseInt(str);\n                    }\n                }\n\n                int start = indexes[0];\n                int end;\n                if (indexes.length > 1) {\n                    end = indexes[1];\n                } else {\n                    end = -1;\n                }\n                int step;\n                if (indexes.length == 3) {\n                    step = indexes[2];\n                } else {\n                    step = 1;\n                }\n\n                if (end >= 0 && end < start) {\n                    throw new UnsupportedOperationException(\"end must greater than or equals start. start \" + start\n                                                            + \",  end \" + end);\n                }\n\n                if (step <= 0) {\n                    throw new UnsupportedOperationException(\"step must greater than zero : \" + step);\n                }\n                return new RangeSegment(start, end, step);\n            }\n\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    interface Segment {\n\n        Object eval(JSONPath path, Object rootObject, Object currentObject);\n        void extract(JSONPath path, DefaultJSONParser parser, Context context);\n    }\n\n\n    static class SizeSegment implements Segment {\n\n        public final static SizeSegment instance = new SizeSegment();\n\n        public Integer eval(JSONPath path, Object rootObject, Object currentObject) {\n            return path.evalSize(currentObject);\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class MaxSegment implements Segment {\n\n        public final static MaxSegment instance = new MaxSegment();\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            Object max = null;\n            if (rootObject instanceof Collection) {\n                Iterator iterator = ((Collection) rootObject).iterator();\n                while (iterator.hasNext()) {\n                    Object next = iterator.next();\n                    if (next == null) {\n                        continue;\n                    }\n\n                    if (max == null) {\n                        max = next;\n                    } else if (compare(max, next) < 0) {\n                        max = next;\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            return max;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class MinSegment implements Segment {\n        public final static MinSegment instance = new MinSegment();\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            Object min = null;\n            if (rootObject instanceof Collection) {\n                Iterator iterator = ((Collection) rootObject).iterator();\n                while (iterator.hasNext()) {\n                    Object next = iterator.next();\n                    if (next == null) {\n                        continue;\n                    }\n\n                    if (min == null) {\n                        min = next;\n                    } else if (compare(min, next) > 0) {\n                        min = next;\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException();\n            }\n\n            return min;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static int compare(Object a, Object b) {\n        if (a.getClass() == b.getClass()) {\n            return ((Comparable) a).compareTo(b);\n        }\n\n        Class typeA = a.getClass();\n        Class typeB = b.getClass();\n\n        if (typeA == BigDecimal.class) {\n            if (typeB == Integer.class) {\n                b = new BigDecimal((Integer) b);\n            } else if (typeB == Long.class) {\n                b = new BigDecimal((Long) b);\n            } else if (typeB == Float.class) {\n                b = new BigDecimal((Float) b);\n            } else if (typeB == Double.class) {\n                b = new BigDecimal((Double) b);\n            }\n        } else if (typeA == Long.class) {\n            if (typeB == Integer.class) {\n                b = new Long((Integer) b);\n            } else if (typeB == BigDecimal.class) {\n                a = new BigDecimal((Long) a);\n            } else if (typeB == Float.class) {\n                a = new Float((Long) a);\n            } else if (typeB == Double.class) {\n                a = new Double((Long) a);\n            }\n        } else if (typeA == Integer.class) {\n            if (typeB == Long.class) {\n                a = new Long((Integer) a);\n            } else if (typeB == BigDecimal.class) {\n                a = new BigDecimal((Integer) a);\n            } else if (typeB == Float.class) {\n                a = new Float((Integer) a);\n            } else if (typeB == Double.class) {\n                a = new Double((Integer) a);\n            }\n        } else if (typeA == Double.class) {\n            if (typeB == Integer.class) {\n                b = new Double((Integer) b);\n            } else if (typeB == Long.class) {\n                b = new Double((Long) b);\n            } else if (typeB == Float.class) {\n                b = new Double((Float) b);\n            }\n        } else if (typeA == Float.class) {\n            if (typeB == Integer.class) {\n                b = new Float((Integer) b);\n            } else if (typeB == Long.class) {\n                b = new Float((Long) b);\n            } else if (typeB == Double.class) {\n                a = new Double((Float) a);\n            }\n        }\n\n        return ((Comparable) a).compareTo(b);\n    }\n\n    static class KeySetSegment implements Segment {\n\n        public final static KeySetSegment instance = new KeySetSegment();\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            return path.evalKeySet(currentObject);\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class PropertySegment implements Segment {\n\n        private final String  propertyName;\n        private final long    propertyNameHash;\n        private final boolean deep;\n\n        public PropertySegment(String propertyName, boolean deep){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.deep = deep;\n        }\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            if (deep) {\n                List<Object> results = new ArrayList<Object>();\n                path.deepScan(currentObject, propertyName, results);\n                return results;\n            } else {\n                // return path.getPropertyValue(currentObject, propertyName, true);\n                return path.getPropertyValue(currentObject, propertyName, propertyNameHash);\n            }\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;\n\n            if (deep && context.object == null) {\n                context.object = new JSONArray();\n            }\n\n            if (lexer.token() == JSONToken.LBRACKET) {\n                if (\"*\".equals(propertyName)) {\n                    return;\n                }\n\n                lexer.nextToken();\n                JSONArray array;\n\n                if (deep) {\n                    array =(JSONArray) context.object;\n                } else {\n                    array = new JSONArray();\n                }\n                for (;;) {\n                    switch (lexer.token()) {\n                        case JSONToken.LBRACE: {\n                            if (deep) {\n                                extract(path, parser, context);\n                                break;\n                            }\n                            int matchStat = lexer.seekObjectToField(propertyNameHash, deep);\n                            if (matchStat == JSONLexer.VALUE) {\n                                Object value;\n                                switch (lexer.token()) {\n                                    case JSONToken.LITERAL_INT:\n                                        value = lexer.integerValue();\n                                        lexer.nextToken();\n                                        break;\n                                    case JSONToken.LITERAL_STRING:\n                                        value = lexer.stringVal();\n                                        lexer.nextToken();\n                                        break;\n                                    default:\n                                        value = parser.parse();\n                                        break;\n                                }\n\n                                array.add(value);\n                                if (lexer.token() == JSONToken.RBRACE) {\n                                    lexer.nextToken();\n                                    continue;\n                                } else {\n                                    lexer.skipObject();\n                                }\n                            } else if (matchStat == JSONLexer.NOT_MATCH) {\n                                continue;\n                            } else {\n                                if (deep) {\n                                    throw new UnsupportedOperationException(lexer.info());\n                                } else {\n                                    lexer.skipObject();\n                                }\n                            }\n                            break;\n                        }\n                        case JSONToken.LBRACKET:\n                            if (deep) {\n                                extract(path, parser, context);\n                            } else {\n                                lexer.skipObject();\n                            }\n                            break;\n                        case JSONToken.LITERAL_STRING:\n                        case JSONToken.LITERAL_INT:\n                        case JSONToken.LITERAL_FLOAT:\n                        case JSONToken.LITERAL_ISO8601_DATE:\n                        case JSONToken.TRUE:\n                        case JSONToken.FALSE:\n                        case JSONToken.NULL:\n                            lexer.nextToken();\n                            break;\n                        default:\n                            break;\n                    }\n\n                    if (lexer.token() == JSONToken.RBRACKET) {\n                        lexer.nextToken();\n                        break;\n                    } else if (lexer.token() == JSONToken.COMMA) {\n                        lexer.nextToken();\n                        continue;\n                    } else {\n                        throw new JSONException(\"illegal json : \" + lexer.info());\n                    }\n                }\n\n                if (!deep) {\n                    if (array.size() > 0) {\n                        context.object = array;\n                    }\n                }\n                return;\n            }\n\n            if (!deep) {\n                int matchStat = lexer.seekObjectToField(propertyNameHash, deep);\n                if (matchStat == JSONLexer.VALUE) {\n                    if (context.eval) {\n                        Object value;\n                        switch (lexer.token()) {\n                            case JSONToken.LITERAL_INT:\n                                value = lexer.integerValue();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            case JSONToken.LITERAL_FLOAT:\n                                value = lexer.decimalValue();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            case JSONToken.LITERAL_STRING:\n                                value = lexer.stringVal();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            default:\n                                value = parser.parse();\n                                break;\n                        }\n\n                        if (context.eval) {\n                            context.object = value;\n                        }\n                    }\n                }\n                return;\n            }\n\n            // deep\n            for (;;) {\n                int matchStat = lexer.seekObjectToField(propertyNameHash, deep);\n                if (matchStat == JSONLexer.NOT_MATCH) {\n                    break;\n                }\n\n                if (matchStat == JSONLexer.VALUE) {\n                    if (context.eval) {\n                        Object value;\n                        switch (lexer.token()) {\n                            case JSONToken.LITERAL_INT:\n                                value = lexer.integerValue();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            case JSONToken.LITERAL_FLOAT:\n                                value = lexer.decimalValue();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            case JSONToken.LITERAL_STRING:\n                                value = lexer.stringVal();\n                                lexer.nextToken(JSONToken.COMMA);\n                                break;\n                            default:\n                                value = parser.parse();\n                                break;\n                        }\n\n                        if (context.eval) {\n                            if (context.object instanceof List) {\n                                List list = (List) context.object;\n                                if (list.size() == 0 && value instanceof List) {\n                                    context.object = value;\n                                } else {\n                                    list.add(value);\n                                }\n                            } else {\n                                context.object = value;\n                            }\n                        }\n                    }\n                } else if (matchStat == JSONLexer.OBJECT || matchStat == JSONLexer.ARRAY) {\n                    extract(path, parser, context);\n                }\n            }\n        }\n\n        public void setValue(JSONPath path, Object parent, Object value) {\n            if (deep) {\n                path.deepSet(parent, propertyName, propertyNameHash, value);\n            } else {\n                path.setPropertyValue(parent, propertyName, propertyNameHash, value);\n            }\n        }\n        \n        public boolean remove(JSONPath path, Object parent) {\n            return path.removePropertyValue(parent, propertyName);\n        }\n    }\n\n    static class MultiPropertySegment implements Segment {\n\n        private final String[] propertyNames;\n        private final long[]   propertyNamesHash;\n\n        public MultiPropertySegment(String[] propertyNames){\n            this.propertyNames = propertyNames;\n            this.propertyNamesHash = new long[propertyNames.length];\n            for (int i = 0; i < propertyNamesHash.length; i++) {\n                propertyNamesHash[i] = TypeUtils.fnv1a_64(propertyNames[i]);\n            }\n        }\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            List<Object> fieldValues = new ArrayList<Object>(propertyNames.length);\n\n            for (int i = 0; i < propertyNames.length; i++) {\n                Object fieldValue = path.getPropertyValue(currentObject, propertyNames[i], propertyNamesHash[i]);\n                fieldValues.add(fieldValue);\n            }\n\n            return fieldValues;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;\n\n            JSONArray array;\n            if (context.object == null) {\n                context.object = array = new JSONArray();\n            } else {\n                array = (JSONArray) context.object;\n            }\n            for (int i = array.size(); i < propertyNamesHash.length; ++i) {\n                array.add(null);\n            }\n\n//            if (lexer.token() == JSONToken.LBRACKET) {\n//                lexer.nextToken();\n//                JSONArray array;\n//\n//                array = new JSONArray();\n//                for (;;) {\n//                    if (lexer.token() == JSONToken.LBRACE) {\n//                        int index = lexer.seekObjectToField(propertyNamesHash);\n//                        int matchStat = lexer.matchStat;\n//                        if (matchStat == JSONLexer.VALUE) {\n//                            Object value;\n//                            switch (lexer.token()) {\n//                                case JSONToken.LITERAL_INT:\n//                                    value = lexer.integerValue();\n//                                    lexer.nextToken();\n//                                    break;\n//                                case JSONToken.LITERAL_STRING:\n//                                    value = lexer.stringVal();\n//                                    lexer.nextToken();\n//                                    break;\n//                                default:\n//                                    value = parser.parse();\n//                                    break;\n//                            }\n//\n//                            array.add(index, value);\n//                            if (lexer.token() == JSONToken.RBRACE) {\n//                                lexer.nextToken();\n//                                continue;\n//                            } else {\n//                                lexer.skipObject();\n//                            }\n//                        } else {\n//                            lexer.skipObject();\n//                        }\n//                    }\n//\n//                    if (lexer.token() == JSONToken.RBRACKET) {\n//                        break;\n//                    } else if (lexer.token() == JSONToken.COMMA) {\n//                        lexer.nextToken();\n//                        continue;\n//                    } else {\n//                        throw new JSONException(\"illegal json.\");\n//                    }\n//                }\n//\n//                context.object = array;\n//                return;\n//            }\n\n            for_:\n            for (;;) {\n                int index = lexer.seekObjectToField(propertyNamesHash);\n                int matchStat = lexer.matchStat;\n                if (matchStat == JSONLexer.VALUE) {\n                    Object value;\n                    switch (lexer.token()) {\n                        case JSONToken.LITERAL_INT:\n                            value = lexer.integerValue();\n                            lexer.nextToken(JSONToken.COMMA);\n                            break;\n                        case JSONToken.LITERAL_FLOAT:\n                            value = lexer.decimalValue();\n                            lexer.nextToken(JSONToken.COMMA);\n                            break;\n                        case JSONToken.LITERAL_STRING:\n                            value = lexer.stringVal();\n                            lexer.nextToken(JSONToken.COMMA);\n                            break;\n                        default:\n                            value = parser.parse();\n                            break;\n                    }\n\n                    array.set(index, value);\n\n                    if (lexer.token() == JSONToken.COMMA) {\n                        continue for_;\n                    }\n                }\n\n                break;\n            }\n        }\n    }\n\n    static class WildCardSegment implements Segment {\n        private boolean deep;\n\n        private WildCardSegment(boolean deep) {\n            this.deep = deep;\n        }\n\n        public final static WildCardSegment instance = new WildCardSegment(false);\n        public final static WildCardSegment instance_deep = new WildCardSegment(true);\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            if (!deep) {\n                return path.getPropertyValues(currentObject);\n            }\n\n            List<Object> values = new ArrayList<Object>();\n            path.deepGetPropertyValues(currentObject, values);\n            return values;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            if (context.eval) {\n                Object object = parser.parse();\n                if (deep) {\n                    List<Object> values = new ArrayList<Object>();\n                    path.deepGetPropertyValues(object, values);\n                    context.object = values;\n                    return;\n                }\n\n                if (object instanceof JSONObject) {\n                    Collection<Object> values = ((JSONObject) object).values();\n                    JSONArray array = new JSONArray(values.size());\n                    for (Object value : values) {\n                        array.add(value);\n                    }\n                    context.object = array;\n                    return;\n                } else if (object instanceof JSONArray) {\n                    context.object = object;\n                    return;\n                }\n            }\n\n            throw new JSONException(\"TODO\");\n        }\n    }\n\n    static class ArrayAccessSegment implements Segment {\n\n        private final int index;\n\n        public ArrayAccessSegment(int index){\n            this.index = index;\n        }\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            return path.getArrayItem(currentObject, index);\n        }\n\n        public boolean setValue(JSONPath path, Object currentObject, Object value) {\n            return path.setArrayItem(path, currentObject, index, value);\n        }\n        \n        public boolean remove(JSONPath path, Object currentObject) {\n            return path.removeArrayItem(path, currentObject, index);\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            JSONLexerBase lexer = (JSONLexerBase) parser.lexer;\n            if (lexer.seekArrayToItem(index)\n                    && context.eval)\n            {\n                context.object = parser.parse();\n            }\n        }\n    }\n\n    static class MultiIndexSegment implements Segment {\n\n        private final int[] indexes;\n\n        public MultiIndexSegment(int[] indexes){\n            this.indexes = indexes;\n        }\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            List<Object> items = new JSONArray(indexes.length);\n            for (int i = 0; i < indexes.length; ++i) {\n                Object item = path.getArrayItem(currentObject, indexes[i]);\n                items.add(item);\n            }\n            return items;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            if (context.eval) {\n                Object object = parser.parse();\n                if (object instanceof List) {\n                    int[] indexes = new int[this.indexes.length];\n                    System.arraycopy(this.indexes, 0, indexes, 0, indexes.length);\n                    boolean noneNegative = indexes[0] >= 0;\n\n                    List list = (List) object;\n                    if (noneNegative) {\n                        for (int i = list.size() - 1; i >= 0; i--) {\n                            if (Arrays.binarySearch(indexes, i) < 0) {\n                                list.remove(i);\n                            }\n                        }\n                        context.object = list;\n                        return;\n                    }\n                }\n            }\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class RangeSegment implements Segment {\n\n        private final int start;\n        private final int end;\n        private final int step;\n\n        public RangeSegment(int start, int end, int step){\n            this.start = start;\n            this.end = end;\n            this.step = step;\n        }\n\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            int size = SizeSegment.instance.eval(path, rootObject, currentObject);\n            int start = this.start >= 0 ? this.start : this.start + size;\n            int end = this.end >= 0 ? this.end : this.end + size;\n\n            int array_size = (end - start) / step + 1;\n            if (array_size == -1) {\n                return null;\n            }\n\n            List<Object> items = new ArrayList<Object>(array_size);\n            for (int i = start; i <= end && i < size; i += step) {\n                Object item = path.getArrayItem(currentObject, i);\n                items.add(item);\n            }\n            return items;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class NotNullSegement implements Filter {\n\n        private final String propertyName;\n        private final long   propertyNameHash;\n\n\n        public NotNullSegement(String propertyName){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            return propertyValue != null;\n        }\n    }\n\n    static class NullSegement implements Filter {\n\n        private final String propertyName;\n        private final long   propertyNameHash;\n\n        public NullSegement(String propertyName){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            return propertyValue == null;\n        }\n    }\n    \n    static class ValueSegment implements Filter {\n        private final String propertyName;\n        private final long   propertyNameHash;\n        private final Object value;\n        private boolean eq = true;\n        \n        public ValueSegment(String propertyName, Object value, boolean eq){\n            if (value == null) {\n                throw new IllegalArgumentException(\"value is null\");\n            }\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.value = value;\n            this.eq = eq;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n            boolean result = value.equals(propertyValue);\n            if (!eq) {\n                result = !result;\n            }\n            return result;\n        }\n    }\n\n    static class IntInSegement implements Filter {\n\n        private final String  propertyName;\n        private final long    propertyNameHash;\n        private final long[]  values;\n        private final boolean not;\n\n        public IntInSegement(String propertyName, long[] values, boolean not){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.values = values;\n            this.not = not;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            if (propertyValue instanceof Number) {\n                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);\n                for (long value : values) {\n                    if (value == longPropertyValue) {\n                        return !not;\n                    }\n                }\n            }\n\n            return not;\n        }\n    }\n\n    static class IntBetweenSegement implements Filter {\n\n        private final String  propertyName;\n        private final long    propertyNameHash;\n        private final long    startValue;\n        private final long    endValue;\n        private final boolean not;\n\n        public IntBetweenSegement(String propertyName, long startValue, long endValue, boolean not){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.startValue = startValue;\n            this.endValue = endValue;\n            this.not = not;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            if (propertyValue instanceof Number) {\n                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);\n                if (longPropertyValue >= startValue && longPropertyValue <= endValue) {\n                    return !not;\n                }\n            }\n\n            return not;\n        }\n    }\n\n    static class IntObjInSegement implements Filter {\n\n        private final String  propertyName;\n        private final long    propertyNameHash;\n        private final Long[]  values;\n        private final boolean not;\n\n        public IntObjInSegement(String propertyName, Long[] values, boolean not){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.values = values;\n            this.not = not;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                for (Long value : values) {\n                    if (value == null) {\n                        return !not;\n                    }\n                }\n\n                return not;\n            }\n\n            if (propertyValue instanceof Number) {\n                long longPropertyValue = TypeUtils.longExtractValue((Number) propertyValue);\n                for (Long value : values) {\n                    if (value == null) {\n                        continue;\n                    }\n\n                    if (value.longValue() == longPropertyValue) {\n                        return !not;\n                    }\n                }\n            }\n\n            return not;\n        }\n    }\n\n    static class StringInSegement implements Filter {\n\n        private final String   propertyName;\n        private final long     propertyNameHash;\n        private final String[] values;\n        private final boolean  not;\n\n        public StringInSegement(String propertyName, String[] values, boolean not){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.values = values;\n            this.not = not;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            for (String value : values) {\n                if (value == propertyValue) {\n                    return !not;\n                } else if (value != null && value.equals(propertyValue)) {\n                    return !not;\n                }\n            }\n\n            return not;\n        }\n    }\n\n    static class IntOpSegement implements Filter {\n\n        private final String   propertyName;\n        private final long     propertyNameHash;\n        private final long     value;\n        private final Operator op;\n\n        private BigDecimal     valueDecimal;\n        private Float          valueFloat;\n        private Double         valueDouble;\n\n        public IntOpSegement(String propertyName, long value, Operator op){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.value = value;\n            this.op = op;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            if (!(propertyValue instanceof Number)) {\n                return false;\n            }\n\n            if (propertyValue instanceof BigDecimal) {\n                if (valueDecimal == null) {\n                    valueDecimal = BigDecimal.valueOf(value);\n                }\n\n                int result = valueDecimal.compareTo((BigDecimal) propertyValue);\n                switch (op) {\n                    case EQ:\n                        return result == 0;\n                    case NE:\n                        return result != 0;\n                    case GE:\n                        return 0 >= result;\n                    case GT:\n                        return 0 > result;\n                    case LE:\n                        return 0 <= result;\n                    case LT:\n                        return 0 < result;\n                }\n\n                return false;\n            }\n\n            if (propertyValue instanceof Float) {\n                if (valueFloat == null) {\n                    valueFloat = Float.valueOf(value);\n                }\n\n                int result = valueFloat.compareTo((Float) propertyValue);\n                switch (op) {\n                    case EQ:\n                        return result == 0;\n                    case NE:\n                        return result != 0;\n                    case GE:\n                        return 0 >= result;\n                    case GT:\n                        return 0 > result;\n                    case LE:\n                        return 0 <= result;\n                    case LT:\n                        return 0 < result;\n                }\n\n                return false;\n            }\n\n            if (propertyValue instanceof Double) {\n                if (valueDouble == null) {\n                    valueDouble = Double.valueOf(value);\n                }\n\n                int result = valueDouble.compareTo((Double) propertyValue);\n                switch (op) {\n                    case EQ:\n                        return result == 0;\n                    case NE:\n                        return result != 0;\n                    case GE:\n                        return 0 >= result;\n                    case GT:\n                        return 0 > result;\n                    case LE:\n                        return 0 <= result;\n                    case LT:\n                        return 0 < result;\n                }\n\n                return false;\n            }\n\n            long longValue = TypeUtils.longExtractValue((Number) propertyValue);\n\n            switch (op) {\n                case EQ:\n                    return longValue == value;\n                case NE:\n                    return longValue != value;\n                case GE:\n                    return longValue >= value;\n                case GT:\n                    return longValue > value;\n                case LE:\n                    return longValue <= value;\n                case LT:\n                    return longValue < value;\n            }\n\n            return false;\n        }\n    }\n    \n    static class DoubleOpSegement implements Filter {\n        private final String   propertyName;\n        private final double   value;\n        private final Operator op;\n\n        private final long     propertyNameHash;\n\n        public DoubleOpSegement(String propertyName, double value, Operator op){\n            this.propertyName = propertyName;\n            this.value = value;\n            this.op = op;\n            propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            if (!(propertyValue instanceof Number)) {\n                return false;\n            }\n\n            double doubleValue = ((Number) propertyValue).doubleValue();\n\n            switch (op) {\n                case EQ:\n                    return doubleValue == value;\n                case NE:\n                    return doubleValue != value;\n                case GE:\n                    return doubleValue >= value;\n                case GT:\n                    return doubleValue > value;\n                case LE:\n                    return doubleValue <= value;\n                case LT:\n                    return doubleValue < value;\n            }\n\n            return false;\n        }\n    }\n\n    static class RefOpSegement implements Filter {\n        private final String    propertyName;\n        private final Segment  refSgement;\n        private final Operator  op;\n        private final long      propertyNameHash;\n\n        public RefOpSegement(String propertyName, Segment refSgement, Operator op){\n            this.propertyName = propertyName;\n            this.refSgement = refSgement;\n            this.op = op;\n            propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            if (!(propertyValue instanceof Number)) {\n                return false;\n            }\n\n            Object refValue = refSgement.eval(path, rootObject, rootObject);\n\n            if (refValue instanceof Integer || refValue instanceof Long || refValue instanceof Short || refValue instanceof Byte) {\n                long value = TypeUtils.longExtractValue((Number) refValue);\n\n                if (propertyValue instanceof Integer || propertyValue instanceof Long || propertyValue instanceof Short || propertyValue instanceof Byte) {\n                    long longValue = TypeUtils.longExtractValue((Number) propertyValue);\n\n                    switch (op) {\n                        case EQ:\n                            return longValue == value;\n                        case NE:\n                            return longValue != value;\n                        case GE:\n                            return longValue >= value;\n                        case GT:\n                            return longValue > value;\n                        case LE:\n                            return longValue <= value;\n                        case LT:\n                            return longValue < value;\n                    }\n                } else if (propertyValue instanceof BigDecimal) {\n                    BigDecimal valueDecimal = BigDecimal.valueOf(value);\n\n                    int result = valueDecimal.compareTo((BigDecimal) propertyValue);\n                    switch (op) {\n                        case EQ:\n                            return result == 0;\n                        case NE:\n                            return result != 0;\n                        case GE:\n                            return 0 >= result;\n                        case GT:\n                            return 0 > result;\n                        case LE:\n                            return 0 <= result;\n                        case LT:\n                            return 0 < result;\n                    }\n\n                    return false;\n                }\n            }\n\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    static class MatchSegement implements Filter {\n\n        private final String   propertyName;\n        private final long     propertyNameHash;\n        private final String   startsWithValue;\n        private final String   endsWithValue;\n        private final String[] containsValues;\n        private final int      minLength;\n        private final boolean  not;\n\n        public MatchSegement(\n                String propertyName,\n                String startsWithValue,\n                String endsWithValue,\n                String[] containsValues,\n                boolean not)\n        {\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.startsWithValue = startsWithValue;\n            this.endsWithValue = endsWithValue;\n            this.containsValues = containsValues;\n            this.not = not;\n\n            int len = 0;\n            if (startsWithValue != null) {\n                len += startsWithValue.length();\n            }\n\n            if (endsWithValue != null) {\n                len += endsWithValue.length();\n            }\n\n            if (containsValues != null) {\n                for (String item : containsValues) {\n                    len += item.length();\n                }\n            }\n\n            this.minLength = len;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            final String strPropertyValue = propertyValue.toString();\n\n            if (strPropertyValue.length() < minLength) {\n                return not;\n            }\n\n            int start = 0;\n            if (startsWithValue != null) {\n                if (!strPropertyValue.startsWith(startsWithValue)) {\n                    return not;\n                }\n                start += startsWithValue.length();\n            }\n\n            if (containsValues != null) {\n                for (String containsValue : containsValues) {\n                    int index = strPropertyValue.indexOf(containsValue, start);\n                    if (index == -1) {\n                        return not;\n                    }\n                    start = index + containsValue.length();\n                }\n            }\n\n            if (endsWithValue != null) {\n                if (!strPropertyValue.endsWith(endsWithValue)) {\n                    return not;\n                }\n            }\n\n            return !not;\n        }\n    }\n\n    static class RlikeSegement implements Filter {\n\n        private final String  propertyName;\n        private final long   propertyNameHash;\n        private final Pattern pattern;\n        private final boolean not;\n\n        public RlikeSegement(String propertyName, String pattern, boolean not){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.pattern = Pattern.compile(pattern);\n            this.not = not;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            String strPropertyValue = propertyValue.toString();\n            Matcher m = pattern.matcher(strPropertyValue);\n            boolean match = m.matches();\n\n            if (not) {\n                match = !match;\n            }\n\n            return match;\n        }\n    }\n\n    static class StringOpSegement implements Filter {\n\n        private final String   propertyName;\n        private final long     propertyNameHash;\n        private final String   value;\n        private final Operator op;\n\n        public StringOpSegement(String propertyName, String value, Operator op){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.value = value;\n            this.op = op;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n\n            if (op == Operator.EQ) {\n                return value.equals(propertyValue);\n            } else if (op == Operator.NE) {\n                return !value.equals(propertyValue);\n            }\n\n            if (propertyValue == null) {\n                return false;\n            }\n\n            int compareResult = value.compareTo(propertyValue.toString());\n            if (op == Operator.GE) {\n                return compareResult <= 0;\n            } else if (op == Operator.GT) {\n                return compareResult < 0;\n            } else if (op == Operator.LE) {\n                return compareResult >= 0;\n            } else if (op == Operator.LT) {\n                return compareResult > 0;\n            }\n\n            return false;\n        }\n    }\n\n    static class RegMatchSegement implements Filter {\n\n        private final String   propertyName;\n        private final long     propertyNameHash;\n        private final Pattern  pattern;\n        private final Operator op;\n\n        public RegMatchSegement(String propertyName, Pattern pattern, Operator op){\n            this.propertyName = propertyName;\n            this.propertyNameHash = TypeUtils.fnv1a_64(propertyName);\n            this.pattern = pattern;\n            this.op = op;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            Object propertyValue = path.getPropertyValue(item, propertyName, propertyNameHash);\n            if (propertyValue == null) {\n                return false;\n            }\n\n            String str = propertyValue.toString();\n\n            Matcher m = pattern.matcher(str);\n            return m.matches();\n        }\n    }\n\n    enum Operator {\n                   EQ, NE, GT, GE, LT, LE, LIKE, NOT_LIKE, RLIKE, NOT_RLIKE, IN, NOT_IN, BETWEEN, NOT_BETWEEN, And, Or, REG_MATCH\n    }\n\n    static public class FilterSegment implements Segment {\n\n        private final Filter filter;\n\n        public FilterSegment(Filter filter){\n            super();\n            this.filter = filter;\n        }\n\n        @SuppressWarnings(\"rawtypes\")\n        public Object eval(JSONPath path, Object rootObject, Object currentObject) {\n            if (currentObject == null) {\n                return null;\n            }\n\n            List<Object> items = new JSONArray();\n\n            if (currentObject instanceof Iterable) {\n                Iterator it = ((Iterable) currentObject).iterator();\n                while (it.hasNext()) {\n                    Object item = it.next();\n\n                    if (filter.apply(path, rootObject, currentObject, item)) {\n                        items.add(item);\n                    }\n                }\n\n                return items;\n            }\n\n            if (filter.apply(path, rootObject, currentObject, currentObject)) {\n                return currentObject;\n            }\n\n            return null;\n        }\n\n        public void extract(JSONPath path, DefaultJSONParser parser, Context context) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    interface Filter {\n\n        boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item);\n    }\n\n    static class FilterGroup implements Filter {\n        private boolean and;\n        private List<Filter> fitlers;\n\n        public FilterGroup(Filter left, Filter right, boolean and) {\n            fitlers = new ArrayList<Filter>(2);\n            fitlers.add(left);\n            fitlers.add(right);\n            this.and = and;\n        }\n\n        public boolean apply(JSONPath path, Object rootObject, Object currentObject, Object item) {\n            if (and) {\n                for (Filter fitler : this.fitlers) {\n                    if (!fitler.apply(path, rootObject, currentObject, item)) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                for (Filter fitler : this.fitlers) {\n                    if (fitler.apply(path, rootObject, currentObject, item)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    protected Object getArrayItem(final Object currentObject, int index) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (index >= 0) {\n                if (index < list.size()) {\n                    return list.get(index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= list.size()) {\n                    return list.get(list.size() + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject.getClass().isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    return Array.get(currentObject, index);\n                }\n                return null;\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    return Array.get(currentObject, arrayLenth + index);\n                }\n                return null;\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object value = map.get(index);\n            if (value == null) {\n                value = map.get(Integer.toString(index));\n            }\n            return value;\n        }\n\n        if (currentObject instanceof Collection) {\n            Collection collection = (Collection) currentObject;\n            int i = 0;\n            for (Object item : collection) {\n                if (i == index) {\n                    return item;\n                }\n                i++;\n            }\n            return null;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public boolean setArrayItem(JSONPath path, Object currentObject, int index, Object value) {\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n            if (index >= 0) {\n                list.set(index, value);\n            } else {\n                list.set(list.size() + index, value);\n            }\n            return true;\n        }\n\n        Class<?> clazz = currentObject.getClass();\n        if (clazz.isArray()) {\n            int arrayLenth = Array.getLength(currentObject);\n\n            if (index >= 0) {\n                if (index < arrayLenth) {\n                    Array.set(currentObject, index, value);\n                }\n            } else {\n                if (Math.abs(index) <= arrayLenth) {\n                    Array.set(currentObject, arrayLenth + index, value);\n                }\n            }\n\n            return true;\n        }\n\n        throw new JSONPathException(\"unsupported set operation.\" + clazz);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    public boolean removeArrayItem(JSONPath path, Object currentObject, int index) {\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n            if (index >= 0) {\n                if (index >= list.size()) {\n                    return false;\n                }\n                list.remove(index);\n            } else {\n                int newIndex = list.size() + index;\n                \n                if (newIndex < 0) {\n                    return false;\n                }\n                \n                list.remove(newIndex);\n            }\n            return true;\n        }\n\n        Class<?> clazz = currentObject.getClass();\n        throw new JSONPathException(\"unsupported set operation.\" + clazz);\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    protected Collection<Object> getPropertyValues(final Object currentObject) {\n        final Class<?> currentClass = currentObject.getClass();\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);\n\n        if (beanSerializer != null) {\n            try {\n                return beanSerializer.getFieldValues(currentObject);\n            } catch (Exception e) {\n                throw new JSONPathException(\"jsonpath error, path \" + path, e);\n            }\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            return map.values();\n        }\n\n        throw new UnsupportedOperationException();\n    }\n\n    protected void deepGetPropertyValues(final Object currentObject, List<Object> outValues) {\n        final Class<?> currentClass = currentObject.getClass();\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);\n\n        Collection collection = null;\n        if (beanSerializer != null) {\n            try {\n                collection = beanSerializer.getFieldValues(currentObject);\n            } catch (Exception e) {\n                throw new JSONPathException(\"jsonpath error, path \" + path, e);\n            }\n        } else if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            collection = map.values();\n        } else if (currentObject instanceof Collection) {\n            collection = (Collection) currentObject;\n        }\n\n        if (collection != null) {\n            for (Object fieldValue : collection) {\n                if (fieldValue == null || ParserConfig.isPrimitive2(fieldValue.getClass())) {\n                    outValues.add(fieldValue);\n                } else {\n                    deepGetPropertyValues(fieldValue, outValues);\n                }\n            }\n            return;\n        }\n\n        throw new UnsupportedOperationException(currentClass.getName());\n    }\n\n    static boolean eq(Object a, Object b) {\n        if (a == b) {\n            return true;\n        }\n\n        if (a == null || b == null) {\n            return false;\n        }\n\n        if (a.getClass() == b.getClass()) {\n            return a.equals(b);\n        }\n\n        if (a instanceof Number) {\n            if (b instanceof Number) {\n                return eqNotNull((Number) a, (Number) b);\n            }\n\n            return false;\n        }\n\n        return a.equals(b);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    static boolean eqNotNull(Number a, Number b) {\n        Class clazzA = a.getClass();\n        boolean isIntA = isInt(clazzA);\n\n        Class clazzB = b.getClass();\n        boolean isIntB = isInt(clazzB);\n        \n        if (a instanceof BigDecimal) {\n            BigDecimal decimalA = (BigDecimal) a;\n            \n            if (isIntB) {\n                return decimalA.equals(BigDecimal.valueOf(TypeUtils.longExtractValue(b)));\n            }\n        }\n\n        if (isIntA) {\n            if (isIntB) {\n                return a.longValue() == b.longValue();\n            }\n            \n            if (b instanceof BigInteger) {\n                BigInteger bigIntB = (BigInteger) a;\n                BigInteger bigIntA = BigInteger.valueOf(a.longValue());\n                \n                return bigIntA.equals(bigIntB);\n            }\n        }\n        \n        if (isIntB) {\n            if (a instanceof BigInteger) {\n                BigInteger bigIntA = (BigInteger) a;\n                BigInteger bigIntB = BigInteger.valueOf(TypeUtils.longExtractValue(b));\n                \n                return bigIntA.equals(bigIntB);\n            }\n        }\n        \n\n        boolean isDoubleA = isDouble(clazzA);\n        boolean isDoubleB = isDouble(clazzB);\n\n        if ((isDoubleA && isDoubleB) || (isDoubleA && isIntB) || (isDoubleB && isIntA)) {\n            return a.doubleValue() == b.doubleValue();\n        }\n        \n\n        return false;\n    }\n\n    protected static boolean isDouble(Class<?> clazzA) {\n        return clazzA == Float.class || clazzA == Double.class;\n    }\n\n    protected static boolean isInt(Class<?> clazzA) {\n        return clazzA == Byte.class || clazzA == Short.class || clazzA == Integer.class || clazzA == Long.class;\n    }\n\n    final static long SIZE = 0x4dea9618e618ae3cL; // TypeUtils.fnv1a_64(\"size\");\n    final static long LENGTH = 0xea11573f1af59eb5L; // TypeUtils.fnv1a_64(\"length\");\n\n    protected Object getPropertyValue(Object currentObject, String propertyName, long propertyNameHash) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n            Object val = map.get(propertyName);\n\n            if (val == null && (SIZE == propertyNameHash || LENGTH == propertyNameHash)) {\n                val = map.size();\n            }\n\n            return val;\n        }\n\n        final Class<?> currentClass = currentObject.getClass();\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);\n        if (beanSerializer != null) {\n            try {\n                return beanSerializer.getFieldValue(currentObject, propertyName, propertyNameHash, false);\n            } catch (Exception e) {\n                throw new JSONPathException(\"jsonpath error, path \" + path + \", segement \" + propertyName, e);\n            }\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            if (SIZE == propertyNameHash || LENGTH == propertyNameHash) {\n                return list.size();\n            }\n\n            List<Object> fieldValues = null;\n\n            for (int i = 0; i < list.size(); ++i) {\n                Object obj = list.get(i);\n\n                //\n                if (obj == list) {\n                    if (fieldValues == null) {\n                        fieldValues = new JSONArray(list.size());\n                    }\n                    fieldValues.add(obj);\n                    continue;\n                }\n\n                Object itemValue = getPropertyValue(obj, propertyName, propertyNameHash);\n                if (itemValue instanceof Collection) {\n                    Collection collection = (Collection) itemValue;\n                    if (fieldValues == null) {\n                        fieldValues = new JSONArray(list.size());\n                    }\n                    fieldValues.addAll(collection);\n                } else if (itemValue != null) {\n                    if (fieldValues == null) {\n                        fieldValues = new JSONArray(list.size());\n                    }\n                    fieldValues.add(itemValue);\n                }\n            }\n\n            if (fieldValues == null) {\n                fieldValues = Collections.emptyList();\n            }\n\n            return fieldValues;\n        }\n\n        if (currentObject instanceof Object[]) {\n            Object[] array = (Object[]) currentObject;\n\n            if (SIZE == propertyNameHash || LENGTH == propertyNameHash) {\n                return array.length;\n            }\n\n            List<Object> fieldValues = new JSONArray(array.length);\n\n            for (int i = 0; i < array.length; ++i) {\n                Object obj = array[i];\n\n                //\n                if (obj == array) {\n                    fieldValues.add(obj);\n                    continue;\n                }\n\n                Object itemValue = getPropertyValue(obj, propertyName, propertyNameHash);\n                if (itemValue instanceof Collection) {\n                    Collection collection = (Collection) itemValue;\n                    fieldValues.addAll(collection);\n                } else if (itemValue != null) {\n                    fieldValues.add(itemValue);\n                }\n            }\n\n            return fieldValues;\n        }\n\n        if (currentObject instanceof Enum) {\n            final long NAME = 0xc4bcadba8e631b86L; // TypeUtils.fnv1a_64(\"name\");\n            final long ORDINAL = 0xf1ebc7c20322fc22L; //TypeUtils.fnv1a_64(\"ordinal\");\n\n            Enum e = (Enum) currentObject;\n            if (NAME == propertyNameHash) {\n                return e.name();\n            }\n\n            if (ORDINAL == propertyNameHash) {\n                return e.ordinal();\n            }\n        }\n\n        if (currentObject instanceof Calendar) {\n            final long YEAR = 0x7c64634977425edcL; //TypeUtils.fnv1a_64(\"year\");\n            final long MONTH = 0xf4bdc3936faf56a5L; //TypeUtils.fnv1a_64(\"month\");\n            final long DAY = 0xca8d3918f4578f1dL; // TypeUtils.fnv1a_64(\"day\");\n            final long HOUR = 0x407efecc7eb5764fL; //TypeUtils.fnv1a_64(\"hour\");\n            final long MINUTE = 0x5bb2f9bdf2fad1e9L; //TypeUtils.fnv1a_64(\"minute\");\n            final long SECOND = 0xa49985ef4cee20bdL; //TypeUtils.fnv1a_64(\"second\");\n\n            Calendar e = (Calendar) currentObject;\n            if (YEAR == propertyNameHash) {\n                return e.get(Calendar.YEAR);\n            }\n            if (MONTH == propertyNameHash) {\n                return e.get(Calendar.MONTH);\n            }\n            if (DAY == propertyNameHash) {\n                return e.get(Calendar.DAY_OF_MONTH);\n            }\n            if (HOUR == propertyNameHash) {\n                return e.get(Calendar.HOUR_OF_DAY);\n            }\n            if (MINUTE == propertyNameHash) {\n                return e.get(Calendar.MINUTE);\n            }\n            if (SECOND == propertyNameHash) {\n                return e.get(Calendar.SECOND);\n            }\n        }\n\n        return null;\n        //throw new JSONPathException(\"jsonpath error, path \" + path + \", segement \" + propertyName);\n    }\n    \n    @SuppressWarnings(\"rawtypes\")\n    protected void deepScan(final Object currentObject, final String propertyName, List<Object> results) {\n        if (currentObject == null) {\n            return;\n        }\n\n        if (currentObject instanceof Map) {\n            Map<?, ?> map = (Map<?, ?>) currentObject;\n\n            for (Map.Entry entry : map.entrySet()) {\n                Object val = entry.getValue();\n\n                if (propertyName.equals(entry.getKey())) {\n                    if (val instanceof Collection) {\n                        results.addAll((Collection) val);\n                    } else {\n                        results.add(val);\n                    }\n                    continue;\n                }\n\n                if (val == null || ParserConfig.isPrimitive2(val.getClass())) {\n                    continue;\n                }\n\n                deepScan(val, propertyName, results);\n            }\n\n            return;\n        }\n\n        if (currentObject instanceof Collection) {\n            Iterator iterator = ((Collection) currentObject).iterator();\n            while (iterator.hasNext()) {\n                Object next = iterator.next();\n                if (ParserConfig.isPrimitive2(next.getClass())) {\n                    continue;\n                }\n                deepScan(next, propertyName, results);\n            }\n            return;\n        }\n\n        final Class<?> currentClass = currentObject.getClass();\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);\n        if (beanSerializer != null) {\n            try {\n                FieldSerializer fieldDeser = beanSerializer.getFieldSerializer(propertyName);\n                if (fieldDeser != null) {\n                    try {\n                        Object val = fieldDeser.getPropertyValueDirect(currentObject);\n                        results.add(val);\n                    } catch (InvocationTargetException ex) {\n                        throw new JSONException(\"getFieldValue error.\" + propertyName, ex);\n                    } catch (IllegalAccessException ex) {\n                        throw new JSONException(\"getFieldValue error.\" + propertyName, ex);\n                    }\n                    return;\n                }\n                List<Object> fieldValues = beanSerializer.getFieldValues(currentObject);\n                for (Object val : fieldValues) {\n                    deepScan(val, propertyName, results);\n                }\n                return;\n            } catch (Exception e) {\n                throw new JSONPathException(\"jsonpath error, path \" + path + \", segement \" + propertyName, e);\n            }\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            for (int i = 0; i < list.size(); ++i) {\n                Object val = list.get(i);\n                deepScan(val, propertyName, results);\n            }\n            return;\n        }\n    }\n\n    protected void deepSet(final Object currentObject, final String propertyName, long propertyNameHash, Object value) {\n        if (currentObject == null) {\n            return;\n        }\n\n        if (currentObject instanceof Map) {\n            Map map = (Map) currentObject;\n\n            if (map.containsKey(propertyName)) {\n                Object val = map.get(propertyName);\n                map.put(propertyName, value);\n                return;\n            }\n\n            for (Object val : map.values()) {\n                deepSet(val, propertyName, propertyNameHash, value);\n            }\n            return;\n        }\n\n        final Class<?> currentClass = currentObject.getClass();\n\n        JavaBeanDeserializer beanDeserializer = getJavaBeanDeserializer(currentClass);\n        if (beanDeserializer != null) {\n            try {\n                FieldDeserializer fieldDeser = beanDeserializer.getFieldDeserializer(propertyName);\n                if (fieldDeser != null) {\n                    fieldDeser.setValue(currentObject, value);\n                    return;\n                }\n\n                JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentClass);\n                List<Object> fieldValues = beanSerializer.getObjectFieldValues(currentObject);\n                for (Object val : fieldValues) {\n                    deepSet(val, propertyName, propertyNameHash, value);\n                }\n                return;\n            } catch (Exception e) {\n                throw new JSONPathException(\"jsonpath error, path \" + path + \", segement \" + propertyName, e);\n            }\n        }\n\n        if (currentObject instanceof List) {\n            List list = (List) currentObject;\n\n            for (int i = 0; i < list.size(); ++i) {\n                Object val = list.get(i);\n                deepSet(val, propertyName, propertyNameHash, value);\n            }\n            return;\n        }\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    protected boolean setPropertyValue(Object parent, String name, long propertyNameHash, Object value) {\n        if (parent instanceof Map) {\n            ((Map) parent).put(name, value);\n            return true;\n        }\n\n        if (parent instanceof List) {\n            for (Object element : (List) parent) {\n                if (element == null) {\n                    continue;\n                }\n                setPropertyValue(element, name, propertyNameHash, value);\n            }\n            return true;\n        }\n\n        ObjectDeserializer derializer = parserConfig.getDeserializer(parent.getClass());\n\n        JavaBeanDeserializer beanDerializer = null;\n        if (derializer instanceof JavaBeanDeserializer) {\n            beanDerializer = (JavaBeanDeserializer) derializer;\n        }\n\n        if (beanDerializer != null) {\n            FieldDeserializer fieldDeserializer = beanDerializer.getFieldDeserializer(propertyNameHash);\n            if (fieldDeserializer == null) {\n                return false;\n            }\n\n            fieldDeserializer.setValue(parent, value);\n            return true;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n    \n    @SuppressWarnings({\"rawtypes\" })\n    protected boolean removePropertyValue(Object parent, String name) {\n        if (parent instanceof Map) {\n            Object origin = ((Map) parent).remove(name);\n            return origin != null;\n        }\n\n        ObjectDeserializer derializer = parserConfig.getDeserializer(parent.getClass());\n\n        JavaBeanDeserializer beanDerializer = null;\n        if (derializer instanceof JavaBeanDeserializer) {\n            beanDerializer = (JavaBeanDeserializer) derializer;\n        }\n\n        if (beanDerializer != null) {\n            FieldDeserializer fieldDeserializer = beanDerializer.getFieldDeserializer(name);\n            if (fieldDeserializer == null) {\n                return false;\n            }\n\n            fieldDeserializer.setValue(parent, null);\n            return true;\n        }\n\n        throw new UnsupportedOperationException();\n    }\n\n    protected JavaBeanSerializer getJavaBeanSerializer(final Class<?> currentClass) {\n        JavaBeanSerializer beanSerializer = null;\n        {\n            ObjectSerializer serializer = serializeConfig.getObjectWriter(currentClass);\n            if (serializer instanceof JavaBeanSerializer) {\n                beanSerializer = (JavaBeanSerializer) serializer;\n            }\n        }\n        return beanSerializer;\n    }\n\n    protected JavaBeanDeserializer getJavaBeanDeserializer(final Class<?> currentClass) {\n        JavaBeanDeserializer beanDeserializer = null;\n        {\n            ObjectDeserializer deserializer = parserConfig.getDeserializer(currentClass);\n            if (deserializer instanceof JavaBeanDeserializer) {\n                beanDeserializer = (JavaBeanDeserializer) deserializer;\n            }\n        }\n        return beanDeserializer;\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    int evalSize(Object currentObject) {\n        if (currentObject == null) {\n            return -1;\n        }\n\n        if (currentObject instanceof Collection) {\n            return ((Collection) currentObject).size();\n        }\n\n        if (currentObject instanceof Object[]) {\n            return ((Object[]) currentObject).length;\n        }\n\n        if (currentObject.getClass().isArray()) {\n            return Array.getLength(currentObject);\n        }\n\n        if (currentObject instanceof Map) {\n            int count = 0;\n\n            for (Object value : ((Map) currentObject).values()) {\n                if (value != null) {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentObject.getClass());\n\n        if (beanSerializer == null) {\n            return -1;\n        }\n\n        try {\n            return beanSerializer.getSize(currentObject);\n        } catch (Exception e) {\n            throw new JSONPathException(\"evalSize error : \" + path, e);\n        }\n    }\n\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Set<?> evalKeySet(Object currentObject) {\n        if (currentObject == null) {\n            return null;\n        }\n\n        if (currentObject instanceof Map) {\n            // For performance reasons return keySet directly, without filtering null-value key.\n            return ((Map)currentObject).keySet();\n        }\n\n        if (currentObject instanceof Collection || currentObject instanceof Object[]\n            || currentObject.getClass().isArray()) {\n            return null;\n        }\n\n        JavaBeanSerializer beanSerializer = getJavaBeanSerializer(currentObject.getClass());\n        if (beanSerializer == null) {\n            return null;\n        }\n\n        try {\n            return beanSerializer.getFieldNames(currentObject);\n        } catch (Exception e) {\n            throw new JSONPathException(\"evalKeySet error : \" + path, e);\n        }\n    }\n\n    public String toJSONString() {\n        return JSON.toJSONString(path);\n    }\n}\n"},
{"Line": "=>25", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (already.contains(ideFrame.hashCode())) return;", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V176/2659/buggy-version/src.github.cweijan.decorate.init.DecorateIniaializer.java", "BodyUseAPI": [], "Fixed commit": "b1f1b4fef291acfb80020670b1696763445b91ce", "Url": "https://api.github.com/repos/cweijan/decorate", "Date": "2018-11-30T08:03:02Z"},
{"Line": "=>47", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((Build.VERSION.SDK_INT) >= (Build.VERSION_CODES.LOLLIPOP)) { listView.setNestedScrollingEnabled(true); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/425/buggy-version/app.src.main.java.edu_cn.pku.course.activities.AboutActivity.java", "BodyUseAPI": [], "Fixed commit": "f1b3b38e2bb44298427b2525a9154a311e2c3f58", "Url": "https://api.github.com/repos/cbwang2016/PKUCourses", "Date": "2018-12-06T12:46:53Z", "Source Code Diff": "@@ -44,6 +44,9 @@ protected void onCreate(Bundle savedInstanceState) {\n         getMenuList();\n \n         ListView listView = findViewById(R.id.about_listView);\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n+            listView.setNestedScrollingEnabled(true);\n+        }\n \n         final AboutAdapter adapter = new AboutAdapter(AboutActivity.this, mList);\n         listView.setAdapter(adapter);", "Complete After Code": "package edu_cn.pku.course.activities;\n\nimport android.annotation.SuppressLint;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.annotation.RequiresApi;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.r0adkll.slidr.Slidr;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu_cn.pku.course.Utils;\nimport edu_cn.pku.course.adapter.AboutAdapter;\n\n\npublic class AboutActivity extends AppCompatActivity {\n    private List<AboutMenu> mList = new ArrayList<>();\n\n    @SuppressLint({\"Assert\", \"InflateParams\"})\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_about);\n        setTitle(\"About\");\n        TextView version = findViewById(R.id.about_version_number);\n        String versionStr = \"\u7248\u672c\u53f7\uff1a\" + Utils.versionString;\n        version.setText(versionStr);\n\n        ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            actionBar.setDisplayHomeAsUpEnabled(true);\n        }\n        getMenuList();\n\n        ListView listView = findViewById(R.id.about_listView);\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            listView.setNestedScrollingEnabled(true);\n        }\n\n        final AboutAdapter adapter = new AboutAdapter(AboutActivity.this, mList);\n        listView.setAdapter(adapter);\n\n        //ListView item\u7684\u70b9\u51fb\u4e8b\u4ef6\n        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @SuppressLint(\"Assert\")\n            @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN)\n            @Override\n            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n                switch (i) {\n                    case 0:\n                        // \u201c\u95ee\u9898\u53cd\u9988\u201d\uff1a\u53d1\u9001\u90ae\u4ef6\n                        Intent j = new Intent(Intent.ACTION_SEND);\n                        // j.setType(\"text/plain\"); //\u6a21\u62df\u5668\u8bf7\u4f7f\u7528\u8fd9\u884c\n                        j.setType(\"message/rfc822\"); // \u771f\u673a\u4e0a\u4f7f\u7528\u8fd9\u884c\n                        j.putExtra(Intent.EXTRA_EMAIL, new String[]{\"wcb@pku.edu.cn\"});\n                        j.putExtra(Intent.EXTRA_SUBJECT, \"\u60a8\u53d1\u73b0\u7684\u95ee\u9898\u53ca\u5efa\u8bae\");\n                        j.putExtra(Intent.EXTRA_TEXT, \"\u6211\u4eec\u5f88\u5e0c\u671b\u80fd\u5f97\u5230\u60a8\u7684\u5efa\u8bae\uff01\uff01\uff01\");\n                        startActivity(Intent.createChooser(j, \"Select email application.\"));\n                        break;\n                    case 1:\n                        Uri uri = Uri.parse(\"https://github.com/cbwang2016/PKUCourses\");\n                        Intent it = new Intent(Intent.ACTION_VIEW, uri);\n                        startActivity(it);\n                        break;\n                    case 2:\n                        Toast.makeText(AboutActivity.this, \"\u522b\u70b9\u4e86\uff0c\u518d\u70b9\u529f\u80fd\u4e5f\u4e0d\u4f1a\u591a\u7684\uff01\\n\u4e0d\u5982\u70b9\u51fb\u201c\u95ee\u9898\u53cd\u9988\u201d\u7ed9\u4e88\u6211\u4eec\u5efa\u8bae\u3002\", Toast.LENGTH_SHORT).show();\n                        break;\n                    case 3:\n                        Toast.makeText(AboutActivity.this, \"Bloom\uff01\\n\u8fd9\u91cc\u6709\u56db\u53ea\u72d7\\n\u6709\u610f\u5411\u53ef\u4ee5\u9009\u8d2d\", Toast.LENGTH_SHORT).show();\n                        break;\n                }\n            }\n        });\n        Slidr.attach(this);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                onBackPressed();\n                return true;\n        }\n\n        return (super.onOptionsItemSelected(item));\n    }\n\n    /**\n     * \u521d\u59cb\u5316\u6570\u636e\n     */\n    private void getMenuList() {\n        mList.add(new AboutMenu(R.mipmap.icon_email_600, \"\u95ee\u9898\u53cd\u9988\", \"Select email application to send an email to the developer.\", null));\n        mList.add(new AboutMenu(R.mipmap.icon_github_logo_1024, \"Github Page\", \"Open source code on GitHub.\", null));\n        mList.add(new AboutMenu(R.mipmap.icon_function_768, \"\u529f\u80fd\u4ecb\u7ecd\", \"Features\", \"\u6b64APP\u5305\u542b\u4e86course.pku.edu.cn\u7684\u90e8\u5206\u5e38\u7528\u529f\u80fd\uff0c\u4f8b\u5982\u516c\u544a\u3001\u901a\u77e5\u3001\u8bfe\u7a0b\u5217\u8868\u53ca\u6bcf\u4e2a\u8bfe\u7a0b\u5305\u542b\u7684\u5185\u5bb9\u7b49\uff0c\u53e6\u5916\u6dfb\u52a0\u4e86\u5317\u4eac\u5927\u5b66\u95e8\u6237\u4e2d\u7a7a\u95f2\u6559\u5ba4\u67e5\u8be2\u7684\u529f\u80fd\uff0c\u5e0c\u671b\u4e3a\u5bfb\u627e\u7a7a\u95f2\u6559\u5ba4\u7684\u540c\u5b66\u63d0\u4f9b\u4fbf\u5229\u3002\\n\"));\n        mList.add(new AboutMenu(R.mipmap.icon_member_980, \"\u5f00\u53d1\u4eba\u5458\", \"Developer\", \"\u672cApp\u7531\u56db\u4e2a\u75af\u4eba\u9662\u6210\u5458\u5f00\u53d1\u5236\u4f5c\uff1a\\n\\n\" +\n                \"\u00b7\u53f6\u6797\u6960\\n    \u4e3b\u8981\u8d1f\u8d23\u4eba\\n        \u6280\u672f\u603b\u76d1\\n\\n\" +\n                \"\u00b7Yinian\\n    \u70b9\u5b50\u6765\u6e90\\n        \u5409\u7965\u7269\\n\\n\" +\n                \"\u00b7\u6768\u8001\u5e08\u6b4c\u8ff7\\n    \u827a\u672f\u603b\u76d1\\n\\n\" +\n                \"\u00b7\u4e23\u89ad\\n    \u2265DDL\\n        \u6302\u4ef6\\n\"));\n    }\n\n    public class AboutMenu {\n        private int imageId;\n        private String menu;\n        private String subMenu;\n        private String content;\n\n        AboutMenu(int imageId, String menu, String subMenu, String content) {\n            this.imageId = imageId;\n            this.menu = menu;\n            this.subMenu = subMenu;\n            this.content = content;\n        }\n\n        public String getMenu() {\n            return menu;\n        }\n\n        public String getSubMenu() {\n            return subMenu;\n        }\n\n        public int getImageId() {\n            return imageId;\n        }\n\n        public String getContent() {\n            return content;\n        }\n    }\n}\n\n\n\n"},
{"Line": "=>41", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if ((((java.lang.String.valueOf(value).length()) - (java.lang.String.valueOf(value).indexOf(\".\"))) - 1) <= 8) { return java.lang.String.valueOf(value); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/574/buggy-version/app.src.main.java.org.nervos.neuron.util.NumberUtil.java", "BodyUseAPI": ["java.lang.String.valueOf(double)"], "Fixed commit": "d8785321f1ff21bdfab124eb42647ad4c7c39f20", "Url": "https://api.github.com/repos/cryptape/cyton-android", "Date": "2018-11-20T07:28:29Z"},
{"Line": "=>56", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[]", "Content": "=>if ((get_id()) != null) { java.lang.Thread t = new java.lang.Thread(get_id()); this.threadId = DatabaseController.INSTANCE.getRecord(t, t.getCollection(), java.lang.Thread.class).get_id(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/832/buggy-version/src.main.java.app.entities.Announcement.java", "BodyUseAPI": [], "Fixed commit": "90f7cc0d0d17867bd717954e2243d5968ade2f21", "Url": "https://api.github.com/repos/vbutzke/DS3Project", "Date": "2018-12-12T17:01:13Z", "Source Code Diff": "@@ -52,8 +52,11 @@ public Announcement(String title, String description, Address address, String ra\n         this.status \t  = AnnouncementStatus.AVAILABLE;\n         this.adopter     = \"\";\n         this.adopted \t  = false;\n-        Thread t = new Thread(get_id());\n+        \n+        if(get_id()!=null) {\n+        \tThread t = new Thread(get_id());\n \t\t    this.threadId    = DatabaseController.INSTANCE.getRecord(t, t.getCollection(), Thread.class).get_id();\n+        }\n     }\n \n \tpublic String get_id() {", "Complete After Code": "package app.entities;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport app.singletons.AnnouncementStatus;\nimport app.database.DatabaseController;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\nimport app.utils.MongoDbDateDeserializer;\nimport app.utils.MongoDbId;\nimport org.springframework.data.annotation.Transient;\n\npublic class Announcement {\n\t\n\t@JsonSerialize(using=ToStringSerializer.class)\n\tprivate MongoDbId _id;\n  \n\tprivate String    title;\n\tprivate String    description;\n  private Address   address;\n  private String    race;\n  private String    age;\n  private String    size;\n\tprivate String    user;\n\tprivate Photo     photo;\n\tprivate ArrayList<AnnouncementParams> params;\n\tprivate AnnouncementStatus status;\n\tprivate String adopter;\n\tprivate boolean adopted;\n\tprivate String    threadId;\n\tprivate final String collection = \"announcements\";\n\n  @Transient\n\tprivate boolean favorite;\n  \n\t@JsonDeserialize(using = MongoDbDateDeserializer.class)\n\tprivate Date createdAt;\n\n    public Announcement() {}\n\n    public Announcement(String title, String description, Address address, String race, String age, String size) throws IOException {\n        this.title       = title;\n        this.description = description;\n        this.address     = address;\n        this.race        = race;\n        this.age         = age;\n        this.size        = size;\n        this.status \t  = AnnouncementStatus.AVAILABLE;\n        this.adopter     = \"\";\n        this.adopted \t  = false;\n        \n        if(get_id()!=null) {\n        \tThread t = new Thread(get_id());\n\t\t    this.threadId    = DatabaseController.INSTANCE.getRecord(t, t.getCollection(), Thread.class).get_id();\n        }\n    }\n\n\tpublic String get_id() {\n\t\tif(_id == null)\n\t\t\treturn null;\n\t\t\n\t\treturn _id.get$oid();\n\t}\n\n\tpublic void set_id(MongoDbId _id) {\n\t\tthis._id = _id;\n\t}\n\n\tpublic String getTitle() {\n\t\treturn title;\n\t}\n\n\tpublic void setTitle(String title) {\n\t\tthis.title = title;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic Address getAddress() {\n\t\treturn address;\n\t}\n\n\tpublic void setAddress(Address address) {\n\t\tthis.address = address;\n\t}\n\n\tpublic String getRace() {\n\t\treturn race;\n\t}\n\n\tpublic void setRace(String race) {\n\t\tthis.race = race;\n\t}\n\n\tpublic String getAge() {\n\t\treturn age;\n\t}\n\n\tpublic void setAge(String age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic String getSize() {\n\t\treturn size;\n\t}\n\n\tpublic void setSize(String size) {\n\t\tthis.size = size;\n\t}\n\n\tpublic String getUser() {\n\t\treturn user;\n\t}\n\n\tpublic void setUser(String user) {\n\t\tthis.user = user;\n\t}\n\n\tpublic Date getCreatedAt() {\n\t\treturn createdAt;\n\t}\n\t\n\tpublic void setCreatedAt(Date createdAt) {\n\t\tthis.createdAt = createdAt;\n\t}\n\n\tpublic void setAvatar(Photo p) {\n\t\tthis.photo = p;\n\t}\n\t\n\tpublic Photo getAvatar() {\n\t\treturn this.photo;\n\t}\n\t\n\tpublic ArrayList<AnnouncementParams> getParams() {\n\t\treturn params;\n\t}\n\n\tpublic void setParams(ArrayList<AnnouncementParams> params) {\n\t\tthis.params = params;\n\t}\n\n\tpublic boolean getFavorite() {\n\t\treturn favorite;\n\t}\n\n\tpublic void setFavorite(boolean favorite) {\n\t\tthis.favorite = favorite;\n\t}\n\t\n  public String getAdopter() {\n\t\treturn adopter;\n  }\n  \n  public boolean isAdopted() {\n\t\treturn adopted;\n\t}\n\n\tpublic void setAdopter(String adopter) {\n\t\tthis.adopter = adopter;\n\t}\n\n\tpublic void requestAdoption(String adopterId){\n    \tif(this.status == AnnouncementStatus.AVAILABLE) {\n\t\t\tthis.status = AnnouncementStatus.PENDING_APPROVAL;\n\t\t\tsetAdopter(adopterId);\n\t\t} else {\n    \t\tthrow new UnsupportedOperationException(\"There is an adoption pending for this announcement.\");\n\t\t}\n\t}\n\n\tpublic void approveAdoption(String adopterId){\n    \tif(this.status == AnnouncementStatus.PENDING_APPROVAL) {\n\t\t\tthis.status = AnnouncementStatus.ADOPTED;\n\t\t\tsetAdopter(adopterId);\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"There is an adoption pending for this announcement.\");\n\t\t}\n\t}\n\n\tpublic void declineAdoption(){\n\t\tif(this.status == AnnouncementStatus.PENDING_APPROVAL) {\n\t\t\tthis.status = AnnouncementStatus.AVAILABLE;\n\t\t\tsetAdopter(\"\");\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"There is an adoption pending for this announcement.\");\n\t\t}\n\t}\n\n  public Thread addComment(Comment comment) throws IOException {\n    \tThread thread = getThreadFromDB();\n    \tif(thread == null){\n    \t\tthread = new Thread(get_id(), comment);\n\t\t} else {\n    \t\tthread.getComments().add(comment);\n\t\t}\n\t\tDatabaseController.INSTANCE.updateObject(thread, thread.getCollection());\n\t\treturn thread;\n\t}\n\n\tpublic Thread removeComment(int commentPos) throws IOException {\n    \tThread thread = getThreadFromDB();\n    \tthread.getComments().remove(commentPos);\n\t\tDatabaseController.INSTANCE.updateObject(thread, thread.getCollection());\n    \treturn thread;\n\t}\n\n\tpublic Photo getPhoto() {\n\t\treturn photo;\n\t}\n\n\tpublic void save() throws JsonProcessingException {\n\t\tDatabaseController.INSTANCE.updateObject(this, collection);\n\t}\n\n\tpublic String getCollection() {\n\t\treturn collection;\n\t}\n\n\tpublic String getThreadId() {\n\t\treturn threadId;\n\t}\n\n\t@JsonIgnore\n\tpublic Thread getThreadFromDB() throws IOException {\n\n\t\treturn (Thread) DatabaseController.INSTANCE.getRecordBy(threadId, \"threads\", Thread.class);\n\t}\n}\n"},
{"Line": "=>29", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["android.os.Bundle.getInt(java.lang.String)"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (position == 0) currentCafe = currentCafe.substring(1, currentCafe.length());", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/657/buggy-version/app.src.main.java.ua.com.mnbs.noq.ListOfMeals.java", "BodyUseAPI": [], "Fixed commit": "c40bc071f9cb646b1605b0b8551340c0767ad03e", "Url": "https://api.github.com/repos/MaryAndBoys2018/NoQ", "Date": "2018-11-26T19:25:57Z", "Source Code Diff": "@@ -22,9 +22,13 @@ protected void onCreate(Bundle savedInstanceState) {\n         Intent intent = getIntent();\n         Bundle extras = intent.getExtras();\n         String currentCafe = extras.getString(\"cafe name\");\n+        int position = extras.getInt(\"position\");\n \n         currentCafe = currentCafe.trim();\n \n+        if (position == 0)\n+            currentCafe = currentCafe.substring(1,currentCafe.length());\n+\n         Toast.makeText(getApplicationContext(), currentCafe,\n                 Toast.LENGTH_SHORT).show();\n ", "Complete After Code": "package ua.com.mnbs.noq;\n\nimport android.content.Intent;\nimport android.location.Location;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.widget.ArrayAdapter;\nimport android.widget.ListView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\npublic class ListOfMeals extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_menu);\n\n        Intent intent = getIntent();\n        Bundle extras = intent.getExtras();\n        String currentCafe = extras.getString(\"cafe name\");\n        int position = extras.getInt(\"position\");\n\n        currentCafe = currentCafe.trim();\n\n        if (position == 0)\n            currentCafe = currentCafe.substring(1,currentCafe.length());\n\n        Toast.makeText(getApplicationContext(), currentCafe,\n                Toast.LENGTH_SHORT).show();\n\n        String menuFileDirectory = currentCafe + \"_menu.txt\";\n        String pricesFileDirectory = currentCafe + \"_prices.txt\";\n\n        Toast.makeText(getApplicationContext(), menuFileDirectory,\n                Toast.LENGTH_SHORT).show();\n\n        String names = readFile(menuFileDirectory);\n        ArrayList<String> name = moveIntoArrayList(names);\n        String prices = readFile(pricesFileDirectory);\n        ArrayList<String> price = moveIntoArrayList(prices);\n\n       // Toast.makeText(getApplicationContext(), name.get(1), Toast.LENGTH_SHORT).show();\n\n        ArrayList<Meal> meals = new ArrayList<>();\n\n        if (isMistakeInFiles(name, price))\n            Toast.makeText(getApplicationContext(), \"Something is wrong with your text files.\",\n                    Toast.LENGTH_SHORT).show();\n        else {\n            meals = createMealArrayList(name, price);\n            printListOfMeals(meals);\n        }\n\n    }\n\n    private String readFile(String fileName) {\n        String text = \"\";\n        try {\n            InputStream inputStream = getAssets().open(fileName);\n            int size = inputStream.available();\n            byte[] buffer = new byte[size];\n            inputStream.read(buffer);\n            inputStream.close();\n            text = new String(buffer);\n            text += '\\0';\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return text;\n    }\n\n    private ArrayList<String> moveIntoArrayList(String text) {\n        ArrayList<String> returnValue = new ArrayList<>();\n        String temp = \"\";\n        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) == '\\n' || text.charAt(i) == '\\0') {\n                returnValue.add(temp);\n                temp = \"\";\n                continue;\n            }\n            temp += text.charAt(i);\n        }\n        return returnValue;\n    }\n\n    private void printListOfMeals(ArrayList<Meal> meals) {\n        MenuAdapter adapter = new MenuAdapter(this, meals);\n        ListView listView = (ListView) findViewById(R.id.menu_list);\n        listView.setAdapter(adapter);\n    }\n\n    private boolean isMistakeInFiles(ArrayList<String> name, ArrayList<String> price) {\n        return (name.size() != price.size());\n    }\n\n    private ArrayList<Meal> createMealArrayList(ArrayList<String> name, ArrayList<String> price) {\n        ArrayList<Meal> meals = new ArrayList<>();\n        for (int i = 0; i < name.size(); i++)\n            meals.add(new Meal(name.get(i), price.get(i)));\n        return meals;\n    }\n}\n"},
{"Line": "=>567", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["android.widget.Scroller.getCurrX()"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if ((mLastCurrX) != tmp) { callbackScrolling(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/981/buggy-version/waveselectorwidget.src.main.java.com.tencent.intoo.component.widget.waveselector.WaveSelector.java", "BodyUseAPI": [], "Fixed commit": "3172e14f947edd692651e3d360e1de84a3dd6bc8", "Url": "https://api.github.com/repos/sparks345/WaveSelector", "Date": "2018-12-17T15:36:44Z", "Source Code Diff": "@@ -563,8 +563,10 @@ public void computeScroll() {\n             postInvalidate();\n             mLastScrollEndTS = System.currentTimeMillis();\n \n-            callbackScrolling();\n-\n+            int tmp = mScroll.getCurrX();\n+            if (mLastCurrX != tmp) {\n+                callbackScrolling();\n+            }\n         } else {\n             int tmp = mScroll.getCurrX();\n             if (mLastCurrX != tmp) {\n@@ -706,7 +708,7 @@ public void refreshData(List<Integer> ll) {\n      * @param start start\n      */\n     public void seekTo(int start) {\n-        Log.d(TAG, \"seekTo() called with: start = [\" + start + \"] , form =[\" + mCurrentLeft + \"]\");\n+        Log.d(TAG, \"seekTo() called with: start time = [\" + start + \"] , from pos = [\" + mCurrentLeft + \"]\");\n         if (mInited && mIsOnPreDraw) {\n             Log.d(TAG, \"scrollTo... to:\" + start);\n ", "Complete After Code": "package com.tencent.intoo.component.widget.waveselector;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.ConcurrentLinkedQueue;\n\nimport android.animation.ArgbEvaluator;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.content.res.TypedArray;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.RectF;\nimport android.os.SystemClock;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.VelocityTracker;\nimport android.view.View;\nimport android.view.ViewTreeObserver;\nimport android.widget.Scroller;\n\n/**\n * \u6ce2\u5f62\u7ed8\u5236\u7ec4\u4ef6\n * <p>\n * \u5bf9\u5e94PCM\u91c7\u6837\u70b9\u8ba1\u7b97\uff1a\n * k = 1000 / 44100 * 1024 = 23.21995464852607709750566893424;  // 23.22ms \u4e00\u4e2a\u6ce2\u5f62\u70b9\n * m = 1000 / k = 43.066406250000000000000000000001;  // \u6bcf\u79d243\u4e2a\u6ce2\u5f62\u70b9\n * d = 72 / 40s = 1.8/s;  // \u6ee1\u5c4f72\u4e2a\u7ed8\u5236\u70b9 \u5bf9\u5e94 40s\uff0c\u6bcf\u79d2 1.8\u4e2a\u7ed8\u5236\u70b9\n * s = m / d = 23.92578125 \u2248 24;    // \u6bcf\u4e2a\u70b9\u5bf9\u5e9424\u4e2a\u6ce2\u5f62\u70b9\n * SAMPLE_STEP * 2\n *\n * @see #calcSampleStep(int, int, int)\n */\npublic class WaveSelector extends View {\n    public static final String TAG = \"WaveSelector\";\n\n    // TODO \u6ed1\u52a8\u8f68\u9053\u7684\u7075\u654f\u5ea6\n    private static final int SCROLL_SENSITIVITY = 1;\n\n    // \u64ad\u653eAndroid\u673a\u578b\u4f1a\u6709\u9009\u62e9\u65f6\u95f4+1\u3001-1\u6765\u56de\u6296\u52a8\u7684\u73b0\u8c61\uff0c\u5c1d\u8bd5\u4f18\u5316\u4e00\u4e0b\u8fd9\u91cc\n    private boolean mSmoothScrollEnable = true;\n\n    private final ArgbEvaluator mArgbEvaluator;\n    // \u6ce2\u5f62\u64ad\u653e\u6bb5\u8d77\u6b62\u989c\u8272\n    private final int mPlayingStartColor;\n    private final int mPlayingEndColor;\n\n    // \u9009\u62e9\u7ebf\u989c\u8272\n    private final int mSelectLineColor;\n    // \u6ed1\u52a8\u5230\u5c3e\u90e8\u6700\u5c11\u65f6\u957f\u9650\u5236\u65f6\u9009\u62e9\u7ebf\u7684\u989c\u8272\n    private final int mSelectLineOnLimitColor;\n\n    // \u7f13\u5b58\u6ce2\u5f62\u6570\u636e\n    private ArrayList<Volume> mData = new ArrayList<>();\n    private int mPlayDuration;\n    private int mLastDuration = -1;\n\n    private float density = getResources().getDisplayMetrics().density;\n\n    // \u6ee1\u5c4f\u65f6\u957f\n    private long mFullWidthTrackDuration = 40000;\n    // \u534a\u5c4f\u6ce2\u5f62\u4e2a\u6570\n    private int mHalfWaveCount = 36;//36;\n    private int mScrollingVelocity = SCROLLING_VELOCITY_UNIT;\n    // \u6ee1\u5c4f\u6ce2\u5f62\u4e2a\u6570\uff0c\u5de6\u53f3\u5bf9\u79f0\uff0c\u6ee1\u5c4f\u6ce2\u5f62\u6570\u662f\u4e24\u4e2a\u534a\u5c4f\n    private int mWavePageCount = mHalfWaveCount * 2;\n    // \u6ce2\u5f62\u5bbd\u5ea6\uff0c\u901a\u8fc7\u6ee1\u5c4f\u65f6\u957f\u548c\u6ee1\u5c4f\u6ce2\u5f62\u4e2a\u6570\u6362\u7b97,\u9ed8\u8ba440s\u65f6\u957f72\u4e2a\u6ce2\u5f62\n    // \u6bcf\u4e2a\u6ce2\u5f62\u5355\u5143\u5305\u62ec \u4e00\u4e2a\u95f4\u9694 + \u4e00\u4e2a\u6ce2\u5f62\n    private float mWaveSize = 0;//(int) (density * 10);\n    private float mWaveSpace;\n\n    private int mWavePaddingTop = (int) (20 * density);\n    private int mWavePaddingBottom = (int) (30 * density);\n    private int mFullWidth;\n    private int mFullHeight;\n    private float mPIX_PER_SECOND;\n\n    /////////////////////////////////////////////////////////\n    private VelocityTracker mVelocityTracker;\n    private final Scroller mScroll;\n    private long mLastPageStart = -1;//\u76f8\u5bf9pos\n    private long mLastScrollingPageStart = -1;//\u76f8\u5bf9pos\n    private IWaveSelectorListener mListener = new IWaveSelectorListener() {\n        @Override\n        public void onChanging(long timeStart) {\n            Log.d(TAG, \"onChanging() called with: timeStart = [\" + timeStart + \"]\");\n        }\n\n        @Override\n        public void onSelect(long timeStart) {\n            Log.d(TAG, \"onSelect() called with: timeStart = [\" + timeStart + \"]\");\n        }\n\n        @Override\n        public void onReady() {\n            Log.d(TAG, \"onReady() called\");\n        }\n\n        @Override\n        public void onLimit() {\n            Log.d(TAG, \"onLimit() called\");\n        }\n    };\n\n    /////////////////////////////////////////////////////////\n    private float mMaxScrollX;\n    private int mCurrentLeft;\n    private long mLastScrollEndTS;\n    private int mLastCurrX;\n    private boolean mIgnoreCallBack;\n    // \u5de6\u53f3\u7a7a\u95f2\u7684\u95f4\u8ddd\uff0c\u65b9\u4fbf\u4ee5\u4e2d\u70b9\u65b9\u5f0f\u9009\u4e2d\u7b2c0\u79d2\u548c\u6700\u540e\u4e00\u79d2\n    private int mPaddingPix;\n\n    private SizeConvertAdapter mConvertAdapter;\n\n    private boolean mInited;\n    private boolean mIsOnPreDraw;\n    private boolean mIsLimiting = false;\n    private int mAutoSeekTo;// seek\u540e\u754c\u9762\u8fd8\u6ca1ready\uff0c\u5148\u4fdd\u6301\u5728\uff0c\u540e\u7eedonReady\u540e\u8fd8\u539fseek\n\n    // \u6700\u5927\u6eda\u52a8\u8d77\u59cb\u4f4d\u7f6e\uff0c\u9632\u6b62\u6eda\u51fa\u754c\u9762\n    private int mLastAvailableLeft;\n\n    /////////////////////////////////////////////////////////\n    private final RectF mRectVolume = new RectF();\n    private final Paint mWavePaint;\n    private final Paint mWavePlayingPaint;\n    private final Paint mSelectPaint;\n//    private final ValueAnimator mValueAnimator;\n\n    /////////////////////////////////////////////////////////\n    private static final int SCROLLING_VELOCITY_UNIT = 100;\n    private static final float MIN_MOVE_DISTANCE = 1;\n\n    private static final int Direction_UNKNOWN = 0;\n    private static final int Direction_RIGHT = 2;\n    private static final int Direction_LEFT = 1;\n\n    private boolean mIsDragging;\n    private float mLastX;\n    private float mLastDownX;\n    private int mDragDirection;\n\n    /////////////////////////////////////////////////////////\n    private float mHighLightEndPos;//\u76f8\u5bf9\u4f4d\u7f6e\n    private float mHighLightStartPos;\n    private float mHighLightProgressPos;\n    private boolean isProgressing;\n    private Timer timer;\n    private TimerTask timerTask;\n    private static final int TIMER_TRIGGER = 200;\n    // \u6700\u5c11\u53ef\u9009\u65f6\u957f\n    private int mDefaultLimitSelectTime = 2000;\n\n    /////////////////////////////////////////////////////////\n    public WaveSelector(Context context) {\n        this(context, null);\n    }\n\n    public WaveSelector(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n\n        final Resources res = context.getResources();\n        final TypedArray attributes = res.obtainAttributes(attrs, R.styleable.WaveSelector);\n        mFullWidthTrackDuration = attributes.getInt(R.styleable.WaveSelector_full_width_track_duration, (int) mFullWidthTrackDuration);\n        mHalfWaveCount = attributes.getInt(R.styleable.WaveSelector_half_wave_count, mHalfWaveCount);\n        mScrollingVelocity = attributes.getInt(R.styleable.WaveSelector_scrolling_velocity, SCROLLING_VELOCITY_UNIT);\n\n        init();\n\n        mScroll = new Scroller(getContext());\n\n        mWavePaint = new Paint();// \u6ce2\u5f62\n        int waveColor = attributes.getColor(R.styleable.WaveSelector_wave_color, getResources().getColor(R.color.colorWave));\n        mWavePaint.setColor(waveColor);\n\n        mWavePlayingPaint = new Paint();// \u64ad\u653e\u8fc7\u7684\u6ce2\u5f62\n        mWavePlayingPaint.setColor(getResources().getColor(R.color.colorWavePlayed));\n\n        mSelectPaint = new Paint();// \u9009\u62e9\u7ebf\n        mSelectLineColor = attributes.getColor(R.styleable.WaveSelector_wave_select_line_color, getResources().getColor(R.color.colorSelectLine));\n        mSelectLineOnLimitColor = attributes.getColor(R.styleable.WaveSelector_wave_select_line_on_limit_color, getResources().getColor(R.color.colorSelectLine));\n        mSelectPaint.setColor(mSelectLineColor);\n        mSelectPaint.setStrokeWidth(2 * density);\n\n        mArgbEvaluator = new ArgbEvaluator();\n\n        // color.\n        mPlayingStartColor = attributes.getColor(R.styleable.WaveSelector_wave_playing_color_start_color, getResources().getColor(R.color.colorWavePlayed));\n        mPlayingEndColor = attributes.getColor(R.styleable.WaveSelector_wave_playing_color_end_color, getResources().getColor(R.color.colorWavePlayed));\n\n        // padding.\n        mWavePaddingTop = (int) attributes.getDimension(R.styleable.WaveSelector_wave_padding_top, 20 * density);\n        mWavePaddingBottom = (int) attributes.getDimension(R.styleable.WaveSelector_wave_padding_bottom, 30 * density);\n\n        attributes.recycle();\n    }\n\n    private void init() {\n        getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {\n            boolean onPreDrawNotify = true;\n\n            @Override\n            public boolean onPreDraw() {\n                int testWidth = WaveSelector.this.getWidth();\n                if (testWidth <= 0) {\n                    if (onPreDrawNotify) {\n                        Log.e(TAG, \"onPreDraw() not initialized. return.\");\n                        onPreDrawNotify = false;\n                    }\n                    return true;\n                }\n                WaveSelector.this.getViewTreeObserver().removeOnPreDrawListener(this);\n                mIsOnPreDraw = true;\n                mFullWidth = WaveSelector.this.getWidth();\n                mFullHeight = WaveSelector.this.getHeight();\n                mPaddingPix = mFullWidth / 2;\n\n                mWaveSize = mFullWidth * 1.0f / mWavePageCount / 2;\n                mWaveSpace = mWaveSize;\n\n                mPIX_PER_SECOND = mFullWidth * 1.0f / mFullWidthTrackDuration;\n                SizeConvertAdapter.init(mPIX_PER_SECOND);\n                mConvertAdapter = SizeConvertAdapter.getInstance();\n\n                Log.d(TAG, \"onPreDraw() called mFullWidth:\" + mFullWidth + \", mFullHeight:\" + mFullHeight);\n\n                callOnReady();\n\n                return true;\n            }\n        });\n\n    }\n\n    private void callOnReady() {\n        if (mInited && mIsOnPreDraw) {\n            post(new Runnable() {\n                @Override\n                public void run() {\n                    if (mAutoSeekTo > 0) {\n                        seekTo(mAutoSeekTo);\n                    }\n\n                    if (mListener != null) {\n                        mListener.onReady();\n                    }\n                }\n            });\n        }\n    }\n\n    private void callOnLimit() {\n        Log.v(TAG, \"callOnLimit() called\");\n        mIsLimiting = true;\n        if (mInited && mIsOnPreDraw) {\n            if (mListener != null) {\n                mListener.onLimit();\n            }\n        }\n    }\n\n    /**\n     * \u6e05\u7a7a\u6570\u636e\u548c\u72b6\u6001\n     */\n    public void dispose() {\n        Log.i(TAG, \"dispose().\");\n        clearHighLight();\n        mData.clear();\n        mInited = false;\n//        mScroll.setFinalX(0);\n        SizeConvertAdapter.dispose();\n    }\n\n    /////////////////////////////////////////////////////////\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (!mInited) return;\n\n        if (mWaveSize <= 0) {\n            Log.e(TAG, \"skip to. mWaveWidth error.\" + mWaveSize);\n            return;\n        }\n\n        if (mMaxScrollX > 0 && !isAvailed(mCurrentLeft)/*x >= mMaxScrollX || x < 0*/) {\n            Log.e(TAG, \"skip to. mMaxScrollX error.\" + \"x:\" + mCurrentLeft + \", max:\" + mMaxScrollX);\n            mCurrentLeft = mLastAvailableLeft;\n        }\n\n        doDraw(canvas);\n\n        super.onDraw(canvas);\n    }\n\n    private void doDraw(Canvas canvas) {\n        int offSet = (int) ((mCurrentLeft - mPaddingPix) % (mWaveSpace + mWaveSize));\n        mLastAvailableLeft = mCurrentLeft;\n\n        ConcurrentLinkedQueue<Volume> careData = getCurrentPageData();\n        Iterator<Volume> it = careData.iterator();\n        int index = 0;\n        while (it.hasNext()) {\n            // draw volume.\n            Volume dt = it.next();\n            float left = index * (mWaveSpace + mWaveSize);\n            if (mCurrentLeft <= mPaddingPix) {\n                left += (mPaddingPix - mCurrentLeft);\n            } else {\n                left -= offSet;\n            }\n\n            if (left > mFullWidth) break;\n\n            float right = left + mWaveSpace;\n            float height = dt.percent * (mFullHeight - mWavePaddingTop - mWavePaddingBottom);\n            float top = mFullHeight / 2 - height / 2;\n            float bottom = mFullHeight / 2 + height / 2;\n            float corner = 2 * density;\n\n            if (left < 0) {\n                left = 0;\n            }\n            mRectVolume.set(left, top, right, bottom);\n            if (left >= mHighLightStartPos - mWaveSize && right <= mHighLightProgressPos + mWaveSize) {\n                // \u5f53\u524d\u6ce2\u5f62\u6761\u6e10\u53d8\u8272\n                int mCurrentPlayingColor = getCurrentWaveColor((left - mHighLightStartPos) / (mHighLightEndPos - mHighLightStartPos));\n                mWavePlayingPaint.setColor(mCurrentPlayingColor);\n                canvas.drawRoundRect(mRectVolume, corner, corner, mWavePlayingPaint);\n            } else {\n                canvas.drawRoundRect(mRectVolume, corner, corner, mWavePaint);\n            }\n\n            index++;\n        }\n\n        // draw select line.\n        mSelectPaint.setColor(mIsLimiting ? mSelectLineOnLimitColor : mSelectLineColor);\n        canvas.drawLine(mFullWidth / 2, 0, mFullWidth / 2, mFullHeight, mSelectPaint);\n    }\n\n    /**\n     * \u901a\u8fc7\u8d77\u6b62\u8272\u8ba1\u7b97\u5f53\u524d\u8981\u7ed8\u5236\u7684\u6ce2\u5f62\u8272\n     *\n     * @param percent \u8fdb\u5ea6\u767e\u5206\u6bd4\n     * @return \u989c\u8272\n     */\n    private int getCurrentWaveColor(float percent) {\n//        Log.d(TAG, \"getCurrentWaveColor() called with: percent = [\" + percent + \"]\");\n        return (int) mArgbEvaluator.evaluate(percent, mPlayingStartColor, mPlayingEndColor);\n    }\n\n    /////////////////////////////////////////////////////////\n    public void startHighLight() {\n        if (!mInited) return;\n        if (mPlayDuration <= 0) return;\n        int start = mPaddingPix;\n        int end = Math.round(start + mConvertAdapter.getPixByTime(mPlayDuration));\n        startHighLight(start, end);\n    }\n\n    public void startHighLight(float left, float end) {\n        Log.w(TAG, \"startHighLight. left:\" + left + \", end:\" + end);\n        if (!mInited) return;\n        mHighLightEndPos = end;\n        mHighLightStartPos = left;\n        mHighLightProgressPos = left;\n        if (isProgressing) return;\n\n        Log.i(TAG, \"startHighLight......\");\n        timer = new Timer();\n        timerTask = new TimerTask() {\n            @Override\n            public void run() {\n                if (mHighLightProgressPos <= mHighLightEndPos) {\n                    mHighLightProgressPos += mConvertAdapter.getPixByTime(TIMER_TRIGGER);//EVALUATOR_STEP;\n                } else {\n                    // \u5faa\u73af\u64ad\u653e\u542f\u7528\n                    //mHighLightProgressPos = mHighLightStartPos;\n\n                    // \u5355\u6b21\u64ad\u653e\u542f\u7528\n                    stopHighLight();\n                }\n\n                postInvalidate();\n            }\n        };\n\n        isProgressing = true;\n        timer.schedule(timerTask, 0, TIMER_TRIGGER);\n    }\n\n    public void resumeHighLight() {\n        if (!mInited) return;\n        Log.d(TAG, \"resumeHighLight() called\");\n        float current = mHighLightProgressPos - mPaddingPix;\n        startHighLight();\n        seekHighLight(current);\n    }\n\n    private void seekHighLight(float seekPos) {\n        if (!mInited) return;\n        seekPos += mPaddingPix;\n        Log.i(TAG, \"seekHighLight() ... pos:\" + seekPos);\n        if (seekPos + 50 >= mHighLightStartPos && seekPos - 50 <= mHighLightEndPos) {// 50\u4e3a\u5141\u8bb8\u7684\u8bef\u5dee\u503c\uff0ceg left720.0, start719.992 ...\n            mHighLightProgressPos = seekPos;\n            Log.v(TAG, \"................\" + mHighLightProgressPos);\n            postInvalidate();\n        }\n    }\n\n    public void seekHighLightToTime(int ts) {\n        if (!mInited) return;\n        Log.d(TAG, \"seekHighLightToTime() called with: ts = [\" + ts + \"]\");\n        seekHighLight(mConvertAdapter.getPixByTime(ts) - mLastPageStart);\n    }\n\n    protected void clearHighLight() {\n//        mHighLightEndPos = 0;\n//        mHighLightStartPos = 0;\n//        mHighLightProgressPos = 0;\n        mHighLightProgressPos = mHighLightStartPos;\n\n        stopHighLight();\n    }\n\n    public void stopHighLight() {\n        isProgressing = false;\n\n        if (this.timerTask != null) {\n            this.timerTask.cancel();\n            this.timerTask = null;\n        }\n\n        if (this.timer != null) {\n            this.timer.cancel();\n            this.timer = null;\n        }\n\n//        post(new Runnable() {\n//            @Override\n//            public void run() {\n////                mValueAnimator.cancel();\n//            }\n//        });\n    }\n\n    /////////////////////////////////////////////////////////\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n//        Log.v(TAG, \"onTouchEvent.\" + event.getAction() + \" x:\" + event.getX() + \", y:\" + event.getY() + \" --> \" + mCurrentLeft);\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain();\n        }\n        mVelocityTracker.addMovement(event);\n\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                if (!mScroll.isFinished()) {\n                    mScroll.abortAnimation();\n                }\n                mLastX = event.getX();\n                mLastDownX = mLastX;\n                mIsDragging = true;\n\n                return true;\n\n            case MotionEvent.ACTION_MOVE:\n                float moveDiff = event.getX() - mLastX;\n                mCurrentLeft -= moveDiff;// \u53cd\u5411\u6eda\u52a8\n                mLastX = event.getX();\n                if (moveDiff >= MIN_MOVE_DISTANCE) {\n                    mDragDirection = Direction_RIGHT;\n                } else if (moveDiff < -MIN_MOVE_DISTANCE) {\n                    mDragDirection = Direction_LEFT;\n                } else {\n                    mDragDirection = Direction_UNKNOWN;\n                }\n\n                if (Math.abs(mLastX - mLastDownX) > MIN_MOVE_DISTANCE/* || mCurrentLeft <= MIN_MOVE_DISTANCE*/) {\n                    clearHighLight();\n                    callbackScrolling();\n                }\n\n//                if (!isAvailed(mCurrentLeft)) {\n                if (mMaxScrollX > 0 && mCurrentLeft > mMaxScrollX) {\n                    callOnLimit();\n                }\n\n                break;\n            case MotionEvent.ACTION_UP:\n                mCurrentLeft -= event.getX() - mLastX;// \u53cd\u5411\u6eda\u52a8\n                mLastX = event.getX();\n                   /*mScroll.startScroll(mScroll.getCurrX(), 0, (int) (mScroll.getCurrX() - mCurrentLeft), 0, 0);\n                   mIsDragging = false;*/\n\n                if (mVelocityTracker != null) {\n                    mVelocityTracker.computeCurrentVelocity(mScrollingVelocity);\n                    int xVelocity = -(int) mVelocityTracker.getXVelocity();// \u53cd\u5411\u6eda\u52a8\n                    int maxEndX = getMaxEndX();\n                    int minStartX = 0;//mLeftPadding;// todo \u5934\u90e8\u88ab\u62b9\u6389\u4e862s, 181117 <--\u770b\u4e0d\u61c2\u4e86\uff0c2s\u8fd9\u662f\u5565?\n                    mScroll.forceFinished(true);\n                    Log.e(TAG, \"mCurrentLeft:\" + mCurrentLeft + \", xVelocity:\" + xVelocity);\n                    mScroll.fling((int) mCurrentLeft, 0, xVelocity, 0,\n                            minStartX, maxEndX, 0, 0);\n\n                    mVelocityTracker.recycle();\n                    mVelocityTracker = null;\n\n                }\n//                callbackScroll();\n                if (mCurrentLeft <= MIN_MOVE_DISTANCE) {\n//                    callbackScroll();// \u8fd9\u91cc\u9996\u6b21\u4f1a\u8bef\u89e6\u4e00\u6b210\n                }\n                mIsDragging = false;\n                break;\n            case MotionEvent.ACTION_CANCEL:\n                   /*if (mVelocityTracker != null) {\n                       mVelocityTracker.recycle();\n                       mVelocityTracker = null;\n                       mIsDragging = false;\n                   }*/\n                callbackScroll();\n                mIsDragging = false;\n                break;\n        }\n\n        mCurrentLeft = Math.max(0, mCurrentLeft);\n        postInvalidate();\n//        Log.v(TAG, \"onTouchEvent.\" + event.getAction() + \" x:\" + event.getX() + \", y:\" + event.getY() + \" ==> \" + mCurrentLeft);\n\n        return super.onTouchEvent(event);\n    }\n\n    protected int getMaxEndX() {\n        return Math.round(Math.min(Integer.MAX_VALUE, mData.size() * (mWaveSize + mWaveSpace) + mPaddingPix * 2 /*- mRightPadding*/));\n    }\n\n    /**\n     * mCurrentLeft will modify after fling.\n     *\n     * @see #onTouchEvent(MotionEvent) case MotionEvent.ACTION_UP\n     */\n    @Override\n    public void computeScroll() {\n//        Log.d(TAG, \"computeScroll() called\" + mCurrentLeft);\n\n        if (mScroll.computeScrollOffset()) {\n            int tmp2 = mScroll.getCurrX();\n            if (isAvailed(tmp2)) {\n                mCurrentLeft = tmp2 / SCROLL_SENSITIVITY;\n            } else {\n                mScroll.forceFinished(true);\n            }\n            postInvalidate();\n            mLastScrollEndTS = System.currentTimeMillis();\n\n            int tmp = mScroll.getCurrX();\n            if (mLastCurrX != tmp) {\n                callbackScrolling();\n            }\n        } else {\n            int tmp = mScroll.getCurrX();\n            if (mLastCurrX != tmp) {\n                if (mLastScrollEndTS > 0 && System.currentTimeMillis() - mLastScrollEndTS < 100) {\n                    Log.w(TAG, \"...........fling end......\");\n                    // fix position after a quick fling.\n                    mCurrentLeft = tmp / SCROLL_SENSITIVITY;\n                    if (!mIgnoreCallBack) {\n                        Log.e(TAG, \"ignore current callBack()...\");\n                        callbackScroll();\n                    }\n\n                    mIgnoreCallBack = false;\n                }\n                mLastCurrX = tmp / SCROLL_SENSITIVITY;\n            }\n        }\n    }\n\n    private void callbackScroll() {\n        Log.d(TAG, \"callbackScroll() called\" + \" ... \" + mCurrentLeft);\n        mIsLimiting = false;\n        if (mListener != null && mLastPageStart != mCurrentLeft || mCurrentLeft == 0) {// 0\u6700\u5de6\u7aef\uff0c\u4e5f\u9700\u8981\u89e6\u53d1onSelect\uff0c\u8fd9\u91cchack\u4e00\u4e0b\u5427\u3002\u3002\n            mLastPageStart = mCurrentLeft;\n            mLastScrollingPageStart = mCurrentLeft;\n            long ts = mConvertAdapter.getTimeByPix(mCurrentLeft);\n            mListener.onSelect(ts);\n        }\n    }\n\n    private void callbackScrolling() {\n//        Log.v(TAG, \"callbackScrolling() called\");\n        if (mListener != null /*&& mLastPageStart != mCurrentLeft*/ && smoothScrollValid()) {\n//            mLastPageStart = mCurrentLeft;\n            long ts = mConvertAdapter.getTimeByPix(mCurrentLeft);\n            mListener.onChanging(ts);\n        }\n    }\n\n    private boolean smoothScrollValid() {\n        boolean ret = false;\n        if (mSmoothScrollEnable) {\n//            long tsLast = mConvertAdapter.getTimeByPix(mLastScrollingPageStart);\n//            long tsNow = mConvertAdapter.getTimeByPix(mCurrentLeft);\n//            Log.v(TAG, \"N:\" + tsNow + \", L:\" + tsLast);\n            if (mDragDirection == Direction_LEFT) {\n                ret = mCurrentLeft >= mLastScrollingPageStart;\n            } else if (mDragDirection == Direction_RIGHT) {\n                ret = mCurrentLeft <= mLastScrollingPageStart;\n            } else {\n//                ret = true;\n            }\n        }\n\n        mLastScrollingPageStart = mCurrentLeft;\n\n        return ret;\n    }\n\n    private ConcurrentLinkedQueue<Volume> getCurrentPageData() {\n        int index = (int) ((mCurrentLeft - mPaddingPix) / (mWaveSize + mWaveSpace));\n//        Log.v(TAG, \"left:\" + mCurrentLeft + \", idx:\" + index);\n        // \u5f53\u524d\u9875\u7684\u6570\u91cf\n        int pageMax = Math.min(mData.size(), mWavePageCount + 1);\n        // \u6700\u540e\u4e00\u9875\u7684\u5f00\u59cb\u6570\u636eindex\n        int lastPageIndex = (int) (mData.size() - pageMax + (mPaddingPix / (mWaveSize + mWaveSpace)));\n\n        if (index < 0) index = 0;\n        if (index > lastPageIndex) index = lastPageIndex;\n\n        // \u6700\u540e\u4e00\u9875\u5f00\u59cb\u7684\u6eda\u52a8\u4f4d\u7f6e\n        mMaxScrollX = (int) ((mWaveSize + mWaveSpace) * lastPageIndex) + mPaddingPix;\n        mMaxScrollX = Math.max(0, mMaxScrollX - mConvertAdapter.getPixByTime(mDefaultLimitSelectTime));\n\n        ConcurrentLinkedQueue<Volume> currentPageData = new ConcurrentLinkedQueue<>();\n        List<Volume> subList = mData.subList(index, Math.min(index + pageMax, mData.size() - 1));\n        currentPageData.addAll(subList);\n\n        return currentPageData;\n    }\n\n    boolean isAvailed(float currentX) {\n        return currentX <= mMaxScrollX/* - mRightPadding*/ && currentX >= 0;// + mLeftPadding;\n    }\n\n    /////////////////////////////////////////////////////////\n\n    /**\n     * \u8bbe\u7f6e\u6ce2\u5f62\u6570\u636e\n     *\n     * @param ll \u6570\u636e\n     */\n    public void setData(List<Integer> ll) {\n        Log.d(TAG, \"setData()\");\n        if (ll == null) return;\n\n//        Log.v(TAG, \"setData() called with: ll = [\" + ll.subList(0, Math.min(ll.size(), 10)) + \"]...\" + \", mInited:\" + mInited);\n        if (mInited) {\n            Log.e(TAG, \"setData(). already inited. ignore...\");\n            return;\n        }\n\n        mInited = true;\n        for (int i = 0; i < ll.size(); i++) {\n            mData.add(new Volume(ll.get(i)));\n        }\n\n        invalidate();\n\n        callOnReady();\n\n    }\n\n    /**\n     * \u5237\u65b0\u6ce2\u5f62\u7684\u6570\u636e\uff0c\u4e0d\u89e6\u53d1\u5404\u79cd\u56de\u8c03\n     *\n     * @param ll \u6570\u636e\n     */\n    public void refreshData(List<Integer> ll) {\n        Log.d(TAG, \"refreshData() called with: ll = [\" + ll + \"]\");\n        if (ll == null) return;\n\n        if (!mInited) {\n            Log.e(TAG, \"refreshData(). not inited. ignore...\");\n            return;\n        }\n\n        mData.clear();\n        for (int i = 0; i < ll.size(); i++) {\n            mData.add(new Volume(ll.get(i)));\n        }\n\n        invalidate();\n    }\n\n    /**\n     * \u4ecestart\u4f4d\u7f6e\u5f00\u59cb\n     *\n     * @param start start\n     */\n    public void seekTo(int start) {\n        Log.d(TAG, \"seekTo() called with: start time = [\" + start + \"] , from pos = [\" + mCurrentLeft + \"]\");\n        if (mInited && mIsOnPreDraw) {\n            Log.d(TAG, \"scrollTo... to:\" + start);\n\n//            mCurrentLeft =  mScroll.getFinalX();\n//            mScroll.fling((int) mCurrentLeft, 0, 11, 0,\n//                    0, getMaxEndX(), 0, 0);\n//            mScroll.startScroll(mCurrentLeft, 0, (int) mConvertAdapter.getPixByTime(start) - mCurrentLeft, 0, 0);\n//            MotionEvent.obtain(0, System.currentTimeMillis(), MotionEvent.ACTION_SCROLL,\n//                           1, pointerProperties, pointerCoords, 0, 0, xPrecision, yPrecision, deviceId,\n//                           edgeFlags, inputDevice, flags);\n//               }\n            if (mVelocityTracker == null) {\n                setSimulateClick(this, 0, 0);\n            }\n\n            int lastCurrentX = mCurrentLeft;\n            int newCurrentX = Math.round(mConvertAdapter.getPixByTime(start));\n\n            mScroll.setFinalX(newCurrentX);\n            if (lastCurrentX == newCurrentX) {// \u8fd9\u79cd\u4e24\u6b21\u76f8\u540c\u7684\u573a\u666f\u5f97\u5f3a\u5236\u89e6\u53d1\u4e00\u6b21callbackScroll\n                callbackScroll();\n            }\n        } else {\n            mAutoSeekTo = start;\n            Log.d(TAG, \"seekTo later... to:\" + start);\n        }\n    }\n\n    /**\n     * hack \u65b9\u6cd5\uff0c\u6a21\u62df\u4e00\u6b21\u70b9\u51fb\uff0c\u9632\u6b62\u9996\u6b21seek\u65e0\u6548\n     *\n     * @param view v\n     * @param x    x\n     * @param y    y\n     */\n    private void setSimulateClick(View view, float x, float y) {\n        Log.d(TAG, \"setSimulateClick() called with: view = [\" + view + \"], x = [\" + x + \"], y = [\" + y + \"]\");\n        long downTime = SystemClock.uptimeMillis();\n        final MotionEvent downEvent = MotionEvent.obtain(downTime, downTime,\n                MotionEvent.ACTION_DOWN, x, y, 0);\n        downTime += 1;\n        final MotionEvent upEvent = MotionEvent.obtain(downTime, downTime,\n                MotionEvent.ACTION_UP, x, y, 0);\n        view.onTouchEvent(downEvent);\n        view.onTouchEvent(upEvent);\n        downEvent.recycle();\n        upEvent.recycle();\n    }\n\n\n    /**\n     * \u8bbe\u7f6e\u622a\u53d6\u65f6\u957f\n     *\n     * @param duration \u622a\u53d6\u65f6\u957f\n     */\n    public void setPlayDuration(int duration) {\n        boolean showLog = duration != mLastDuration;\n        if (showLog) {\n            Log.d(TAG, \"setPlayDuration() called with: duration = [\" + duration + \"]\");\n        }\n        mLastDuration = duration;\n        mPlayDuration = duration;\n        if (isProgressing) {\n            int start = mPaddingPix;\n            mHighLightEndPos = Math.round(start + mConvertAdapter.getPixByTime(mPlayDuration));\n            if (showLog) {\n                Log.w(TAG, \"setPlayDuration, already progressing, refresh mHighLightEndPos:\" + mHighLightEndPos);\n            }\n        }\n    }\n\n    public int getPlayDuration() {\n        return mDragDirection;\n    }\n\n    /**\n     * \u6700\u5c11\u9009\u62e9\u65f6\u95f4\uff0c\u6ce2\u5f62\u6ed1\u52a8\u503c\u6700\u5c0f\u65f6\u957f\u65f6\u4f1a\u505c\u4f4f\n     *\n     * @param timeSpan \u65f6\u957f\n     */\n    public void setLimitedSelectTime(int timeSpan) {\n        Log.d(TAG, \"setLimitedSelectTime: \" + timeSpan);\n        mDefaultLimitSelectTime = timeSpan;\n    }\n\n    /////////////////////////////////////////////////////////\n    public interface IWaveSelectorListener {\n        void onChanging(long timeStart);\n\n        void onSelect(long timeStart);\n\n        void onReady();\n\n        void onLimit();\n    }\n\n    public void setListener(IWaveSelectorListener listener) {\n        this.mListener = listener;\n    }\n\n    /////////////////////////////////////////////////////////\n    public static class Volume {\n        public final int vol;\n        private final float percent;\n\n        public Volume(int vol) {\n            this.vol = vol;\n            this.percent = Math.max(0.05f, vol * 1.0f / 65536);// \u6700\u4f4e5%\uff0c\u4e0d\u8981\u8ba9\u6ce2\u5f62\u56fe\u7a7a\u7740\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(vol);\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    public static class SizeConvertAdapter {\n        float mPixPerSec;\n\n        public static SizeConvertAdapter instance;\n\n        public SizeConvertAdapter(float pixPerSec) {\n            mPixPerSec = pixPerSec;\n        }\n\n        public static void init(float pixPerSec) {\n            if (instance != null) Log.e(TAG, \"help already initialized.\");\n            instance = new SizeConvertAdapter(pixPerSec);\n        }\n\n        public static void dispose() {\n            instance = null;\n        }\n\n        private static SizeConvertAdapter getInstance() {\n            if (instance == null) throw new IllegalArgumentException(\"help must init() first.\");\n            return instance;\n        }\n\n        public float getPixByTime(int time) {\n            return mPixPerSec * time;\n        }\n\n        public long getTimeByPix(long currentLeft) {\n            return (long) (currentLeft / mPixPerSec);\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    public static class Config {\n        public int halfWaveCount;\n        public int wavePaddingTop;\n        public int wavePaddingBottom;\n    }\n\n    /////////////////////////////////////////////////////////\n\n    /**\n     * \u8ba1\u7b97\u91c7\u6837\u70b9\u5bc6\u5ea6\n     *\n     * @param rate               \u7801\u7387\uff0c\u901a\u5e38\u4e3a44100\n     * @param drawPointCount     \u6ee1\u5c4f\u7ed8\u5236\u70b9\u6570\n     * @param drawDurationSecond \u6ee1\u5c4f\u65f6\u957f\n     * @return \u91c7\u6837\u5bc6\u5ea6\n     */\n    public static int calcSampleStep(int rate, int drawPointCount, int drawDurationSecond) {\n        float k = 1000.0F / rate * 1024;\n        float m = 1000.0F / k;\n        float d = 1.0f * drawPointCount / drawDurationSecond;\n        float s = m / d;\n        return Math.round(s);\n    }\n}\n"},
{"Line": "=>72", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["org.maas.agents.JSONObject.getString(java.lang.String)"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if ((boxDatabase.get(orderID)) != null) { for (int i = 0; i < (boxDatabase.get(orderID).length()); i++) { boxes.put(boxDatabase.get(orderID).getJSONObject(i)); } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/626/buggy-version/src.main.java.org.maas.agents.LoadingBayAgent.java", "BodyUseAPI": ["boxDatabase.get(orderID).length()", "org.maas.agents.JSONArray.put(boxDatabase.get(orderID).getJSONObject(i))", "boxDatabase.get(orderID).getJSONObject(int)", "java.util.HashMap<java.lang.String, org.maas.agents.JSONArray>.get(java.lang.String)", "java.util.HashMap<java.lang.String, org.maas.agents.JSONArray>.get(java.lang.String)"], "Fixed commit": "92c4b89b1e55e8065b0bbfb9ee5685b5e6d5b2b8", "Url": "https://api.github.com/repos/HBRS-MAAS/ws18-project-commitment_issues", "Date": "2018-12-13T11:34:36Z", "Source Code Diff": "@@ -18,15 +18,14 @@ public class LoadingBayAgent extends BaseAgent {\n \tprivate JSONArray orderDetailsArray = new JSONArray();\n \tprivate String readyOrderID = null;\n \n-\tprivate HashMap<String, HashMap<String, Integer>> productDatabase = \n-\t\t\tnew HashMap<>();\n+\tprivate HashMap<String, HashMap<String, Integer>> productDatabase = new HashMap<>();\n \tprivate HashMap<String, JSONArray> boxDatabase = new HashMap<>();\n \n \tprotected void setup() {\n \t\tsuper.setup();\n-\t\tSystem.out.println(\"Hello! LoadingBay-agent \"+getAID().getName()+\" is ready.\");\n+\t\tSystem.out.println(\"Hello! LoadingBay-agent \" + getAID().getName() + \" is ready.\");\n \n-\t\tregister(\"loading-bay\", \"loading-bay\");\t\n+\t\tregister(\"loading-bay\", \"loading-bay\");\n \n \t\taddBehaviour(new OrderDetailsReceiver());\n \t\taddBehaviour(new ProductDetailsReceiver());\n@@ -38,56 +37,66 @@ protected void takeDown() {\n \t\tSystem.out.println(getAID().getLocalName() + \": Terminating.\");\n \t}\n \n-\tprotected void addCustomerOrder (String orderID, String product, int quantity) {\n-\t\tHashMap <String, Integer> temp = new HashMap<String, Integer>();\n+\tprotected void addCustomerOrder(String orderID, String product, int quantity) {\n+\t\tHashMap<String, Integer> temp = new HashMap<String, Integer>();\n \t\ttemp.put(product, quantity);\n \t\tthis.productDatabase.put(orderID, temp);\n \t}\n \n-\tprotected void addCustomerProduct (String orderID, String product, int quantity) {\n-\t\tHashMap <String, Integer> temp = new HashMap<String, Integer>();\n+\tprotected void addCustomerProduct(String orderID, String product, int quantity) {\n+\t\tHashMap<String, Integer> temp = new HashMap<String, Integer>();\n \t\ttemp.put(product, quantity);\n \t\tthis.productDatabase.get(orderID).put(product, quantity);\n \t}\n \n-\tprotected void UpdateCustomerProductQuantity (String orderID, String product, int addedQuantity) {\n+\tprotected void UpdateCustomerProductQuantity(String orderID, String product, int addedQuantity) {\n \t\tint oldQuantity = this.productDatabase.get(orderID).get(product);\n \t\tint newQuantity = oldQuantity + addedQuantity;\n \t\tthis.productDatabase.get(orderID).replace(product, newQuantity);\n \t}\n \n-\tprotected String createOrderBoxesJSONMessage (String orderID) {\n+\tprotected String createOrderBoxesJSONMessage(String orderID) {\n \t\tJSONObject message = new JSONObject();\n-\t\tmessage.put(\"OrderID\", orderID);\t\t\n+\t\tmessage.put(\"OrderID\", orderID);\n \t\tmessage.put(\"Boxes\", this.boxDatabase.get(orderID));\n \n \t\treturn message.toString();\n \t}\n \n-\tprotected void updateBoxDatabase (String orderBoxesDetails) {\n+\tprotected void updateBoxDatabase(String orderBoxesDetails) {\n \t\tJSONObject JSONData = new JSONObject(orderBoxesDetails);\n \n \t\tString orderID = JSONData.getString(\"OrderID\");\n \t\tJSONArray boxes = JSONData.getJSONArray(\"Boxes\");\n \n+\t\tif (boxDatabase.get(orderID) != null) {\n+\t\t\tfor (int i = 0; i < boxDatabase.get(orderID).length(); i++) {\n+\t\t\t\tboxes.put(boxDatabase.get(orderID).getJSONObject(i));\n+\t\t\t}\n+\t\t}\n+\n \t\tthis.boxDatabase.put(orderID, boxes);\n \t}\n \n-\tprotected void updateProductDatabase (String orderBoxesDetails) {\n+\tprotected void updateProductDatabase(String orderBoxesDetails) {\n \t\tJSONObject JSONData = new JSONObject(orderBoxesDetails);\n \n \t\tString orderID = JSONData.getString(\"OrderID\");\n \t\tJSONArray boxes = JSONData.getJSONArray(\"Boxes\");\n \n \t\t// Check if the database does not contain this order's details\n \t\tif (!this.productDatabase.containsKey(orderID)) {\n-\t\t\tfor (int i = 0 ; i < boxes.length(); i++) {\n+\t\t\tfor (int i = 0; i < boxes.length(); i++) {\n \t\t\t\tJSONObject boxDetails = boxes.getJSONObject(i);\n-\t\t\t\tif (i == 0) {\n+\t\t\t\tif (!productDatabase.containsKey(orderID)) {\n \t\t\t\t\taddCustomerOrder(orderID, boxDetails.getString(\"ProductType\"), boxDetails.getInt(\"Quantity\"));\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\taddCustomerProduct(orderID, boxDetails.getString(\"ProductType\"), boxDetails.getInt(\"Quantity\"));\n+\t\t\t\t} else {\n+\t\t\t\t\tString productType = boxDetails.getString(\"ProductType\");\n+\t\t\t\t\tif (productDatabase.get(orderID).containsKey(productType)) {\n+\t\t\t\t\t\tUpdateCustomerProductQuantity(orderID, productType, boxDetails.getInt(\"Quantity\"));\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\taddCustomerProduct(orderID, productType, boxDetails.getInt(\"Quantity\"));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -96,14 +105,15 @@ protected void updateProductDatabase (String orderBoxesDetails) {\n \t\t\t// Get the product details currently associated with and stored for this orderID\n \t\t\tHashMap<String, Integer> orderProductDetails = this.productDatabase.get(orderID);\n \n-\t\t\tfor (int i = 0 ; i < boxes.length(); i++) {\n+\t\t\tfor (int i = 0; i < boxes.length(); i++) {\n \t\t\t\tJSONObject boxDetails = boxes.getJSONObject(i);\n \t\t\t\tString productType = boxDetails.getString(\"ProductType\");\n \n-\t\t\t\t// If the order entry in the database already has this product in a certain quantity:\n+\t\t\t\t// If the order entry in the database already has this product in a certain\n+\t\t\t\t// quantity:\n \t\t\t\tif (orderProductDetails.containsKey(productType)) {\n \t\t\t\t\t// Update that entry with the additional quantity of that product\n-\t\t\t\t\tUpdateCustomerProductQuantity (orderID, productType, boxDetails.getInt(\"Quantity\"));\n+\t\t\t\t\tUpdateCustomerProductQuantity(orderID, productType, boxDetails.getInt(\"Quantity\"));\n \t\t\t\t}\n \t\t\t\t// if it doesn't, simply add it to that order entry's product list:\n \t\t\t\telse {\n@@ -113,7 +123,7 @@ protected void updateProductDatabase (String orderBoxesDetails) {\n \t\t}\n \t}\n \n-\tprotected boolean orderProductsReady (String orderID) {\n+\tprotected boolean orderProductsReady(String orderID) {\n \t\t/*\n \t\t * Returns true if the order details (products and their quantities) are\n \t\t * fulfilled in the database for that particular customer order.\n@@ -124,7 +134,7 @@ protected boolean orderProductsReady (String orderID) {\n \t\tJSONObject productsObject = new JSONObject();\n \t\tString IDCheckString = null;\n \n-\t\tfor (int i = 0 ; i < this.orderDetailsArray.length(); i++) {\n+\t\tfor (int i = 0; i < this.orderDetailsArray.length(); i++) {\n \t\t\tJSONObject orderData = this.orderDetailsArray.getJSONObject(i);\n \n \t\t\tif (orderID.equals(orderData.getString(\"OrderID\"))) {\n@@ -135,7 +145,8 @@ protected boolean orderProductsReady (String orderID) {\n \t\t}\n \n \t\tif (IDCheckString.equals(null)) {\n-\t\t\tSystem.out.println(\"[\"+getAID().getLocalName()+\"]: ERROR: OrderID not found in this.orderDetailsArray \");\n+\t\t\tSystem.out\n+\t\t\t\t\t.println(\"[\" + getAID().getLocalName() + \"]: ERROR: OrderID not found in this.orderDetailsArray \");\n \t\t}\n \n \t\tfor (String productName : productsObject.keySet()) {\n@@ -158,7 +169,7 @@ private class TimeUpdater extends CyclicBehaviour {\n \t\tpublic void action() {\n \t\t\tif (getAllowAction()) {\n \t\t\t\tfinished();\n-\t\t\t} \n+\t\t\t}\n \t\t}\n \t}\n \n@@ -175,7 +186,7 @@ protected void findReceiver() {\n \t\t\t\treceivingAgent = result[0].getName();\n \n \t\t\t} catch (FIPAException fe) {\n-\t\t\t\tSystem.out.println(\"[\"+getAID().getLocalName()+\"]: No OrderAggregator agent found.\");\n+\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: No OrderAggregator agent found.\");\n \t\t\t\tfe.printStackTrace();\n \t\t\t}\n \t\t}\n@@ -185,14 +196,14 @@ public void action() {\n \n \t\t\tACLMessage msg = new ACLMessage(ACLMessage.INFORM);\n \n-\t\t\tmsg.addReceiver(receivingAgent); \n-\t\t\tmsg.setContent(createOrderBoxesJSONMessage(((LoadingBayAgent)baseAgent).readyOrderID));\n+\t\t\tmsg.addReceiver(receivingAgent);\n+\t\t\tmsg.setContent(createOrderBoxesJSONMessage(((LoadingBayAgent) baseAgent).readyOrderID));\n \t\t\tmsg.setConversationId(\"packaged-orders\");\n \t\t\tmsg.setPostTimeStamp(System.currentTimeMillis());\n \n \t\t\tmyAgent.send(msg);\n \n-\t\t\tSystem.out.println(\"[\"+getAID().getLocalName()+\"]: Order details sent to OrderAggregator\");\n+\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: Order details sent to OrderAggregator\");\n \t\t}\n \t}\n \n@@ -213,12 +224,11 @@ protected void findOrderProcessor() {\n \t\t\t\torderProcessor = result[0].getName();\n \n \t\t\t} catch (FIPAException fe) {\n-\t\t\t\tSystem.out.println(\"[\"+getAID().getLocalName()+\"]: No OrderProcessor agent found.\");\n+\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: No OrderProcessor agent found.\");\n \t\t\t\tfe.printStackTrace();\n \t\t\t}\n \t\t}\n \n-\n \t\tpublic void action() {\n \t\t\tfindOrderProcessor();\n \n@@ -228,14 +238,13 @@ public void action() {\n \n \t\t\tif (msg != null) {\n \t\t\t\t// If a single order is provided, in a message:\n-\t\t\t\t((LoadingBayAgent)baseAgent).orderDetailsArray.put(new JSONObject(msg.getContent()));\n+\t\t\t\t((LoadingBayAgent) baseAgent).orderDetailsArray.put(new JSONObject(msg.getContent()));\n \n \t\t\t\t// Enable this instead, if a list of orders is provided:\n \t\t\t\t/*\n-\t\t\t\t JSONArray messagethis.orderDetailsArray = new JSONArray(msg.getContent());\n-\t\t\t\t for (int i = 0 ; i < messagethis.orderDetailsArray.length() ; i++) {\n-\t\t\t\t\tthis.orderDetailsArray.put(messagethis.orderDetailsArray.get(i));\n-\t\t\t\t }\n+\t\t\t\t * JSONArray messagethis.orderDetailsArray = new JSONArray(msg.getContent());\n+\t\t\t\t * for (int i = 0 ; i < messagethis.orderDetailsArray.length() ; i++) {\n+\t\t\t\t * this.orderDetailsArray.put(messagethis.orderDetailsArray.get(i)); }\n \t\t\t\t */\n \t\t\t} else {\n \t\t\t\tblock();\n@@ -252,7 +261,8 @@ public void action() {\n \t\t\tACLMessage msg = myAgent.receive(mt);\n \n \t\t\tif (msg != null) {\n-\t\t\t\tSystem.out.println(\"[\"+getAID().getLocalName()+\"]: Received product boxes from \"+msg.getSender().getLocalName());\n+\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: Received product boxes from \"\n+\t\t\t\t\t\t+ msg.getSender().getLocalName());\n \n \t\t\t\t// This assumes a JSON object is sent by the preceding agent\n \t\t\t\tString boxesMessageContent = msg.getContent();\n@@ -264,7 +274,7 @@ public void action() {\n \t\t\t\tupdateProductDatabase(boxesMessageContent);\n \n \t\t\t\tif (orderProductsReady(orderID)) {\n-\t\t\t\t\t((LoadingBayAgent)baseAgent).readyOrderID = orderID;\n+\t\t\t\t\t((LoadingBayAgent) baseAgent).readyOrderID = orderID;\n \t\t\t\t\taddBehaviour(new PackagingPhaseMessageSender());\n \t\t\t\t}\n \t\t\t} else {", "Complete After Code": "package org.maas.agents;\n\nimport java.util.HashMap;\n\nimport org.json.*;\n\nimport jade.core.AID;\nimport jade.core.behaviours.*;\nimport jade.domain.DFService;\nimport jade.domain.FIPAException;\nimport jade.domain.FIPAAgentManagement.DFAgentDescription;\nimport jade.domain.FIPAAgentManagement.ServiceDescription;\nimport jade.lang.acl.ACLMessage;\nimport jade.lang.acl.MessageTemplate;\n\n@SuppressWarnings(\"serial\")\npublic class LoadingBayAgent extends BaseAgent {\n\tprivate JSONArray orderDetailsArray = new JSONArray();\n\tprivate String readyOrderID = null;\n\n\tprivate HashMap<String, HashMap<String, Integer>> productDatabase = new HashMap<>();\n\tprivate HashMap<String, JSONArray> boxDatabase = new HashMap<>();\n\n\tprotected void setup() {\n\t\tsuper.setup();\n\t\tSystem.out.println(\"Hello! LoadingBay-agent \" + getAID().getName() + \" is ready.\");\n\n\t\tregister(\"loading-bay\", \"loading-bay\");\n\n\t\taddBehaviour(new OrderDetailsReceiver());\n\t\taddBehaviour(new ProductDetailsReceiver());\n\t\taddBehaviour(new TimeUpdater());\n\t}\n\n\tprotected void takeDown() {\n\t\tdeRegister();\n\t\tSystem.out.println(getAID().getLocalName() + \": Terminating.\");\n\t}\n\n\tprotected void addCustomerOrder(String orderID, String product, int quantity) {\n\t\tHashMap<String, Integer> temp = new HashMap<String, Integer>();\n\t\ttemp.put(product, quantity);\n\t\tthis.productDatabase.put(orderID, temp);\n\t}\n\n\tprotected void addCustomerProduct(String orderID, String product, int quantity) {\n\t\tHashMap<String, Integer> temp = new HashMap<String, Integer>();\n\t\ttemp.put(product, quantity);\n\t\tthis.productDatabase.get(orderID).put(product, quantity);\n\t}\n\n\tprotected void UpdateCustomerProductQuantity(String orderID, String product, int addedQuantity) {\n\t\tint oldQuantity = this.productDatabase.get(orderID).get(product);\n\t\tint newQuantity = oldQuantity + addedQuantity;\n\t\tthis.productDatabase.get(orderID).replace(product, newQuantity);\n\t}\n\n\tprotected String createOrderBoxesJSONMessage(String orderID) {\n\t\tJSONObject message = new JSONObject();\n\t\tmessage.put(\"OrderID\", orderID);\n\t\tmessage.put(\"Boxes\", this.boxDatabase.get(orderID));\n\n\t\treturn message.toString();\n\t}\n\n\tprotected void updateBoxDatabase(String orderBoxesDetails) {\n\t\tJSONObject JSONData = new JSONObject(orderBoxesDetails);\n\n\t\tString orderID = JSONData.getString(\"OrderID\");\n\t\tJSONArray boxes = JSONData.getJSONArray(\"Boxes\");\n\n\t\tif (boxDatabase.get(orderID) != null) {\n\t\t\tfor (int i = 0; i < boxDatabase.get(orderID).length(); i++) {\n\t\t\t\tboxes.put(boxDatabase.get(orderID).getJSONObject(i));\n\t\t\t}\n\t\t}\n\n\t\tthis.boxDatabase.put(orderID, boxes);\n\t}\n\n\tprotected void updateProductDatabase(String orderBoxesDetails) {\n\t\tJSONObject JSONData = new JSONObject(orderBoxesDetails);\n\n\t\tString orderID = JSONData.getString(\"OrderID\");\n\t\tJSONArray boxes = JSONData.getJSONArray(\"Boxes\");\n\n\t\t// Check if the database does not contain this order's details\n\t\tif (!this.productDatabase.containsKey(orderID)) {\n\t\t\tfor (int i = 0; i < boxes.length(); i++) {\n\t\t\t\tJSONObject boxDetails = boxes.getJSONObject(i);\n\t\t\t\tif (!productDatabase.containsKey(orderID)) {\n\t\t\t\t\taddCustomerOrder(orderID, boxDetails.getString(\"ProductType\"), boxDetails.getInt(\"Quantity\"));\n\t\t\t\t} else {\n\t\t\t\t\tString productType = boxDetails.getString(\"ProductType\");\n\t\t\t\t\tif (productDatabase.get(orderID).containsKey(productType)) {\n\t\t\t\t\t\tUpdateCustomerProductQuantity(orderID, productType, boxDetails.getInt(\"Quantity\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddCustomerProduct(orderID, productType, boxDetails.getInt(\"Quantity\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// In the event that it does:\n\t\telse {\n\t\t\t// Get the product details currently associated with and stored for this orderID\n\t\t\tHashMap<String, Integer> orderProductDetails = this.productDatabase.get(orderID);\n\n\t\t\tfor (int i = 0; i < boxes.length(); i++) {\n\t\t\t\tJSONObject boxDetails = boxes.getJSONObject(i);\n\t\t\t\tString productType = boxDetails.getString(\"ProductType\");\n\n\t\t\t\t// If the order entry in the database already has this product in a certain\n\t\t\t\t// quantity:\n\t\t\t\tif (orderProductDetails.containsKey(productType)) {\n\t\t\t\t\t// Update that entry with the additional quantity of that product\n\t\t\t\t\tUpdateCustomerProductQuantity(orderID, productType, boxDetails.getInt(\"Quantity\"));\n\t\t\t\t}\n\t\t\t\t// if it doesn't, simply add it to that order entry's product list:\n\t\t\t\telse {\n\t\t\t\t\taddCustomerProduct(orderID, productType, boxDetails.getInt(\"Quantity\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected boolean orderProductsReady(String orderID) {\n\t\t/*\n\t\t * Returns true if the order details (products and their quantities) are\n\t\t * fulfilled in the database for that particular customer order.\n\t\t */\n\t\tint productQuantity = 0;\n\t\tHashMap<String, Integer> orderProductDetails = this.productDatabase.get(orderID);\n\n\t\tJSONObject productsObject = new JSONObject();\n\t\tString IDCheckString = null;\n\n\t\tfor (int i = 0; i < this.orderDetailsArray.length(); i++) {\n\t\t\tJSONObject orderData = this.orderDetailsArray.getJSONObject(i);\n\n\t\t\tif (orderID.equals(orderData.getString(\"OrderID\"))) {\n\t\t\t\tIDCheckString = orderData.getString(\"OrderID\");\n\t\t\t\tproductsObject = orderData.getJSONObject(\"Products\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (IDCheckString.equals(null)) {\n\t\t\tSystem.out\n\t\t\t\t\t.println(\"[\" + getAID().getLocalName() + \"]: ERROR: OrderID not found in this.orderDetailsArray \");\n\t\t}\n\n\t\tfor (String productName : productsObject.keySet()) {\n\t\t\tint orderQuantity = productsObject.getInt(productName);\n\n\t\t\ttry {\n\t\t\t\tproductQuantity = orderProductDetails.get(productName);\n\t\t\t} catch (NullPointerException e) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (productQuantity != orderQuantity) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate class TimeUpdater extends CyclicBehaviour {\n\t\tpublic void action() {\n\t\t\tif (getAllowAction()) {\n\t\t\t\tfinished();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class PackagingPhaseMessageSender extends OneShotBehaviour {\n\t\tprivate AID receivingAgent = null;\n\n\t\tprotected void findReceiver() {\n\t\t\tDFAgentDescription template = new DFAgentDescription();\n\t\t\tServiceDescription sd = new ServiceDescription();\n\t\t\tsd.setType(\"order-aggregator\");\n\t\t\ttemplate.addServices(sd);\n\t\t\ttry {\n\t\t\t\tDFAgentDescription[] result = DFService.search(myAgent, template);\n\t\t\t\treceivingAgent = result[0].getName();\n\n\t\t\t} catch (FIPAException fe) {\n\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: No OrderAggregator agent found.\");\n\t\t\t\tfe.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void action() {\n\t\t\tfindReceiver();\n\n\t\t\tACLMessage msg = new ACLMessage(ACLMessage.INFORM);\n\n\t\t\tmsg.addReceiver(receivingAgent);\n\t\t\tmsg.setContent(createOrderBoxesJSONMessage(((LoadingBayAgent) baseAgent).readyOrderID));\n\t\t\tmsg.setConversationId(\"packaged-orders\");\n\t\t\tmsg.setPostTimeStamp(System.currentTimeMillis());\n\n\t\t\tmyAgent.send(msg);\n\n\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: Order details sent to OrderAggregator\");\n\t\t}\n\t}\n\n\tprivate class OrderDetailsReceiver extends CyclicBehaviour {\n\t\tprivate String orderProcessorServiceType;\n\t\tprivate AID orderProcessor = null;;\n\t\tprivate MessageTemplate mt;\n\n\t\tprotected void findOrderProcessor() {\n\t\t\tDFAgentDescription template = new DFAgentDescription();\n\t\t\tServiceDescription sd = new ServiceDescription();\n\t\t\torderProcessorServiceType = \"OrderProcessing\";\n\n\t\t\tsd.setType(orderProcessorServiceType);\n\t\t\ttemplate.addServices(sd);\n\t\t\ttry {\n\t\t\t\tDFAgentDescription[] result = DFService.search(myAgent, template);\n\t\t\t\torderProcessor = result[0].getName();\n\n\t\t\t} catch (FIPAException fe) {\n\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: No OrderProcessor agent found.\");\n\t\t\t\tfe.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void action() {\n\t\t\tfindOrderProcessor();\n\n\t\t\tmt = MessageTemplate.and(MessageTemplate.MatchSender(orderProcessor),\n\t\t\t\t\tMessageTemplate.MatchPerformative(ACLMessage.INFORM));\n\t\t\tACLMessage msg = myAgent.receive(mt);\n\n\t\t\tif (msg != null) {\n\t\t\t\t// If a single order is provided, in a message:\n\t\t\t\t((LoadingBayAgent) baseAgent).orderDetailsArray.put(new JSONObject(msg.getContent()));\n\n\t\t\t\t// Enable this instead, if a list of orders is provided:\n\t\t\t\t/*\n\t\t\t\t * JSONArray messagethis.orderDetailsArray = new JSONArray(msg.getContent());\n\t\t\t\t * for (int i = 0 ; i < messagethis.orderDetailsArray.length() ; i++) {\n\t\t\t\t * this.orderDetailsArray.put(messagethis.orderDetailsArray.get(i)); }\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\tblock();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class ProductDetailsReceiver extends CyclicBehaviour {\n\t\tprivate MessageTemplate mt;\n\n\t\tpublic void action() {\n\t\t\tmt = MessageTemplate.and(MessageTemplate.MatchConversationId(\"boxes-ready\"),\n\t\t\t\t\tMessageTemplate.MatchPerformative(ACLMessage.INFORM));\n\t\t\tACLMessage msg = myAgent.receive(mt);\n\n\t\t\tif (msg != null) {\n\t\t\t\tSystem.out.println(\"[\" + getAID().getLocalName() + \"]: Received product boxes from \"\n\t\t\t\t\t\t+ msg.getSender().getLocalName());\n\n\t\t\t\t// This assumes a JSON object is sent by the preceding agent\n\t\t\t\tString boxesMessageContent = msg.getContent();\n\t\t\t\tJSONObject JSONData = new JSONObject(boxesMessageContent);\n\t\t\t\tString orderIDKey = \"OrderID\";\n\t\t\t\tString orderID = JSONData.getString(orderIDKey);\n\n\t\t\t\tupdateBoxDatabase(boxesMessageContent);\n\t\t\t\tupdateProductDatabase(boxesMessageContent);\n\n\t\t\t\tif (orderProductsReady(orderID)) {\n\t\t\t\t\t((LoadingBayAgent) baseAgent).readyOrderID = orderID;\n\t\t\t\t\taddBehaviour(new PackagingPhaseMessageSender());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tblock();\n\t\t\t}\n\t\t}\n\t}\n}\n"},
{"Line": "=>63", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[]", "Content": "=>if ((wish.getCreateTime()) != null) { this.createTime = com.github.abigail830.wishlist.domainv1.WishDTO.dateFormatter.get().format(wish.getCreateTime()); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/321/buggy-version/src.main.java.com.github.abigail830.wishlist.domainv1.WishDTO.java", "BodyUseAPI": [], "Fixed commit": "24b96983f25dbbc25035c9bd4a5fe590d4e94ac0", "Url": "https://api.github.com/repos/abigail830/wish-list", "Date": "2018-12-06T21:50:31Z", "Source Code Diff": "@@ -60,8 +60,12 @@ public WishDTO(Integer wishID, String description, String createTime, String las\n     public WishDTO(Wish wish) {\n         this.wishID = wish.getId();\n         this.description = wish.getDescription();\n-        this.createTime = dateFormatter.get().format(wish.getCreateTime());\n-        this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n+        if (wish.getCreateTime() != null) {\n+            this.createTime = dateFormatter.get().format(wish.getCreateTime());\n+        }\n+        if (wish.getLastUpdateTime() != null) {\n+            this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n+        }\n         this.wishStatus = wish.getWishStatus();\n         this.wishListID = wish.getWishListId();\n         if (StringUtils.isNotBlank(wish.getImplementorOpenId()) && wish.getImplementor() != null) {", "Complete After Code": "package com.github.abigail830.wishlist.domainv1;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.github.abigail830.wishlist.entity.Wish;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport org.apache.commons.lang.StringUtils;\n\nimport java.text.SimpleDateFormat;\n\n@ApiModel(\"\u613f\u671b\u5217\u8868\u524d\u6bb5VO\")\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class WishDTO {\n\n    @ApiModelProperty(value = \"\u613f\u671bID\",  example = \"1\")\n    private Integer wishID;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u5217\u8868ID\",  example = \"1\")\n    private Integer wishListID;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u6982\u8ff0\",  example = \"\u6211\u8981\u4e00\u53f0\u8f66\uff01\")\n    private String description;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u521b\u5efa\u65f6\u95f4\",  example = \"2018-09-01\")\n    private String createTime;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u4fe1\u606f\u6700\u540e\u66f4\u65b0\u65f6\u95f4\",  example = \"2018-11-01\")\n    private String lastUpdateTime;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u6700\u65b0\u72b6\u6001\",  example = \"\u5b9e\u73b0\u5566\uff01\")\n    private String wishStatus;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u627f\u63a5\u4eba\",  example = \"\u5fae\u4fe1\u7528\u6237\")\n    private UserDTO implementor;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u62e5\u6709\u4eba\",  example = \"\u5fae\u4fe1\u7528\u6237\")\n    private UserDTO creator;\n\n    private static final ThreadLocal<SimpleDateFormat> dateFormatter = new ThreadLocal<SimpleDateFormat>() {\n        @Override protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd\");\n        }\n    };\n\n    public WishDTO () {\n\n    }\n\n    public WishDTO(Integer wishID, String description, String createTime, String lastUpdateTime,\n                      String wishStatus, UserDTO implementor, Integer wishListID) {\n        this.wishID = wishID;\n        this.description = description;\n        this.createTime = createTime;\n        this.lastUpdateTime = lastUpdateTime;\n        this.wishStatus = wishStatus;\n        this.implementor = implementor;\n        this.wishListID = wishListID;\n    }\n\n    public WishDTO(Wish wish) {\n        this.wishID = wish.getId();\n        this.description = wish.getDescription();\n        if (wish.getCreateTime() != null) {\n            this.createTime = dateFormatter.get().format(wish.getCreateTime());\n        }\n        if (wish.getLastUpdateTime() != null) {\n            this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n        }\n        this.wishStatus = wish.getWishStatus();\n        this.wishListID = wish.getWishListId();\n        if (StringUtils.isNotBlank(wish.getImplementorOpenId()) && wish.getImplementor() != null) {\n            this.implementor = new UserDTO(wish.getImplementor());\n        }\n        if (wish.getCreator() != null) {\n            this.creator = new UserDTO(wish.getCreator());\n        }\n    }\n\n    public Integer getWishID() {\n        return wishID;\n    }\n\n    public void setWishID(Integer wishID) {\n        this.wishID = wishID;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getCreateTime() {\n        return createTime;\n    }\n\n    public void setCreateTime(String createTime) {\n        this.createTime = createTime;\n    }\n\n    public String getLastUpdateTime() {\n        return lastUpdateTime;\n    }\n\n    public void setLastUpdateTime(String lastUpdateTime) {\n        this.lastUpdateTime = lastUpdateTime;\n    }\n\n    public String getWishStatus() {\n        return wishStatus;\n    }\n\n    public void setWishStatus(String wishStatus) {\n        this.wishStatus = wishStatus;\n    }\n\n    public UserDTO getImplementor() {\n        return implementor;\n    }\n\n    public void setImplementor(UserDTO implementor) {\n        this.implementor = implementor;\n    }\n\n    public Integer getWishListID() {\n        return wishListID;\n    }\n\n    public void setWishListID(Integer wishListID) {\n        this.wishListID = wishListID;\n    }\n\n    public UserDTO getCreator() {\n        return creator;\n    }\n\n    public void setCreator(UserDTO creator) {\n        this.creator = creator;\n    }\n\n    @Override\n    public String toString() {\n        return \"WishDTO{\" +\n                \"wishID=\" + wishID +\n                \", wishListID='\" + wishListID + '\\'' +\n                \", description='\" + description + '\\'' +\n                \", createTime='\" + createTime + '\\'' +\n                \", lastUpdateTime='\" + lastUpdateTime + '\\'' +\n                \", wishStatus='\" + wishStatus + '\\'' +\n                \", implementor=\" + implementor +\n                '}';\n    }\n\n}\n"},
{"Line": "=>66", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[]", "Content": "=>if ((wish.getLastUpdateTime()) != null) { this.lastUpdateTime = com.github.abigail830.wishlist.domainv1.WishDTO.dateFormatter.get().format(wish.getLastUpdateTime()); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/321/buggy-version/src.main.java.com.github.abigail830.wishlist.domainv1.WishDTO.java", "BodyUseAPI": [], "Fixed commit": "24b96983f25dbbc25035c9bd4a5fe590d4e94ac0", "Url": "https://api.github.com/repos/abigail830/wish-list", "Date": "2018-12-06T21:50:31Z", "Source Code Diff": "@@ -60,8 +60,12 @@ public WishDTO(Integer wishID, String description, String createTime, String las\n     public WishDTO(Wish wish) {\n         this.wishID = wish.getId();\n         this.description = wish.getDescription();\n-        this.createTime = dateFormatter.get().format(wish.getCreateTime());\n-        this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n+        if (wish.getCreateTime() != null) {\n+            this.createTime = dateFormatter.get().format(wish.getCreateTime());\n+        }\n+        if (wish.getLastUpdateTime() != null) {\n+            this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n+        }\n         this.wishStatus = wish.getWishStatus();\n         this.wishListID = wish.getWishListId();\n         if (StringUtils.isNotBlank(wish.getImplementorOpenId()) && wish.getImplementor() != null) {", "Complete After Code": "package com.github.abigail830.wishlist.domainv1;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.github.abigail830.wishlist.entity.Wish;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport org.apache.commons.lang.StringUtils;\n\nimport java.text.SimpleDateFormat;\n\n@ApiModel(\"\u613f\u671b\u5217\u8868\u524d\u6bb5VO\")\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class WishDTO {\n\n    @ApiModelProperty(value = \"\u613f\u671bID\",  example = \"1\")\n    private Integer wishID;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u5217\u8868ID\",  example = \"1\")\n    private Integer wishListID;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u6982\u8ff0\",  example = \"\u6211\u8981\u4e00\u53f0\u8f66\uff01\")\n    private String description;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u521b\u5efa\u65f6\u95f4\",  example = \"2018-09-01\")\n    private String createTime;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u4fe1\u606f\u6700\u540e\u66f4\u65b0\u65f6\u95f4\",  example = \"2018-11-01\")\n    private String lastUpdateTime;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u6700\u65b0\u72b6\u6001\",  example = \"\u5b9e\u73b0\u5566\uff01\")\n    private String wishStatus;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u627f\u63a5\u4eba\",  example = \"\u5fae\u4fe1\u7528\u6237\")\n    private UserDTO implementor;\n\n    @ApiModelProperty(value = \"\u613f\u671b\u62e5\u6709\u4eba\",  example = \"\u5fae\u4fe1\u7528\u6237\")\n    private UserDTO creator;\n\n    private static final ThreadLocal<SimpleDateFormat> dateFormatter = new ThreadLocal<SimpleDateFormat>() {\n        @Override protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"yyyy-MM-dd\");\n        }\n    };\n\n    public WishDTO () {\n\n    }\n\n    public WishDTO(Integer wishID, String description, String createTime, String lastUpdateTime,\n                      String wishStatus, UserDTO implementor, Integer wishListID) {\n        this.wishID = wishID;\n        this.description = description;\n        this.createTime = createTime;\n        this.lastUpdateTime = lastUpdateTime;\n        this.wishStatus = wishStatus;\n        this.implementor = implementor;\n        this.wishListID = wishListID;\n    }\n\n    public WishDTO(Wish wish) {\n        this.wishID = wish.getId();\n        this.description = wish.getDescription();\n        if (wish.getCreateTime() != null) {\n            this.createTime = dateFormatter.get().format(wish.getCreateTime());\n        }\n        if (wish.getLastUpdateTime() != null) {\n            this.lastUpdateTime = dateFormatter.get().format(wish.getLastUpdateTime());\n        }\n        this.wishStatus = wish.getWishStatus();\n        this.wishListID = wish.getWishListId();\n        if (StringUtils.isNotBlank(wish.getImplementorOpenId()) && wish.getImplementor() != null) {\n            this.implementor = new UserDTO(wish.getImplementor());\n        }\n        if (wish.getCreator() != null) {\n            this.creator = new UserDTO(wish.getCreator());\n        }\n    }\n\n    public Integer getWishID() {\n        return wishID;\n    }\n\n    public void setWishID(Integer wishID) {\n        this.wishID = wishID;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public String getCreateTime() {\n        return createTime;\n    }\n\n    public void setCreateTime(String createTime) {\n        this.createTime = createTime;\n    }\n\n    public String getLastUpdateTime() {\n        return lastUpdateTime;\n    }\n\n    public void setLastUpdateTime(String lastUpdateTime) {\n        this.lastUpdateTime = lastUpdateTime;\n    }\n\n    public String getWishStatus() {\n        return wishStatus;\n    }\n\n    public void setWishStatus(String wishStatus) {\n        this.wishStatus = wishStatus;\n    }\n\n    public UserDTO getImplementor() {\n        return implementor;\n    }\n\n    public void setImplementor(UserDTO implementor) {\n        this.implementor = implementor;\n    }\n\n    public Integer getWishListID() {\n        return wishListID;\n    }\n\n    public void setWishListID(Integer wishListID) {\n        this.wishListID = wishListID;\n    }\n\n    public UserDTO getCreator() {\n        return creator;\n    }\n\n    public void setCreator(UserDTO creator) {\n        this.creator = creator;\n    }\n\n    @Override\n    public String toString() {\n        return \"WishDTO{\" +\n                \"wishID=\" + wishID +\n                \", wishListID='\" + wishListID + '\\'' +\n                \", description='\" + description + '\\'' +\n                \", createTime='\" + createTime + '\\'' +\n                \", lastUpdateTime='\" + lastUpdateTime + '\\'' +\n                \", wishStatus='\" + wishStatus + '\\'' +\n                \", implementor=\" + implementor +\n                '}';\n    }\n\n}\n"},
{"Line": "=>136", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["mProductQuantityEditText.getText().toString().trim()"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (quantityText.isEmpty()) { android.widget.Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to reduce it\", Toast.LENGTH_SHORT).show(); return; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/53/buggy-version/app.src.main.java.com.example.ahad.bookinventory.BookEditor.java", "BodyUseAPI": [], "Fixed commit": "efb955bf64014cc58734621498aec925339da8bd", "Url": "https://api.github.com/repos/modfa/InventoryApp", "Date": "2018-11-04T07:29:29Z", "Source Code Diff": "@@ -132,7 +132,14 @@ protected void onCreate(Bundle savedInstanceState) {\n         mMinusButton.setOnClickListener(new View.OnClickListener() {\n             @Override\n             public void onClick(View v) {\n-                int quantity = Integer.parseInt(mProductQuantityEditText.getText().toString().trim());\n+               String quantityText = mProductQuantityEditText.getText().toString().trim();\n+               if(quantityText.isEmpty()){\n+                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to reduce it\",\n+                           Toast.LENGTH_SHORT).show();\n+                   return;\n+               }\n+                int quantity = Integer.parseInt(quantityText);\n+\n                 if (quantity == 0) {\n                     Toast.makeText(getApplicationContext(), \"Sorry !! Can't go below zero quantity\",\n                             Toast.LENGTH_SHORT).show();\n@@ -146,7 +153,13 @@ public void onClick(View v) {\n         mPlusButton.setOnClickListener(new View.OnClickListener() {\n             @Override\n             public void onClick(View v) {\n-                int quantity = Integer.parseInt(mProductQuantityEditText.getText().toString().trim());\n+               String quantityText = mProductQuantityEditText.getText().toString().trim();\n+               if(quantityText.isEmpty()){\n+                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to add on it\",\n+                           Toast.LENGTH_SHORT).show();\n+                   return;\n+               }\n+                int quantity = Integer.parseInt(quantityText);\n                 quantity++;\n                 mProductQuantityEditText.setText(Integer.toString(quantity));\n             }", "Complete After Code": "package com.example.ahad.bookinventory;\n\nimport android.app.AlertDialog;\nimport android.app.LoaderManager;\nimport android.content.ContentValues;\nimport android.content.CursorLoader;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.support.v4.app.NavUtils;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.text.TextUtils;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport com.example.ahad.bookinventory.data.InventoryContract.BookEntry;\n\n\npublic class BookEditor extends AppCompatActivity implements LoaderManager.LoaderCallbacks<Cursor> {\n    /**\n     * Identifier for the book data loader\n     */\n    private static final int EXISTING_BOOK_LOADER = 0;\n    // Buttons for increasing,decreasing and order\n    private Button mPlusButton, mMinusButton, mOrderButton;\n    /**\n     * Content URI for the existing book (null if it's a new book)\n     */\n    private Uri mCurrentBookUri;\n    /**\n     * EditText field to enter the product name\n     */\n    private EditText mProductNameEditText;\n\n    /**\n     * EditText field to enter the product price\n     */\n    private EditText mProductPriceEditText;\n\n    /**\n     * EditText field to enter the product quantity\n     */\n    private EditText mProductQuantityEditText;\n\n    /**\n     * EditText field to enter the product supplier name\n     */\n    private EditText mProductSupplierNameEditText;\n\n    /**\n     * EditText field to enter the product Supplier phone number\n     */\n    private EditText mProductSupplierPhoneEditText;\n    /**\n     * Boolean flag that keeps track of whether the book has been edited (true) or not (false)\n     */\n    private boolean mBookHasChanged = false;\n\n\n    /**\n     * OnTouchListener that listens for any user touches on a View, implying that they are modifying\n     * the view, and we change the mPetHasChanged boolean to true.\n     */\n    private View.OnTouchListener mTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View view, MotionEvent motionEvent) {\n            mBookHasChanged = true;\n            return false;\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_book_editor);\n\n        //Examine the intent that was used to launch this activity\n        //In order to figure out if we are creating a book or editing an existing one\n        Intent intent = getIntent();\n        mCurrentBookUri = intent.getData();\n\n        //if the intent does not contain the pet content URI,\n        // then we know that we are creating a new pet\n        if (mCurrentBookUri == null) {\n            getWindow().getDecorView().setBackgroundColor(ContextCompat.getColor(BookEditor.this, R.color.yellow_light));\n            setTitle(R.string.add_a_book);\n            // Invalidate the options menu, so the \"Delete\" menu option can be hidden.\n            // (It doesn't make sense to delete a book that hasn't been created yet.)\n            invalidateOptionsMenu();\n\n        } else {\n            // Otherwise it is an existing pet, so change App bar to say \"Edit the Pet\"\n            setTitle(R.string.edit_the_book);\n            getWindow().getDecorView().setBackgroundColor(ContextCompat.getColor(BookEditor.this, R.color.yellow_light));\n\n            // Initialize a loader to read the book data from the database\n            // and display the current values in the editor\n            getLoaderManager().initLoader(EXISTING_BOOK_LOADER, null, this);\n\n        }\n\n        // Find all relevant views that we will need to read user input from\n        mProductNameEditText = findViewById(R.id.product_name);\n        mProductPriceEditText = findViewById(R.id.price);\n        mProductQuantityEditText = findViewById(R.id.quantity);\n        mProductSupplierNameEditText = findViewById(R.id.supplier_name);\n        mProductSupplierPhoneEditText = findViewById(R.id.supplier_ph_number);\n        mMinusButton = findViewById(R.id.minus);\n        mPlusButton = findViewById(R.id.plus);\n        mOrderButton = findViewById(R.id.order);\n\n        // Setup OnTouchListeners on all the input fields, so we can determine if the user\n        // has touched or modified them. This will let us know if there are unsaved changes\n        // or not, if the user tries to leave the editor without saving.\n        mProductNameEditText.setOnTouchListener(mTouchListener);\n        mProductPriceEditText.setOnTouchListener(mTouchListener);\n        mProductQuantityEditText.setOnTouchListener(mTouchListener);\n        mProductSupplierNameEditText.setOnTouchListener(mTouchListener);\n        mProductSupplierPhoneEditText.setOnTouchListener(mTouchListener);\n\n\n// Setup OnClickListener to decrease the quantity\n        mMinusButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               String quantityText = mProductQuantityEditText.getText().toString().trim();\n               if(quantityText.isEmpty()){\n                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to reduce it\",\n                           Toast.LENGTH_SHORT).show();\n                   return;\n               }\n                int quantity = Integer.parseInt(quantityText);\n\n                if (quantity == 0) {\n                    Toast.makeText(getApplicationContext(), \"Sorry !! Can't go below zero quantity\",\n                            Toast.LENGTH_SHORT).show();\n                } else {\n                    quantity--;\n                    mProductQuantityEditText.setText(Integer.toString(quantity));\n                }\n            }\n        });\n// Setup OnClickListener to increase the quantity\n        mPlusButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               String quantityText = mProductQuantityEditText.getText().toString().trim();\n               if(quantityText.isEmpty()){\n                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to add on it\",\n                           Toast.LENGTH_SHORT).show();\n                   return;\n               }\n                int quantity = Integer.parseInt(quantityText);\n                quantity++;\n                mProductQuantityEditText.setText(Integer.toString(quantity));\n            }\n        });\n// Setup OnClickListener to order the supplier via the phone number\n        mOrderButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                String phoneNumber = mProductSupplierPhoneEditText.getText().toString().trim();\n                String uri = \"tel:\" + phoneNumber;\n                Intent intent = new Intent(Intent.ACTION_DIAL);\n                intent.setData(Uri.parse(uri));\n                startActivity(intent);\n            }\n        });\n    }\n\n    /**\n     * Get user input from editor and save new product into database.\n     */\n\n    private void insertProduct() {\n\n        // Read from input fields\n        // Use trim to eliminate leading or trailing white space\n        String nameString = mProductNameEditText.getText().toString().trim();\n        String priceString = mProductPriceEditText.getText().toString().trim();\n        String quantityString = mProductQuantityEditText.getText().toString().trim();\n        String supplierNameString = mProductSupplierNameEditText.getText().toString().trim();\n        String supplierPhoneNumberString = mProductSupplierPhoneEditText.getText().toString().trim();\n\n        // Check if this is supposed to be a new book\n        // and check if all the fields in the editor are blank\n        if (mCurrentBookUri == null &&\n                TextUtils.isEmpty(nameString) && TextUtils.isEmpty(priceString) &&\n                TextUtils.isEmpty(quantityString) && TextUtils.isEmpty(supplierNameString) && TextUtils.isEmpty(supplierPhoneNumberString)) {\n            Toast.makeText(this, R.string.require_all_details, Toast.LENGTH_LONG).show();\n            return;\n        }\n        // Check if this is supposed to be a new book\n        // and check if any of the fields in the editor are blank\n\n        if (TextUtils.isEmpty(nameString)) {\n            Toast.makeText(this, R.string.name_require,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if (TextUtils.isEmpty(priceString)) {\n            Toast.makeText(this, R.string.price_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if (TextUtils.isEmpty(quantityString)) {\n            Toast.makeText(this, R.string.quantity_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (TextUtils.isEmpty(supplierNameString)) {\n            Toast.makeText(this, R.string.supplier_name_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (TextUtils.isEmpty(supplierPhoneNumberString)) {\n            Toast.makeText(this, R.string.supplier_ph_no_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n\n        // Convert the Strings into the integer values\n        int price = Integer.parseInt(priceString);\n        int quantity = Integer.parseInt(quantityString);\n\n        // Create a ContentValues object where column names are the keys,\n        // and product attributes from the editor are the values.\n        ContentValues values = new ContentValues();\n        values.put(BookEntry.COLUMN_PRODUCT_NAME, nameString);\n        values.put(BookEntry.COLUMN_PRODUCT_PRICE, price);\n        values.put(BookEntry.COLUMN_PRODUCT_QUANTITY, quantity);\n        values.put(BookEntry.COLUMN_SUPPLER_NAME, supplierNameString);\n        values.put(BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER, supplierPhoneNumberString);\n\n        if (mCurrentBookUri == null) {\n            // Insert a new row for book in the database, returning the ID of that new row.\n            Uri newUri = getContentResolver().insert(BookEntry.CONTENT_URI, values);\n            // Show a toast message depending on whether or not the insertion was successful\n            if (newUri == null) {\n                // If the new content URI is null, then there was an error with insertion.\n                Toast.makeText(this, getString(R.string.editor_insert_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the insertion was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_insert_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n        } else {\n            // Otherwise this is an EXISTING book, so update the pet with content URI: mCurrentBookUri\n            // and pass in the new ContentValues. Pass in null for the selection and selection args\n            // because mCurrentBookUri will already identify the correct row in the database that\n            // we want to modify.\n            int rowsAffected = getContentResolver().update(mCurrentBookUri, values, null, null);\n// Show a toast message depending on whether or not the update was successful.\n            if (rowsAffected == 0) {\n                // If no rows were affected, then there was an error with the update.\n                Toast.makeText(this, getString(R.string.editor_update_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the update was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_update_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu options from the res/menu/menu_editor.xml file.\n        // This adds menu items to the app bar.\n        getMenuInflater().inflate(R.menu.editor_menu, menu);\n        return true;\n    }\n\n    /**\n     * This method is called after invalidateOptionsMenu(), so that the\n     * menu can be updated (some menu items can be hidden or made visible).\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n        // If this is a new pet, hide the \"Delete\" menu item.\n        if (mCurrentBookUri == null) {\n            MenuItem menuItem = menu.findItem(R.id.action_delete);\n            menuItem.setVisible(false);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // User clicked on a menu option in the app bar overflow menu\n        switch (item.getItemId()) {\n            // Respond to a click on the \"Save\" menu option\n            case R.id.action_save:\n                insertProduct();\n                finish();\n                return true;\n\n            case R.id.action_delete:\n                showDeleteConfirmationDialog();\n                return true;\n\n            // Respond to a click on the \"Up\" arrow button in the app bar\n            case android.R.id.home:\n                // If the book hasn't changed, continue with navigating up to parent activity\n                if (!mBookHasChanged) {\n                    NavUtils.navigateUpFromSameTask(BookEditor.this);\n                    return true;\n                }\n                // Otherwise if there are unsaved changes, setup a dialog to warn the user.\n                // Create a click listener to handle the user confirming that\n                // changes should be discarded.\n                DialogInterface.OnClickListener discardButtonClickListener =\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialogInterface, int i) {\n                                // User clicked \"Discard\" button, navigate to parent activity.\n                                NavUtils.navigateUpFromSameTask(BookEditor.this);\n                            }\n                        };\n                // Show a dialog that notifies the user they have unsaved changes\n                showUnsavedChangesDialog(discardButtonClickListener);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * This method is called when the back button is pressed.\n     */\n    @Override\n    public void onBackPressed() {\n        // If the pet hasn't changed, continue with handling back button press\n        if (!mBookHasChanged) {\n            super.onBackPressed();\n            return;\n        }\n        // Otherwise if there are unsaved changes, setup a dialog to warn the user.\n        // Create a click listener to handle the user confirming that changes should be discarded.\n        DialogInterface.OnClickListener discardButtonClickListener =\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        // User clicked \"Discard\" button, close the current activity.\n                        finish();\n                    }\n                };\n        // Show dialog that there are unsaved changes\n        showUnsavedChangesDialog(discardButtonClickListener);\n    }\n\n    @Override\n    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\n        // Since the editor shows all book attributes, define a projection that contains\n        // all columns from the book table\n        String[] projection = {\n                BookEntry._ID,\n                BookEntry.COLUMN_PRODUCT_NAME,\n                BookEntry.COLUMN_PRODUCT_PRICE,\n                BookEntry.COLUMN_PRODUCT_QUANTITY,\n                BookEntry.COLUMN_SUPPLER_NAME,\n                BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER};\n\n        // This loader will execute the ContentProvider's query method on a background thread\n        return new CursorLoader(this,   // Parent activity context\n                mCurrentBookUri,         // Query the content URI for the current pet\n                projection,             // Columns to include in the resulting Cursor\n                null,                   // No selection clause\n                null,                   // No selection arguments\n                null);                  // Default sort order\n    }\n\n    @Override\n    public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {\n        // Proceed with moving to the first row of the cursor and reading data from it\n        // (This should be the only row in the cursor)\n        if (cursor.moveToFirst()) {\n            // Find the columns of pet attributes that we're interested in\n            int nameColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_NAME);\n            int priceColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_PRICE);\n            int quantityColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_QUANTITY);\n            int supplierNameColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_SUPPLER_NAME);\n            int supplierNumberColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER);\n\n            // Extract out the value from the Cursor for the given column index\n            String name = cursor.getString(nameColumnIndex);\n            int price = cursor.getInt(priceColumnIndex);\n            int quantity = cursor.getInt(quantityColumnIndex);\n            String supplierName = cursor.getString(supplierNameColumnIndex);\n            String supplierNumber = cursor.getString(supplierNumberColumnIndex);\n\n            // Update the views on the screen with the values from the database\n            mProductNameEditText.setText(name);\n            mProductPriceEditText.setText(Integer.toString(price));\n            mProductQuantityEditText.setText(Integer.toString(quantity));\n            mProductSupplierNameEditText.setText(supplierName);\n            mProductSupplierPhoneEditText.setText(supplierNumber);\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader<Cursor> loader) {\n        // If the loader is invalidated, clear out all the data from the input fields.\n        mProductNameEditText.setText(\"\");\n        mProductPriceEditText.setText(\"\");\n        mProductQuantityEditText.setText(\"\");\n        mProductSupplierNameEditText.setText(\"\");\n        mProductSupplierPhoneEditText.setText(\"\");\n    }\n\n\n    /**\n     * Show a dialog that warns the user there are unsaved changes that will be lost\n     * if they continue leaving the editor.\n     *\n     * @param discardButtonClickListener is the click listener for what to do when\n     *                                   the user confirms they want to discard their changes\n     */\n    private void showUnsavedChangesDialog(\n            DialogInterface.OnClickListener discardButtonClickListener) {\n        // Create an AlertDialog.Builder and set the message, and click listeners\n        // for the postivie and negative buttons on the dialog.\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(R.string.unsaved_changes_dialog_msg);\n        builder.setPositiveButton(R.string.discard, discardButtonClickListener);\n        builder.setNegativeButton(R.string.keep_editing, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Keep editing\" button, so dismiss the dialog\n                // and continue editing the pet.\n                if (dialog != null) {\n                    dialog.dismiss();\n                }\n            }\n        });\n        // Create and show the AlertDialog\n        AlertDialog alertDialog = builder.create();\n        alertDialog.show();\n    }\n\n    private void showDeleteConfirmationDialog() {\n        // Create an AlertDialog.Builder and set the message, and click listeners\n        // for the postivie and negative buttons on the dialog.\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(R.string.delete_dialog_msg_single);\n        builder.setPositiveButton(R.string.delete, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Delete\" button, so delete the book.\n                deleteBook();\n            }\n        });\n        builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Cancel\" button, so dismiss the dialog\n                // and continue editing the book.\n                if (dialog != null) {\n                    dialog.dismiss();\n                }\n            }\n        });\n\n        // Create and show the AlertDialog\n        AlertDialog alertDialog = builder.create();\n        alertDialog.show();\n    }\n\n    /**\n     * Perform the deletion of the book in the database.\n     */\n    private void deleteBook() {\n        // Only perform the delete if this is an existing book.\n        if (mCurrentBookUri != null) {\n            // Call the ContentResolver to delete the book at the given content URI.\n            // Pass in null for the selection and selection args because the mCurrentPetUri\n            // content URI already identifies the book that we want.\n            int rowsDeleted = getContentResolver().delete(mCurrentBookUri, null, null);\n            // Show a toast message depending on whether or not the delete was successful.\n            if (rowsDeleted == 0) {\n                // If no rows were deleted, then there was an error with the delete.\n                Toast.makeText(this, getString(R.string.editor_delete_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the delete was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_delete_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n            // Close the activity\n            finish();\n        }\n    }\n}\n"},
{"Line": "=>157", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["mProductQuantityEditText.getText().toString().trim()"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (quantityText.isEmpty()) { android.widget.Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to add on it\", Toast.LENGTH_SHORT).show(); return; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/53/buggy-version/app.src.main.java.com.example.ahad.bookinventory.BookEditor.java", "BodyUseAPI": [], "Fixed commit": "efb955bf64014cc58734621498aec925339da8bd", "Url": "https://api.github.com/repos/modfa/InventoryApp", "Date": "2018-11-04T07:29:29Z", "Source Code Diff": "@@ -132,7 +132,14 @@ protected void onCreate(Bundle savedInstanceState) {\n         mMinusButton.setOnClickListener(new View.OnClickListener() {\n             @Override\n             public void onClick(View v) {\n-                int quantity = Integer.parseInt(mProductQuantityEditText.getText().toString().trim());\n+               String quantityText = mProductQuantityEditText.getText().toString().trim();\n+               if(quantityText.isEmpty()){\n+                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to reduce it\",\n+                           Toast.LENGTH_SHORT).show();\n+                   return;\n+               }\n+                int quantity = Integer.parseInt(quantityText);\n+\n                 if (quantity == 0) {\n                     Toast.makeText(getApplicationContext(), \"Sorry !! Can't go below zero quantity\",\n                             Toast.LENGTH_SHORT).show();\n@@ -146,7 +153,13 @@ public void onClick(View v) {\n         mPlusButton.setOnClickListener(new View.OnClickListener() {\n             @Override\n             public void onClick(View v) {\n-                int quantity = Integer.parseInt(mProductQuantityEditText.getText().toString().trim());\n+               String quantityText = mProductQuantityEditText.getText().toString().trim();\n+               if(quantityText.isEmpty()){\n+                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to add on it\",\n+                           Toast.LENGTH_SHORT).show();\n+                   return;\n+               }\n+                int quantity = Integer.parseInt(quantityText);\n                 quantity++;\n                 mProductQuantityEditText.setText(Integer.toString(quantity));\n             }", "Complete After Code": "package com.example.ahad.bookinventory;\n\nimport android.app.AlertDialog;\nimport android.app.LoaderManager;\nimport android.content.ContentValues;\nimport android.content.CursorLoader;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.Loader;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.support.v4.app.NavUtils;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.text.TextUtils;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport com.example.ahad.bookinventory.data.InventoryContract.BookEntry;\n\n\npublic class BookEditor extends AppCompatActivity implements LoaderManager.LoaderCallbacks<Cursor> {\n    /**\n     * Identifier for the book data loader\n     */\n    private static final int EXISTING_BOOK_LOADER = 0;\n    // Buttons for increasing,decreasing and order\n    private Button mPlusButton, mMinusButton, mOrderButton;\n    /**\n     * Content URI for the existing book (null if it's a new book)\n     */\n    private Uri mCurrentBookUri;\n    /**\n     * EditText field to enter the product name\n     */\n    private EditText mProductNameEditText;\n\n    /**\n     * EditText field to enter the product price\n     */\n    private EditText mProductPriceEditText;\n\n    /**\n     * EditText field to enter the product quantity\n     */\n    private EditText mProductQuantityEditText;\n\n    /**\n     * EditText field to enter the product supplier name\n     */\n    private EditText mProductSupplierNameEditText;\n\n    /**\n     * EditText field to enter the product Supplier phone number\n     */\n    private EditText mProductSupplierPhoneEditText;\n    /**\n     * Boolean flag that keeps track of whether the book has been edited (true) or not (false)\n     */\n    private boolean mBookHasChanged = false;\n\n\n    /**\n     * OnTouchListener that listens for any user touches on a View, implying that they are modifying\n     * the view, and we change the mPetHasChanged boolean to true.\n     */\n    private View.OnTouchListener mTouchListener = new View.OnTouchListener() {\n        @Override\n        public boolean onTouch(View view, MotionEvent motionEvent) {\n            mBookHasChanged = true;\n            return false;\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_book_editor);\n\n        //Examine the intent that was used to launch this activity\n        //In order to figure out if we are creating a book or editing an existing one\n        Intent intent = getIntent();\n        mCurrentBookUri = intent.getData();\n\n        //if the intent does not contain the pet content URI,\n        // then we know that we are creating a new pet\n        if (mCurrentBookUri == null) {\n            getWindow().getDecorView().setBackgroundColor(ContextCompat.getColor(BookEditor.this, R.color.yellow_light));\n            setTitle(R.string.add_a_book);\n            // Invalidate the options menu, so the \"Delete\" menu option can be hidden.\n            // (It doesn't make sense to delete a book that hasn't been created yet.)\n            invalidateOptionsMenu();\n\n        } else {\n            // Otherwise it is an existing pet, so change App bar to say \"Edit the Pet\"\n            setTitle(R.string.edit_the_book);\n            getWindow().getDecorView().setBackgroundColor(ContextCompat.getColor(BookEditor.this, R.color.yellow_light));\n\n            // Initialize a loader to read the book data from the database\n            // and display the current values in the editor\n            getLoaderManager().initLoader(EXISTING_BOOK_LOADER, null, this);\n\n        }\n\n        // Find all relevant views that we will need to read user input from\n        mProductNameEditText = findViewById(R.id.product_name);\n        mProductPriceEditText = findViewById(R.id.price);\n        mProductQuantityEditText = findViewById(R.id.quantity);\n        mProductSupplierNameEditText = findViewById(R.id.supplier_name);\n        mProductSupplierPhoneEditText = findViewById(R.id.supplier_ph_number);\n        mMinusButton = findViewById(R.id.minus);\n        mPlusButton = findViewById(R.id.plus);\n        mOrderButton = findViewById(R.id.order);\n\n        // Setup OnTouchListeners on all the input fields, so we can determine if the user\n        // has touched or modified them. This will let us know if there are unsaved changes\n        // or not, if the user tries to leave the editor without saving.\n        mProductNameEditText.setOnTouchListener(mTouchListener);\n        mProductPriceEditText.setOnTouchListener(mTouchListener);\n        mProductQuantityEditText.setOnTouchListener(mTouchListener);\n        mProductSupplierNameEditText.setOnTouchListener(mTouchListener);\n        mProductSupplierPhoneEditText.setOnTouchListener(mTouchListener);\n\n\n// Setup OnClickListener to decrease the quantity\n        mMinusButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               String quantityText = mProductQuantityEditText.getText().toString().trim();\n               if(quantityText.isEmpty()){\n                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to reduce it\",\n                           Toast.LENGTH_SHORT).show();\n                   return;\n               }\n                int quantity = Integer.parseInt(quantityText);\n\n                if (quantity == 0) {\n                    Toast.makeText(getApplicationContext(), \"Sorry !! Can't go below zero quantity\",\n                            Toast.LENGTH_SHORT).show();\n                } else {\n                    quantity--;\n                    mProductQuantityEditText.setText(Integer.toString(quantity));\n                }\n            }\n        });\n// Setup OnClickListener to increase the quantity\n        mPlusButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               String quantityText = mProductQuantityEditText.getText().toString().trim();\n               if(quantityText.isEmpty()){\n                   Toast.makeText(getApplicationContext(), \"Please provide a valid quantity to add on it\",\n                           Toast.LENGTH_SHORT).show();\n                   return;\n               }\n                int quantity = Integer.parseInt(quantityText);\n                quantity++;\n                mProductQuantityEditText.setText(Integer.toString(quantity));\n            }\n        });\n// Setup OnClickListener to order the supplier via the phone number\n        mOrderButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                String phoneNumber = mProductSupplierPhoneEditText.getText().toString().trim();\n                String uri = \"tel:\" + phoneNumber;\n                Intent intent = new Intent(Intent.ACTION_DIAL);\n                intent.setData(Uri.parse(uri));\n                startActivity(intent);\n            }\n        });\n    }\n\n    /**\n     * Get user input from editor and save new product into database.\n     */\n\n    private void insertProduct() {\n\n        // Read from input fields\n        // Use trim to eliminate leading or trailing white space\n        String nameString = mProductNameEditText.getText().toString().trim();\n        String priceString = mProductPriceEditText.getText().toString().trim();\n        String quantityString = mProductQuantityEditText.getText().toString().trim();\n        String supplierNameString = mProductSupplierNameEditText.getText().toString().trim();\n        String supplierPhoneNumberString = mProductSupplierPhoneEditText.getText().toString().trim();\n\n        // Check if this is supposed to be a new book\n        // and check if all the fields in the editor are blank\n        if (mCurrentBookUri == null &&\n                TextUtils.isEmpty(nameString) && TextUtils.isEmpty(priceString) &&\n                TextUtils.isEmpty(quantityString) && TextUtils.isEmpty(supplierNameString) && TextUtils.isEmpty(supplierPhoneNumberString)) {\n            Toast.makeText(this, R.string.require_all_details, Toast.LENGTH_LONG).show();\n            return;\n        }\n        // Check if this is supposed to be a new book\n        // and check if any of the fields in the editor are blank\n\n        if (TextUtils.isEmpty(nameString)) {\n            Toast.makeText(this, R.string.name_require,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if (TextUtils.isEmpty(priceString)) {\n            Toast.makeText(this, R.string.price_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n        if (TextUtils.isEmpty(quantityString)) {\n            Toast.makeText(this, R.string.quantity_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (TextUtils.isEmpty(supplierNameString)) {\n            Toast.makeText(this, R.string.supplier_name_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n        if (TextUtils.isEmpty(supplierPhoneNumberString)) {\n            Toast.makeText(this, R.string.supplier_ph_no_required,\n                    Toast.LENGTH_SHORT).show();\n            return;\n        }\n\n\n        // Convert the Strings into the integer values\n        int price = Integer.parseInt(priceString);\n        int quantity = Integer.parseInt(quantityString);\n\n        // Create a ContentValues object where column names are the keys,\n        // and product attributes from the editor are the values.\n        ContentValues values = new ContentValues();\n        values.put(BookEntry.COLUMN_PRODUCT_NAME, nameString);\n        values.put(BookEntry.COLUMN_PRODUCT_PRICE, price);\n        values.put(BookEntry.COLUMN_PRODUCT_QUANTITY, quantity);\n        values.put(BookEntry.COLUMN_SUPPLER_NAME, supplierNameString);\n        values.put(BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER, supplierPhoneNumberString);\n\n        if (mCurrentBookUri == null) {\n            // Insert a new row for book in the database, returning the ID of that new row.\n            Uri newUri = getContentResolver().insert(BookEntry.CONTENT_URI, values);\n            // Show a toast message depending on whether or not the insertion was successful\n            if (newUri == null) {\n                // If the new content URI is null, then there was an error with insertion.\n                Toast.makeText(this, getString(R.string.editor_insert_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the insertion was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_insert_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n        } else {\n            // Otherwise this is an EXISTING book, so update the pet with content URI: mCurrentBookUri\n            // and pass in the new ContentValues. Pass in null for the selection and selection args\n            // because mCurrentBookUri will already identify the correct row in the database that\n            // we want to modify.\n            int rowsAffected = getContentResolver().update(mCurrentBookUri, values, null, null);\n// Show a toast message depending on whether or not the update was successful.\n            if (rowsAffected == 0) {\n                // If no rows were affected, then there was an error with the update.\n                Toast.makeText(this, getString(R.string.editor_update_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the update was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_update_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n        }\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu options from the res/menu/menu_editor.xml file.\n        // This adds menu items to the app bar.\n        getMenuInflater().inflate(R.menu.editor_menu, menu);\n        return true;\n    }\n\n    /**\n     * This method is called after invalidateOptionsMenu(), so that the\n     * menu can be updated (some menu items can be hidden or made visible).\n     */\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n        // If this is a new pet, hide the \"Delete\" menu item.\n        if (mCurrentBookUri == null) {\n            MenuItem menuItem = menu.findItem(R.id.action_delete);\n            menuItem.setVisible(false);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        // User clicked on a menu option in the app bar overflow menu\n        switch (item.getItemId()) {\n            // Respond to a click on the \"Save\" menu option\n            case R.id.action_save:\n                insertProduct();\n                finish();\n                return true;\n\n            case R.id.action_delete:\n                showDeleteConfirmationDialog();\n                return true;\n\n            // Respond to a click on the \"Up\" arrow button in the app bar\n            case android.R.id.home:\n                // If the book hasn't changed, continue with navigating up to parent activity\n                if (!mBookHasChanged) {\n                    NavUtils.navigateUpFromSameTask(BookEditor.this);\n                    return true;\n                }\n                // Otherwise if there are unsaved changes, setup a dialog to warn the user.\n                // Create a click listener to handle the user confirming that\n                // changes should be discarded.\n                DialogInterface.OnClickListener discardButtonClickListener =\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialogInterface, int i) {\n                                // User clicked \"Discard\" button, navigate to parent activity.\n                                NavUtils.navigateUpFromSameTask(BookEditor.this);\n                            }\n                        };\n                // Show a dialog that notifies the user they have unsaved changes\n                showUnsavedChangesDialog(discardButtonClickListener);\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * This method is called when the back button is pressed.\n     */\n    @Override\n    public void onBackPressed() {\n        // If the pet hasn't changed, continue with handling back button press\n        if (!mBookHasChanged) {\n            super.onBackPressed();\n            return;\n        }\n        // Otherwise if there are unsaved changes, setup a dialog to warn the user.\n        // Create a click listener to handle the user confirming that changes should be discarded.\n        DialogInterface.OnClickListener discardButtonClickListener =\n                new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialogInterface, int i) {\n                        // User clicked \"Discard\" button, close the current activity.\n                        finish();\n                    }\n                };\n        // Show dialog that there are unsaved changes\n        showUnsavedChangesDialog(discardButtonClickListener);\n    }\n\n    @Override\n    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\n        // Since the editor shows all book attributes, define a projection that contains\n        // all columns from the book table\n        String[] projection = {\n                BookEntry._ID,\n                BookEntry.COLUMN_PRODUCT_NAME,\n                BookEntry.COLUMN_PRODUCT_PRICE,\n                BookEntry.COLUMN_PRODUCT_QUANTITY,\n                BookEntry.COLUMN_SUPPLER_NAME,\n                BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER};\n\n        // This loader will execute the ContentProvider's query method on a background thread\n        return new CursorLoader(this,   // Parent activity context\n                mCurrentBookUri,         // Query the content URI for the current pet\n                projection,             // Columns to include in the resulting Cursor\n                null,                   // No selection clause\n                null,                   // No selection arguments\n                null);                  // Default sort order\n    }\n\n    @Override\n    public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {\n        // Proceed with moving to the first row of the cursor and reading data from it\n        // (This should be the only row in the cursor)\n        if (cursor.moveToFirst()) {\n            // Find the columns of pet attributes that we're interested in\n            int nameColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_NAME);\n            int priceColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_PRICE);\n            int quantityColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_PRODUCT_QUANTITY);\n            int supplierNameColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_SUPPLER_NAME);\n            int supplierNumberColumnIndex = cursor.getColumnIndex(BookEntry.COLUMN_SUPPLIER_PHONE_NUMBER);\n\n            // Extract out the value from the Cursor for the given column index\n            String name = cursor.getString(nameColumnIndex);\n            int price = cursor.getInt(priceColumnIndex);\n            int quantity = cursor.getInt(quantityColumnIndex);\n            String supplierName = cursor.getString(supplierNameColumnIndex);\n            String supplierNumber = cursor.getString(supplierNumberColumnIndex);\n\n            // Update the views on the screen with the values from the database\n            mProductNameEditText.setText(name);\n            mProductPriceEditText.setText(Integer.toString(price));\n            mProductQuantityEditText.setText(Integer.toString(quantity));\n            mProductSupplierNameEditText.setText(supplierName);\n            mProductSupplierPhoneEditText.setText(supplierNumber);\n        }\n    }\n\n    @Override\n    public void onLoaderReset(Loader<Cursor> loader) {\n        // If the loader is invalidated, clear out all the data from the input fields.\n        mProductNameEditText.setText(\"\");\n        mProductPriceEditText.setText(\"\");\n        mProductQuantityEditText.setText(\"\");\n        mProductSupplierNameEditText.setText(\"\");\n        mProductSupplierPhoneEditText.setText(\"\");\n    }\n\n\n    /**\n     * Show a dialog that warns the user there are unsaved changes that will be lost\n     * if they continue leaving the editor.\n     *\n     * @param discardButtonClickListener is the click listener for what to do when\n     *                                   the user confirms they want to discard their changes\n     */\n    private void showUnsavedChangesDialog(\n            DialogInterface.OnClickListener discardButtonClickListener) {\n        // Create an AlertDialog.Builder and set the message, and click listeners\n        // for the postivie and negative buttons on the dialog.\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(R.string.unsaved_changes_dialog_msg);\n        builder.setPositiveButton(R.string.discard, discardButtonClickListener);\n        builder.setNegativeButton(R.string.keep_editing, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Keep editing\" button, so dismiss the dialog\n                // and continue editing the pet.\n                if (dialog != null) {\n                    dialog.dismiss();\n                }\n            }\n        });\n        // Create and show the AlertDialog\n        AlertDialog alertDialog = builder.create();\n        alertDialog.show();\n    }\n\n    private void showDeleteConfirmationDialog() {\n        // Create an AlertDialog.Builder and set the message, and click listeners\n        // for the postivie and negative buttons on the dialog.\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\n        builder.setMessage(R.string.delete_dialog_msg_single);\n        builder.setPositiveButton(R.string.delete, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Delete\" button, so delete the book.\n                deleteBook();\n            }\n        });\n        builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {\n            public void onClick(DialogInterface dialog, int id) {\n                // User clicked the \"Cancel\" button, so dismiss the dialog\n                // and continue editing the book.\n                if (dialog != null) {\n                    dialog.dismiss();\n                }\n            }\n        });\n\n        // Create and show the AlertDialog\n        AlertDialog alertDialog = builder.create();\n        alertDialog.show();\n    }\n\n    /**\n     * Perform the deletion of the book in the database.\n     */\n    private void deleteBook() {\n        // Only perform the delete if this is an existing book.\n        if (mCurrentBookUri != null) {\n            // Call the ContentResolver to delete the book at the given content URI.\n            // Pass in null for the selection and selection args because the mCurrentPetUri\n            // content URI already identifies the book that we want.\n            int rowsDeleted = getContentResolver().delete(mCurrentBookUri, null, null);\n            // Show a toast message depending on whether or not the delete was successful.\n            if (rowsDeleted == 0) {\n                // If no rows were deleted, then there was an error with the delete.\n                Toast.makeText(this, getString(R.string.editor_delete_book_failed),\n                        Toast.LENGTH_SHORT).show();\n            } else {\n                // Otherwise, the delete was successful and we can display a toast.\n                Toast.makeText(this, getString(R.string.editor_delete_book_successful),\n                        Toast.LENGTH_SHORT).show();\n            }\n            // Close the activity\n            finish();\n        }\n    }\n}\n"},
{"Line": "=>184", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (org.apache.commons.lang3.StringUtils.isBlank(input.getLeaseId())) { input.setLease(null); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/683/buggy-version/src.main.java.com.primetime.controller.DetailInventoryController.java", "BodyUseAPI": ["com.primetime.entity.DetailInventory.setLease(<nulltype>)"], "Fixed commit": "d8a57118bd98f66da6b9a2a7218aa9c6359289f2", "Url": "https://api.github.com/repos/ramanimukesh/backend", "Date": "2018-12-28T05:01:03Z"},
{"Line": "=>180", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["io.vertx.core.json.JsonObject.getJsonArray(java.lang.String,fr.wseduc.webutils.collections.JsonArray)"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (ids.contains(user.getUserId())) unread = \"true\";", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/254/buggy-version/conversation.src.main.java.org.entcore.conversation.service.impl.SqlConversationService.java", "BodyUseAPI": [], "Fixed commit": "2b296a548f53c03e3f2ca97aa8281e0f9175e122", "Url": "https://api.github.com/repos/opendigitaleducation/entcore", "Date": "2018-11-15T15:55:00Z", "Source Code Diff": "@@ -175,17 +175,18 @@ public void handle(Either<String, JsonObject> event) {\n \n \t\t\t\tJsonArray attachmentIds = event.right().getValue().getJsonArray(\"attachmentids\");\n \t\t\t\tlong totalQuota = event.right().getValue().getLong(\"totalquota\");\n-\n+\t\t\t\tString unread = \"false\";\n \t\t\t\tfinal JsonArray ids = message.getJsonArray(\"allUsers\", new fr.wseduc.webutils.collections.JsonArray());\n-\n+\t\t\t\tif(ids.contains(user.getUserId()))\n+\t\t\t\t\tunread = \"true\";\n \t\t\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n \n \t\t\t\tString updateMessage =\n \t\t\t\t\t\t\"UPDATE \" + messageTable + \" SET state = ? WHERE id = ? \"+\n \t\t\t\t\t\t\t\t\"RETURNING id, subject, body\";\n \t\t\t\tString updateUnread = \"UPDATE \" + userMessageTable + \" \" +\n-\t\t\t\t\t\t\"SET unread = true \" +\n-\t\t\t\t\t\t\"WHERE user_id = ? AND message_id = ? \";\n+\t\t\t\t\t\t\"SET unread = \" + unread +\n+\t\t\t\t\t\t\" WHERE user_id = ? AND message_id = ? \";\n \t\t\t\tbuilder.prepared(updateMessage, new fr.wseduc.webutils.collections.JsonArray().add(\"SENT\").add(draftId));\n \t\t\t\tbuilder.prepared(updateUnread, new fr.wseduc.webutils.collections.JsonArray().add(user.getUserId()).add(draftId));\n ", "Complete After Code": "/*\n * Copyright \u00a9 \"Open Digital Education\", 2016\n *\n * This program is published by \"Open Digital Education\".\n * You must indicate the name of the software and the company in any production /contribution\n * using the software and indicate on the home page of the software industry in question,\n * \"powered by Open Digital Education\" with a reference to the website: https://opendigitaleducation.com/.\n *\n * This program is free software, licensed under the terms of the GNU Affero General Public License\n * as published by the Free Software Foundation, version 3 of the License.\n *\n * You can redistribute this application and/or modify it since you respect the terms of the GNU Affero General Public License.\n * If you modify the source code and then use this modified source code in your creation, you must make available the source code of your modifications.\n *\n * You should have received a copy of the GNU Affero General Public License along with the software.\n * If not, please see : <http://www.gnu.org/licenses/>. Full compliance requires reading the terms of this license and following its directives.\n\n */\n\npackage org.entcore.conversation.service.impl;\n\nimport static fr.wseduc.webutils.Utils.isNotEmpty;\nimport static org.entcore.common.user.UserUtils.findVisibles;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport org.entcore.common.sql.Sql;\nimport org.entcore.common.sql.SqlResult;\nimport org.entcore.common.sql.SqlStatementsBuilder;\nimport org.entcore.common.user.UserInfos;\nimport org.entcore.common.user.UserUtils;\nimport org.entcore.common.utils.Config;\nimport org.entcore.common.utils.StringUtils;\nimport org.entcore.common.validation.StringValidation;\nimport org.entcore.conversation.Conversation;\nimport org.entcore.conversation.service.ConversationService;\nimport io.vertx.core.Handler;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.eventbus.EventBus;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\n\nimport fr.wseduc.webutils.Either;\nimport fr.wseduc.webutils.Server;\nimport fr.wseduc.webutils.Utils;\n\npublic class SqlConversationService implements ConversationService{\n\n\tprivate final EventBus eb;\n\tprivate final Sql sql;\n\n\tprivate final int maxFolderDepth;\n\n\tprivate final String messageTable;\n\tprivate final String folderTable;\n\tprivate final String attachmentTable;\n\tprivate final String userMessageTable;\n\tprivate final String userMessageAttachmentTable;\n\n\tpublic SqlConversationService(Vertx vertx, String schema) {\n\t\tthis.eb = Server.getEventBus(vertx);\n\t\tthis.sql = Sql.getInstance();\n\t\tthis.maxFolderDepth = Config.getConf().getInteger(\"max-folder-depth\", Conversation.DEFAULT_FOLDER_DEPTH);\n\t\tmessageTable = schema + \".messages\";\n\t\tfolderTable = schema + \".folders\";\n\t\tattachmentTable = schema + \".attachments\";\n\t\tuserMessageTable = schema + \".usermessages\";\n\t\tuserMessageAttachmentTable = schema + \".usermessagesattachments\";\n\t}\n\n\t@Override\n\tpublic void saveDraft(String parentMessageId, String threadId, JsonObject message, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tsave(parentMessageId, threadId, message, user, result);\n\t}\n\n\tprivate void save(String parentMessageId, String threadId, JsonObject message, UserInfos user, Handler<Either<String, JsonObject>> result){\n\t\tmessage\n\t\t\t.put(\"id\", UUID.randomUUID().toString())\n\t\t\t.put(\"from\", user.getUserId())\n\t\t\t.put(\"date\", System.currentTimeMillis())\n\t\t\t.put(\"state\", State.DRAFT.name());\n\n\t\tJsonObject m = Utils.validAndGet(message, MESSAGE_FIELDS, DRAFT_REQUIRED_FIELDS);\n\t\tif (validationError(user, m, result))\n\t\t\treturn;\n\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\tif(parentMessageId != null)\n\t\t\tmessage.put(\"parent_id\", parentMessageId);\n\n\t\tif(threadId != null){\n\t\t\tmessage.put(\"thread_id\", threadId);\n\t\t}else{\n\t\t\tmessage.put(\"thread_id\", message.getString(\"id\"));\n\t\t}\n\n\t\t// 1 - Insert message\n\t\tbuilder.insert(messageTable, message, \"id\");\n\n\t\t// 2 - Link message to the user\n\t\tbuilder.insert(userMessageTable, new JsonObject()\n\t\t\t.put(\"user_id\", user.getUserId())\n\t\t\t.put(\"message_id\", message.getString(\"id\")));\n\n\t\tsql.transaction(builder.build(), SqlResult.validUniqueResultHandler(0, result));\n\t}\n\n\t@Override\n\tpublic void updateDraft(String messageId, JsonObject message, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tupdate(messageId, message, user, result);\n\t}\n\n\tprivate void update(String messageId, JsonObject message, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tmessage.put(\"date\", System.currentTimeMillis());\n\t\tJsonObject m = Utils.validAndGet(message, UPDATE_DRAFT_FIELDS, UPDATE_DRAFT_REQUIRED_FIELDS);\n\t\tif (validationError(user, m, result, messageId))\n\t\t\treturn;\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tfor (String attr : message.fieldNames()) {\n\t\t\tif(\"to\".equals(attr) || \"cc\".equals(attr) || \"displayNames\".equals(attr)){\n\t\t\t\tsb.append(\"\\\"\" + attr+ \"\\\"\").append(\" = CAST(? AS JSONB),\");\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\"\" + attr+ \"\\\"\").append(\" = ?,\");\n\t\t\t}\n\t\t\tvalues.add(message.getValue(attr));\n\t\t}\n\t\tif(sb.length() > 0)\n\t\t\tsb.deleteCharAt(sb.length() - 1);\n\n\t\tString query =\n\t\t\t\"UPDATE \" + messageTable +\n\t\t\t\" SET \" + sb.toString() + \" \" +\n\t\t\t\"WHERE id = ? AND state = ?\";\n\t\tvalues.add(messageId).add(\"DRAFT\");\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\tprivate void getSenderAttachments(String senderId, String messageId, Handler<Either<String, JsonObject>> handler){\n\t\tString query =\n\t\t\t\"SELECT \" +\n\t\t\t\t\"coalesce(json_agg(distinct att.id), '[]'::json) as attachmentIds,\" +\n\t\t\t\t\"coalesce(sum(att.size), 0)::integer as totalQuota \" +\n\t\t\t\"FROM \" + attachmentTable + \" att \" +\n\t\t\t\"JOIN \" + userMessageAttachmentTable + \" uma \" +\n\t\t\t\t\"ON (att.id = uma.attachment_id) \" +\n\t\t\t\"JOIN \" + userMessageTable + \" um \" +\n\t\t\t\t\"ON um.user_id = uma.user_id AND um.message_id = uma.message_id \" +\n\t\t\t\"WHERE um.user_id = ? AND um.message_id = ?\";\n\n\t\tsql.prepared(query, new fr.wseduc.webutils.collections.JsonArray().add(senderId).add(messageId), SqlResult.validUniqueResultHandler(handler, \"attachmentids\"));\n\t}\n\n\t@Override\n\tpublic void send(final String parentMessageId, final String draftId, final JsonObject message, final UserInfos user, final Handler<Either<String, JsonObject>> result) {\n\t\tsendMessage(parentMessageId, draftId, message, user, result);\n\t}\n\n\tprivate void sendMessage(final String parentMessageId, final String draftId, final JsonObject message, final UserInfos user, final Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, draftId))\n\t\t\treturn;\n\n\t\tgetSenderAttachments(user.getUserId(), draftId, new Handler<Either<String,JsonObject>>() {\n\t\t\tpublic void handle(Either<String, JsonObject> event) {\n\t\t\t\tif(event.isLeft()){\n\t\t\t\t\tresult.handle(new Either.Left<String, JsonObject>(event.left().getValue()));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tJsonArray attachmentIds = event.right().getValue().getJsonArray(\"attachmentids\");\n\t\t\t\tlong totalQuota = event.right().getValue().getLong(\"totalquota\");\n\t\t\t\tString unread = \"false\";\n\t\t\t\tfinal JsonArray ids = message.getJsonArray(\"allUsers\", new fr.wseduc.webutils.collections.JsonArray());\n\t\t\t\tif(ids.contains(user.getUserId()))\n\t\t\t\t\tunread = \"true\";\n\t\t\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\t\t\tString updateMessage =\n\t\t\t\t\t\t\"UPDATE \" + messageTable + \" SET state = ? WHERE id = ? \"+\n\t\t\t\t\t\t\t\t\"RETURNING id, subject, body\";\n\t\t\t\tString updateUnread = \"UPDATE \" + userMessageTable + \" \" +\n\t\t\t\t\t\t\"SET unread = \" + unread +\n\t\t\t\t\t\t\" WHERE user_id = ? AND message_id = ? \";\n\t\t\t\tbuilder.prepared(updateMessage, new fr.wseduc.webutils.collections.JsonArray().add(\"SENT\").add(draftId));\n\t\t\t\tbuilder.prepared(updateUnread, new fr.wseduc.webutils.collections.JsonArray().add(user.getUserId()).add(draftId));\n\n\t\t\t\tfor(Object toObj : ids){\n\t\t\t\t\tif(toObj.equals(user.getUserId()))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tbuilder.insert(userMessageTable, new JsonObject()\n\t\t\t\t\t\t.put(\"user_id\", toObj.toString())\n\t\t\t\t\t\t.put(\"message_id\", draftId)\n\t\t\t\t\t\t.put(\"total_quota\", totalQuota)\n\t\t\t\t\t);\n\t\t\t\t\tfor(Object attachmentId : attachmentIds){\n\t\t\t\t\t\tbuilder.insert(userMessageAttachmentTable, new JsonObject()\n\t\t\t\t\t\t\t.put(\"user_id\", toObj.toString())\n\t\t\t\t\t\t\t.put(\"message_id\", draftId)\n\t\t\t\t\t\t\t.put(\"attachment_id\", attachmentId.toString())\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsql.transaction(builder.build(), SqlResult.validUniqueResultHandler(0, result));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void list(String folder, String restrain, Boolean unread, UserInfos user, int page,final String searchText, Handler<Either<String, JsonArray>> results) {\n\t\tint skip = page * LIST_LIMIT;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tString messageConditionUnread = addMessageConditionUnread(folder, values, unread, user);\n\t\tString messagesFields = \"m.id, m.subject, m.from, m.state, m.\\\"fromName\\\", m.to, m.\\\"toName\\\", m.cc, m.\\\"ccName\\\", m.\\\"displayNames\\\", m.date \";\n\n\t\tvalues.add(\"SENT\").add(user.getUserId());\n\t\tString additionalWhere = addCompleteFolderCondition(values, restrain, unread, folder, user);\n\n\t\tif(searchText != null){\n\t\t\tadditionalWhere += \" AND m.text_searchable  @@ to_tsquery(m.language::regconfig, unaccent(?)) \";\n\t\t\tvalues.add(StringUtils.join(checkAndComposeWordFromSearchText(searchText), \" & \"));\n\t\t}\n\t\tString query = \"SELECT \"+messagesFields+\", um.unread as unread, \" +\n\t\t\t\t\"CASE when COUNT(distinct r) = 0 THEN false ELSE true END AS response, COUNT(*) OVER() as count, \" +\n\t\t\t\t\"CASE when COUNT(distinct uma) = 0 THEN false ELSE true END AS  \\\"hasAttachment\\\" \" +\n\t\t\t\t\"FROM \" + userMessageTable + \" um LEFT JOIN \" +\n\t\t\t\tuserMessageAttachmentTable + \" uma ON um.user_id = uma.user_id AND um.message_id = uma.message_id JOIN \" +\n\t\t\t\tmessageTable + \" m ON (um.message_id = m.id\" + messageConditionUnread + \") LEFT JOIN \" +\n\t\t\t\tmessageTable + \" r ON um.message_id = r.parent_id AND r.from = um.user_id AND r.state= ? \" +\n\t\t\t\t\"WHERE um.user_id = ? \" + additionalWhere + \" \" +\n\t\t\t\t\"GROUP BY m.id, unread \" +\n\t\t\t\t\"ORDER BY m.date DESC LIMIT \" + LIST_LIMIT + \" OFFSET \" + skip;\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(results, \"attachments\", \"to\", \"toName\", \"cc\", \"ccName\", \"displayNames\"));\n\t}\n\n\t//TODO : add to utils (similar function in SearchEngineController)\n\tprivate List<String> checkAndComposeWordFromSearchText(final String searchText) {\n\t\tList<String> searchWords = new ArrayList<>();\n\t\tfinal String searchTextTreaty = searchText.replaceAll(\"\\\\s+\", \" \").trim();\n\t\tif (!searchTextTreaty.isEmpty()) {\n\t\t\tString[] words = searchTextTreaty.split(\" \");\n\t\t\tString tmp;\n\t\t\tfor (String w : words) {\n\t\t\t\ttmp = w.replaceAll(\"(?!')\\\\p{Punct}\", \"\");\n\t\t\t\tif(tmp.length() > 0)\n\t\t\t\t\tsearchWords.add(tmp);\n\t\t\t}\n\t\t}\n\t\treturn  searchWords;\n\t}\n\n\t@Override\n\tpublic void listThreads(UserInfos user, int page, Handler<Either<String, JsonArray>> results) {\n\t\tint nbThread =  10;\n\t\tint skip = page * nbThread;\n\t\tString messagesFields = \"id, date, subject, \\\"displayNames\\\", \\\"to\\\", \\\"from\\\", cc \";\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tvalues.add(user.getUserId());\n\t\tvalues.add(user.getUserId());\n\t\tString query = \" WITH threads AS ( \" +\n\t\t\t\t\" SELECT * from (SELECT  DISTINCT ON (m.thread_id) thread_id AS \"+messagesFields+ \" FROM \" + userMessageTable + \" um \" +\n\t\t\t\t\" JOIN \"+messageTable+\" m ON um.message_id = m.id \" +\n\t\t\t\t\" WHERE um.user_id = ? AND m.state = 'SENT' AND um.trashed = false ORDER BY m.thread_id, m.date DESC) a \"+\n\t\t\t\t\" ORDER BY date DESC LIMIT \"+ nbThread +\" OFFSET \"+ skip + \") \" +\n\n\t\t\t\t\"SELECT \"+ messagesFields +\", unread FROM threads JOIN (SELECT m.thread_id, SUM(CASE WHEN um.unread THEN 1 ELSE 0 END) AS unread \" +\n\t\t\t\t\"FROM threads, conversation.usermessages um JOIN conversation.messages m ON um.message_id = m.id and um.user_id= ? \" +\n\t\t\t\t\"WHERE  um.trashed = false AND m.thread_id=threads.id GROUP BY m.thread_id) c ON threads.id = c.thread_id \" +\n\t\t\t\t\"ORDER BY date DESC\";\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(results, \"to\", \"toName\", \"cc\", \"ccName\", \"displayNames\"));\n\t}\n\n\t@Override\n\tpublic void listThreadMessages(String threadId, int page, UserInfos user, Handler<Either<String, JsonArray>> results) {\n\t\tint skip = page * LIST_LIMIT;\n\t\tString messagesFields = \"m.id, m.parent_id, m.subject, m.body, m.from, m.\\\"fromName\\\", m.to, m.\\\"toName\\\", m.cc, m.\\\"ccName\\\", m.\\\"displayNames\\\", m.date, m.thread_id \";\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tvalues.add(user.getUserId());\n\t\tvalues.add(threadId);\n\n\t\tString query =\n\t\t\t\t\"SELECT \"+messagesFields+\", um.unread as unread FROM \" +userMessageTable + \" as um \" +\n\t\t\t\t\" JOIN \"+messageTable+\" as m ON um.message_id = m.id \" +\n\t\t\t\t\" WHERE um.user_id = ? AND m.thread_id = ? \" +\n\t\t\t\t\" AND m.state = 'SENT' AND um.trashed = false \" +\n\t\t\t\t\" ORDER BY m.date DESC LIMIT \" + LIST_LIMIT + \" OFFSET \" + skip;\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(results, \"to\", \"toName\", \"cc\", \"ccName\", \"displayNames\"));\n\t}\n\n\t@Override\n\tpublic void listThreadMessagesNavigation(String messageId, boolean previous, UserInfos user, Handler<Either<String, JsonArray>> results) {\n\t\tint maxMessageInThread = 15;\n\t\tString messagesFields = \"m.id, m.parent_id, m.subject, m.body, m.from, m.\\\"fromName\\\", m.to, m.\\\"toName\\\", m.cc, m.\\\"ccName\\\", m.\\\"displayNames\\\", m.date, m.thread_id \";\n\t\tString condition, limit;\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tif(previous){\n\t\t\tcondition = \" m.date < element.date \";\n\t\t\tlimit = \" LIMIT \"+ maxMessageInThread +\" OFFSET 0\";\n\t\t}else{\n\t\t\tcondition = \" m.date > element.date \";\n\t\t\tlimit = \"\";\n\t\t}\n\t\tvalues.add(messageId);\n\t\tvalues.add(user.getUserId());\n\n\t\tString query = \"WITH element AS ( \" +\n\t\t\t\t\" SELECT thread_id, date FROM \"+messageTable+\" WHERE id = ? ) \" +\n\t\t\t\t\"SELECT \"+messagesFields+\", um.unread as unread FROM element, \" +userMessageTable + \" as um \" +\n\t\t\t\t\" JOIN \"+messageTable+\" as m ON um.message_id = m.id \" +\n\t\t\t\t\" WHERE um.user_id = ? AND m.thread_id = element.thread_id \" +\n\t\t\t\t\" AND \" + condition +\n\t\t\t\t\" AND m.state = 'SENT' AND um.trashed = false \" +\n\t\t\t\t\" ORDER BY m.date DESC\" + limit;\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(results, \"to\", \"toName\", \"cc\", \"ccName\", \"displayNames\"));\n\t}\n\n\n\t@Override\n\tpublic void trash(List<String> messagesId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result))\n\t\t\treturn;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tStringBuilder query = new StringBuilder(\n\t\t\t\"UPDATE \" + userMessageTable + \" \" +\n\t\t\t\"SET trashed = true \" +\n\t\t\t\"WHERE trashed = false AND user_id = ? AND message_id IN (\");\n\n\t\tvalues.add(user.getUserId());\n\n\t\tfor(String id : messagesId){\n\t\t\tquery.append(\"?,\");\n\t\t\tvalues.add(id);\n\t\t}\n\t\tif(messagesId.size() > 0)\n\t\t\tquery.deleteCharAt(query.length() - 1);\n\t\tquery.append(\")\");\n\n\t\tsql.prepared(query.toString(), values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void trashThread(List<String> threadIds, UserInfos user, Handler<Either<String, JsonObject>> result){\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tStringBuilder query = new StringBuilder(\n\t\t\t\t\"UPDATE \" + userMessageTable + \" AS um  \" +\n\t\t\t\t\t\"SET trashed = true \" +\n\t\t\t\t\t\"FROM conversation.messages as m \" +\n\t\t\t\t\t\"WHERE m.thread_id IN \");\n\n\t\tquery.append(generateInVars(threadIds, values));\n\t\tquery.append(\" AND um.user_id = ? AND um.trashed = false AND um.message_id = m.id \");\n\t\tvalues.add(user.getUserId());\n\n\t\tsql.prepared(query.toString(), values, SqlResult.validUniqueResultHandler(result));\n\n\t}\n\n\n\t@Override\n\tpublic void restore(List<String> messagesId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result)) return;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tStringBuilder query = new StringBuilder(\n\t\t\t\"UPDATE \" + userMessageTable + \" \" +\n\t\t\t\"SET trashed = false \" +\n\t\t\t\"WHERE trashed = true AND user_id = ? AND message_id IN \");\n\n\t\tvalues.add(user.getUserId());\n\n\t\tquery.append(generateInVars(messagesId, values));\n\n\t\tsql.prepared(query.toString(), values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void delete(List<String> messagesId, Boolean deleteAll, UserInfos user, Handler<Either<String, JsonArray>> result) {\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\tJsonArray values2 = new fr.wseduc.webutils.collections.JsonArray();\n\t\tJsonArray values3 = new fr.wseduc.webutils.collections.JsonArray();\n\t\tvalues2.add(user.getUserId());\n\t\tvalues3.add(user.getUserId());\n\n\t\tString getTotalQuota =\n\t\t\t\"SELECT coalesce(sum(um.total_quota), 0)::integer AS totalQuota FROM \" + userMessageTable + \" um \" +\n\t\t\t\"WHERE um.user_id = ? AND um.trashed = true\";\n\n\t\tString deleteUserMessages =\n\t\t\t\"DELETE FROM \" + userMessageTable + \" um \" +\n\t\t\t\"WHERE um.user_id = ? AND um.trashed = true\";\n\n\t\tif (!deleteAll) {\n\t\t\tgetTotalQuota += \" AND um.message_id IN \";\n\t\t\tgetTotalQuota += (generateInVars(messagesId, values2));\n\t\t\tdeleteUserMessages += \" AND um.message_id IN \";\n\t\t\tdeleteUserMessages += (generateInVars(messagesId, values3));\n\t\t}\n\n\t\tbuilder.prepared(getTotalQuota, values2);\n\t\tbuilder.prepared(deleteUserMessages, values3);\n\n\t\tsql.transaction(builder.build(), SqlResult.validResultsHandler(result));\n\t}\n\n\t@Override\n\tpublic void get(String messageId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, messageId))\n\t\t\treturn;\n\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\tString updateQuery = \"UPDATE \" + userMessageTable + \" \" +\n\t\t\t\"SET unread = false \" +\n\t\t\t\"WHERE user_id = ? AND message_id = ? \";\n\n\t\tString selectQuery =\n\t\t\t\"SELECT \" +\n\t\t\t\t\"m.*, \" +\n\t\t\t\t\"CASE WHEN COUNT(distinct att) = 0 THEN '[]' ELSE json_agg(distinct att.*) END AS attachments \" +\n\t\t\t\"FROM \" + messageTable + \" m \" +\n\t\t\t\"JOIN \" + userMessageTable + \" um \" +\n\t\t\t\t\"ON m.id = um.message_id \" +\n\t\t\t\"LEFT JOIN \" + userMessageAttachmentTable + \" uma USING (user_id, message_id) \" +\n\t\t\t\"LEFT JOIN \" + attachmentTable + \" att \" +\n\t\t\t\t\"ON att.id = uma.attachment_id \" +\n\t\t\t\"WHERE um.user_id = ? AND m.id = ?  \" +\n\t\t\t\"GROUP BY m.id\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(user.getUserId())\n\t\t\t.add(messageId);\n\n\t\tbuilder.prepared(updateQuery, values);\n\t\tbuilder.prepared(selectQuery, values);\n\n\t\tsql.transaction(builder.build(), SqlResult.validUniqueResultHandler(1, result, \"attachments\", \"to\", \"toName\", \"cc\", \"ccName\", \"displayNames\"));\n\t}\n\n\t@Override\n\tpublic void count(String folder, String restrain, Boolean unread, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, folder))\n\t\t\treturn;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tString messageConditionUnread = addMessageConditionUnread(folder, values, unread, user);\n\t\tvalues.add(user.getUserId());\n\n\t\tString query = \"SELECT count(*) as count FROM \" + userMessageTable + \" um JOIN \" +\n\t\t\tmessageTable + \" m ON (um.message_id = m.id\" + messageConditionUnread + \") \" +\n\t\t\t\"WHERE user_id = ? \";\n\n\t\tquery += addCompleteFolderCondition(values, restrain, unread, folder, user);\n\n\t\tif(restrain != null && unread){\n\t\t\tquery += \" AND (m.from <> ? OR m.to @> ?::jsonb OR m.cc @> ?::jsonb) \";\n\t\t\tvalues.add(user.getUserId());\n\t\t\tvalues.add(new fr.wseduc.webutils.collections.JsonArray().add(user.getUserId()).toString());\n\t\t\tvalues.add(new fr.wseduc.webutils.collections.JsonArray().add(user.getUserId()).toString());\n\t\t}\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void findVisibleRecipients(final String parentMessageId, final UserInfos user,\n\t\t\tfinal String acceptLanguage, final String search, final Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result))\n\t\t\treturn;\n\n\t\tfinal JsonObject visible = new JsonObject();\n\n\t\tfinal JsonObject params = new JsonObject();\n\n\t\tfinal String preFilter;\n\t\tif (isNotEmpty(search)) {\n\t\t\tpreFilter = \"AND (m:Group OR m.displayNameSearchField CONTAINS {search}) \";\n\t\t\tparams.put(\"search\", StringValidation.sanitize(search));\n\t\t} else {\n\t\t\tpreFilter = null;\n\t\t}\n\n\t\tif (parentMessageId != null && !parentMessageId.trim().isEmpty()) {\n\t\t\tString getMessageQuery = \"SELECT m.* FROM \" + messageTable +\n\t\t\t\t\" WHERE id = ?\";\n\t\t\tsql.prepared(getMessageQuery, new fr.wseduc.webutils.collections.JsonArray().add(parentMessageId),\n\t\t\t\tSqlResult.validUniqueResultHandler(new Handler<Either<String,JsonObject>>() {\n\t\t\t\tpublic void handle(Either<String, JsonObject> event) {\n\t\t\t\t\tif(event.isLeft()){\n\t\t\t\t\t\tresult.handle(event);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal JsonArray to = event.right().getValue().getJsonArray(\"to\");\n\t\t\t\t\tfinal JsonArray cc = event.right().getValue().getJsonArray(\"cc\");\n\n\t\t\t\t\tparams.put(\"to\", to)\n\t\t\t\t\t\t.put(\"cc\", cc);\n\n\t\t\t\t\tString customReturn =\n\t\t\t\t\t\t\t\"MATCH (v:Visible) \" +\n\t\t\t\t\t\t\t\"WHERE (v.id = visibles.id OR v.id IN {to} OR v.id IN {cc}) \" +\n\t\t\t\t\t\t\t\"RETURN DISTINCT visibles.id as id, visibles.name as name, \" +\n\t\t\t\t\t\t\t\"visibles.displayName as displayName, visibles.groupDisplayName as groupDisplayName, \" +\n\t\t\t\t\t\t\t\"visibles.profiles[0] as profile, visibles.structureName as structureName \";\n\t\t\t\t\tcallFindVisibles(user, acceptLanguage, result, visible, params, preFilter, customReturn);\n\t\t\t\t}\n\t\t\t}));\n\t\t} else {\n\t\t\tString customReturn =\n\t\t\t\t\t\"RETURN DISTINCT visibles.id as id, visibles.name as name, \" +\n\t\t\t\t\t\"visibles.displayName as displayName, visibles.groupDisplayName as groupDisplayName, \" +\n\t\t\t\t\t\"visibles.profiles[0] as profile, visibles.structureName as structureName\";\n\t\t\tcallFindVisibles(user, acceptLanguage, result, visible, params, preFilter, customReturn);\n\t\t}\n\t}\n\n\tprivate void callFindVisibles(UserInfos user, final String acceptLanguage, final Handler<Either<String, JsonObject>> result,\n\t\t\tfinal JsonObject visible, JsonObject params, String preFilter, String customReturn) {\n\t\tfindVisibles(eb, user.getUserId(), customReturn, params, true, true, false, acceptLanguage, preFilter, new Handler<JsonArray>() {\n\t\t\t@Override\n\t\t\tpublic void handle(JsonArray visibles) {\n\t\t\t\tJsonArray users = new fr.wseduc.webutils.collections.JsonArray();\n\t\t\t\tJsonArray groups = new fr.wseduc.webutils.collections.JsonArray();\n\t\t\t\tvisible.put(\"groups\", groups).put(\"users\", users);\n\t\t\t\tfor (Object o: visibles) {\n\t\t\t\t\tif (!(o instanceof JsonObject)) continue;\n\t\t\t\t\tJsonObject j = (JsonObject) o;\n\t\t\t\t\tif (j.getString(\"name\") != null) {\n\t\t\t\t\t\tj.remove(\"displayName\");\n\t\t\t\t\t\tUserUtils.groupDisplayName(j, acceptLanguage);\n\t\t\t\t\t\tgroups.add(j);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj.remove(\"name\");\n\t\t\t\t\t\tusers.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.handle(new Either.Right<String,JsonObject>(visible));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void toggleUnread(List<String> messagesIds, boolean unread, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result))\n\t\t\treturn;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tString query = \"UPDATE \" + userMessageTable + \" \" +\n\t\t\t\t\"SET unread = ? \" +\n\t\t\t\t\"WHERE user_id = ? AND message_id IN \"  + Sql.listPrepared(messagesIds.toArray());\n\n\t\tvalues.add(unread);\n\t\tvalues.add(user.getUserId());\n\t\tfor(String id : messagesIds){\n\t\t\tvalues.add(id);\n\t\t}\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void toggleUnreadThread(List<String> threadIds, boolean unread, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tStringBuilder query = new StringBuilder(\n\t\t\t\t\"UPDATE \" + userMessageTable + \" AS um  \" +\n\t\t\t\t\t\t\"SET  unread = ? \" +\n\t\t\t\t\t\t\"FROM conversation.messages as m \" +\n\t\t\t\t\t\t\"WHERE m.thread_id IN \");\n\t\tvalues.add(unread);\n\t\tquery.append(generateInVars(threadIds, values));\n\t\tquery.append(\" AND um.user_id = ? AND um.message_id = m.id \");\n\t\tvalues.add(user.getUserId());\n\n\t\tsql.prepared(query.toString(), values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\n\t@Override\n\tpublic void createFolder(final String folderName, final String parentFolderId, final UserInfos user,\n\t\t\tfinal Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, folderName))\n\t\t\treturn;\n\n\t\tfinal SqlStatementsBuilder builder = new SqlStatementsBuilder();\n\t\tfinal JsonObject messageObj = new JsonObject()\n\t\t\t.put(\"id\", UUID.randomUUID().toString())\n\t\t\t.put(\"name\", folderName)\n\t\t\t.put(\"user_id\", user.getUserId());\n\n\t\tif (parentFolderId != null) {\n\t\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t\t.add(user.getUserId())\n\t\t\t\t.add(parentFolderId);\n\t\t\tString depthQuery = \"SELECT depth FROM \" + folderTable + \" WHERE user_id = ? AND id = ?\";\n\t\t\tsql.prepared(depthQuery, values, SqlResult.validUniqueResultHandler(new Handler<Either<String,JsonObject>>() {\n\t\t\t\tpublic void handle(Either<String, JsonObject> event) {\n\t\t\t\t\tif(event.isLeft()){\n\t\t\t\t\t\tresult.handle(event);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tint parentDepth = event.right().getValue().getInteger(\"depth\");\n\t\t\t\t\tif(parentDepth >= maxFolderDepth){\n\t\t\t\t\t\tresult.handle(new Either.Left<String, JsonObject>(\"error.max.folder.depth\"));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tmessageObj\n\t\t\t\t\t\t.put(\"parent_id\", parentFolderId)\n\t\t\t\t\t\t.put(\"depth\", parentDepth + 1);\n\n\t\t\t\t\tbuilder.insert(folderTable, messageObj);\n\n\t\t\t\t\tsql.transaction(builder.build(), SqlResult.validUniqueResultHandler(result));\n\t\t\t\t}\n\t\t\t}));\n\t\t} else {\n\t\t\tsql.insert(folderTable, messageObj, SqlResult.validUniqueResultHandler(result));\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void updateFolder(String folderId, JsonObject data, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, data.getString(\"name\")))\n\t\t\treturn;\n\n\t\tString query = \"UPDATE \" + folderTable + \" AS f \" +\n\t\t\t\"SET name = ? \" +\n\t\t\t\"WHERE f.id = ? AND f.user_id = ?\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(data.getString(\"name\"))\n\t\t\t.add(folderId)\n\t\t\t.add(user.getUserId());\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void listFolders(String parentId, UserInfos user, Handler<Either<String, JsonArray>> result) {\n\t\tif(validationError(user, result))\n\t\t\treturn;\n\n\t\tString query =\n\t\t\t\"SELECT f.* FROM \" + folderTable + \" AS f \" +\n\t\t\t\"WHERE f.user_id = ? AND f.trashed = false \";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(user.getUserId());\n\n\t\tif(parentId == null){\n\t\t\tquery += \"AND f.parent_id IS NULL\";\n\t\t} else {\n\t\t\tquery += \"AND f.parent_id = ?\";\n\t\t\tvalues.add(parentId);\n\t\t}\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void listTrashedFolders(UserInfos user, Handler<Either<String, JsonArray>> result) {\n\t\tif(validationError(user, result))\n\t\t\treturn;\n\n\t\tString query =\n\t\t\t\"SELECT f.* FROM \" + folderTable + \" AS f \" +\n\t\t\t\"WHERE f.user_id = ? AND f.trashed = true \";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(user.getUserId());\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void moveToFolder(List<String> messageIds, String folderId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result, folderId))\n\t\t\treturn;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tString query =\n\t\t\t\"UPDATE \" + userMessageTable + \" AS um \" +\n\t\t\t\"SET folder_id = ? \" +\n\t\t\t\"WHERE um.user_id = ? AND um.message_id IN \";\n\n\t\tvalues\n\t\t\t.add(folderId)\n\t\t\t.add(user.getUserId());\n\n\t\tquery += generateInVars(messageIds, values);\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void backToSystemFolder(List<String> messageIds, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result))\n\t\t\treturn;\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\n\t\tString query =\n\t\t\t\"UPDATE \" + userMessageTable + \" AS um \" +\n\t\t\t\"SET folder_id = NULL \" +\n\t\t\t\"WHERE um.user_id = ? AND um.message_id IN \";\n\n\t\tvalues.add(user.getUserId());\n\n\t\tquery += generateInVars(messageIds, values);\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void trashFolder(String folderId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tString query =\n\t\t\t\"UPDATE \" + folderTable + \" AS f \" +\n\t\t\t\"SET trashed = ? \" +\n\t\t\t\"WHERE f.id = ? AND f.user_id = ? AND f.trashed = ?\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(true)\n\t\t\t.add(folderId)\n\t\t\t.add(user.getUserId())\n\t\t\t.add(false);\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void restoreFolder(String folderId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tString query =\n\t\t\t\"UPDATE \" + folderTable + \" AS f \" +\n\t\t\t\"SET trashed = ? \" +\n\t\t\t\"WHERE f.id = ? AND f.user_id = ? AND f.trashed = ?\";\n\n\t\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t\t.add(false)\n\t\t\t\t.add(folderId)\n\t\t\t\t.add(user.getUserId())\n\t\t\t\t.add(true);\n\n\t\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void deleteFolder(String folderId, Boolean deleteAll, UserInfos user, Handler<Either<String, JsonArray>> result) {\n\t\tif (!deleteAll) {\n\t\t\tif(validationError(user, result, folderId))\n\t\t\t\treturn;\n\t\t}\n\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\t/* Get all parent folders with recursion */\n\n\t\tString nonRecursiveTerm =\n\t\t\t\"SELECT DISTINCT f.* FROM \" + folderTable + \" AS f \" +\n\t\t\t\"WHERE \";\n\t\tJsonArray recursiveValues = new fr.wseduc.webutils.collections.JsonArray();\n\t\tif (!deleteAll) {\n\t\t\tnonRecursiveTerm += \"f.id = ? AND \";\n\t\t\trecursiveValues.add(folderId);\n\t\t}\n\t\tnonRecursiveTerm += \"f.user_id = ? AND f.trashed = true \";\n\t\trecursiveValues.add(user.getUserId());\n\n\t\tString recursiveTerm =\n\t\t\t\"SELECT f.* FROM \" + folderTable + \" AS f JOIN \" +\n\t\t\t\"parents ON f.parent_id = parents.id \" +\n\t\t\t\"WHERE f.user_id = ?\";\n\t\trecursiveValues.add(user.getUserId());\n\n\t\t/* Get quota to free */\n\n\t\tString quotaRecursion =\n\t\t\t\"WITH RECURSIVE parents AS ( \"+\n\t\t\t\t\tnonRecursiveTerm +\n\t\t\t\t\t\"UNION \" +\n\t\t\t\t\trecursiveTerm +\n\t\t\t\") \" +\n\t\t\t\"SELECT COALESCE(sum(um.total_quota), 0)::integer AS totalQuota FROM parents JOIN \" +\n\t\t\tuserMessageTable + \" um ON um.folder_id = parents.id AND um.user_id = parents.user_id \";\n\n\t\tbuilder.prepared(quotaRecursion, recursiveValues);\n\n\t\t/* Physically delete the folder, which will start a cascading delete process for parent folders, messages and attachments. */\n\n\t\tString deleteFolder =\n\t\t\t\"DELETE FROM \" + folderTable + \" f \" +\n\t\t\t\"WHERE \";\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray();\n\t\tif (!deleteAll) {\n\t\t\tdeleteFolder += \"f.id = ? AND \";\n\t\t\tvalues.add(folderId);\n\t\t}\n\t\tdeleteFolder += \"f.user_id = ? AND f.trashed = true\";\n\t\tvalues.add(user.getUserId());\n\n\n\t\tbuilder.prepared(deleteFolder, values);\n\n\t\t/* Perform the transaction */\n\n\t\tsql.transaction(builder.build(), SqlResult.validResultsHandler(result));\n\n\t}\n\n\t@Override\n\tpublic void addAttachment(String messageId, UserInfos user, JsonObject uploaded, Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result, messageId))\n\t\t\treturn;\n\n\t\tlong attachmentSize = uploaded.getJsonObject(\"metadata\", new JsonObject()).getLong(\"size\", 0l);\n\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\tJsonObject attParams = new JsonObject()\n\t\t\t.put(\"id\", uploaded.getString(\"_id\"))\n\t\t\t.put(\"name\", uploaded.getJsonObject(\"metadata\").getString(\"name\"))\n\t\t\t.put(\"filename\", uploaded.getJsonObject(\"metadata\").getString(\"filename\"))\n\t\t\t.put(\"contentType\", uploaded.getJsonObject(\"metadata\").getString(\"content-type\"))\n\t\t\t.put(\"contentTransferEncoding\", uploaded.getJsonObject(\"metadata\").getString(\"content-transfer-encoding\"))\n\t\t\t.put(\"charset\", uploaded.getJsonObject(\"metadata\").getString(\"charset\"))\n\t\t\t.put(\"size\", attachmentSize);\n\n\t\tbuilder.insert(attachmentTable, attParams, \"id\");\n\n\t\tJsonObject umaParams = new JsonObject()\n\t\t\t.put(\"user_id\", user.getUserId())\n\t\t\t.put(\"message_id\", messageId)\n\t\t\t.put(\"attachment_id\", uploaded.getString(\"_id\"));\n\n\t\tbuilder.insert(userMessageAttachmentTable, umaParams);\n\n\t\tString query =\n\t\t\t\"UPDATE \" + userMessageTable + \" AS um \" +\n\t\t\t\"SET total_quota = total_quota + ? \" +\n\t\t\t\"WHERE um.user_id = ? AND um.message_id = ?\";\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(attachmentSize)\n\t\t\t.add(user.getUserId())\n\t\t\t.add(messageId);\n\n\t\tbuilder.prepared(query, values);\n\n\t\tsql.transaction(builder.build(), SqlResult.validUniqueResultHandler(0, result));\n\t}\n\n\t@Override\n\tpublic void getAttachment(String messageId, String attachmentId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result, messageId, attachmentId))\n\t\t\treturn;\n\n\t\tString query =\n\t\t\t\"SELECT att.* FROM \" + attachmentTable + \" att JOIN \" +\n\t\t\tuserMessageAttachmentTable + \" uma ON uma.attachment_id = att.id \" +\n\t\t\t\"WHERE att.id = ? AND uma.user_id = ? AND uma.message_id = ?\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(attachmentId)\n\t\t\t.add(user.getUserId())\n\t\t\t.add(messageId);\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void getAllAttachments(String messageId, UserInfos user, Handler<Either<String, JsonArray>> result) {\n\t\tif (user == null) {\n\t\t\tresult.handle(new Either.Left<String, JsonArray>(\"conversation.invalid.user\"));\n\t\t\treturn;\n\t\t}\n\t\tif (messageId == null) {\n\t\t\tresult.handle(new Either.Left<String, JsonArray>(\"conversation.invalid.parameter\"));\n\t\t\treturn;\n\t\t}\n\n\t\tString query =\n\t\t\t\"SELECT att.* FROM \" + attachmentTable + \" att JOIN \" +\n\t\t\tuserMessageAttachmentTable + \" uma ON uma.attachment_id = att.id \" +\n\t\t\t\"WHERE uma.user_id = ? AND uma.message_id = ?\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(user.getUserId())\n\t\t\t.add(messageId);\n\n\t\tsql.prepared(query, values, SqlResult.validResultHandler(result));\n\t}\n\n\t@Override\n\tpublic void removeAttachment(String messageId, String attachmentId, UserInfos user, final Handler<Either<String, JsonObject>> result) {\n\t\tif(validationParamsError(user, result, messageId, attachmentId))\n\t\t\treturn;\n\n\t\tSqlStatementsBuilder builder = new SqlStatementsBuilder();\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t.add(messageId)\n\t\t\t.add(user.getUserId())\n\t\t\t.add(attachmentId);\n\n\t\tString query1 =\n\t\t\t\"SELECT att.* FROM \" + attachmentTable + \" att WHERE att.id = ?\";\n\t\tbuilder.prepared(query1, new fr.wseduc.webutils.collections.JsonArray().add(attachmentId));\n\n\t\tString query2 =\n\t\t\t\"SELECT (count(*) = 1) AS deletionCheck FROM \" + attachmentTable + \" att JOIN \" +\n\t\t\tuserMessageAttachmentTable + \" uma ON uma.attachment_id = att.id \" +\n\t\t\t\"WHERE att.id = ? \" +\n\t\t\t\"GROUP BY att.id HAVING count(distinct uma.user_id) = 1 AND count(distinct uma.message_id) = 1\";\n\t\tbuilder.prepared(query2, new fr.wseduc.webutils.collections.JsonArray().add(attachmentId));\n\n\t\tString query3 =\n\t\t\t\"WITH attachment AS (\" +\n\t\t\t\tquery1 +\n\t\t\t\") \" +\n\t\t\t\"UPDATE \" + userMessageTable + \" AS um \" +\n\t\t\t\"SET total_quota = um.total_quota - (SELECT SUM(DISTINCT attachment.size) FROM attachment) \" +\n\t\t\t\"WHERE um.message_id = ? AND um.user_id = ?\";\n\t\tJsonArray values3 = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t\t.add(attachmentId)\n\t\t\t\t.add(messageId)\n\t\t\t\t.add(user.getUserId());\n\t\tbuilder.prepared(query3, values3);\n\n\t\tString query4 =\n\t\t\t\"DELETE FROM \" + userMessageAttachmentTable + \" WHERE \" +\n\t\t\t\"message_id = ? AND user_id = ? AND attachment_id = ?\";\n\t\tbuilder.prepared(query4, values);\n\n\t\tsql.transaction(builder.build(), SqlResult.validResultsHandler(new Handler<Either<String,JsonArray>>() {\n\t\t\tpublic void handle(Either<String, JsonArray> event) {\n\t\t\t\tif(event.isLeft()){\n\t\t\t\t\tresult.handle(new Either.Left<String, JsonObject>(event.left().getValue()));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tJsonArray results = event.right().getValue();\n\t\t\t\t\tJsonObject attachment = results.getJsonArray(0).getJsonObject(0);\n\t\t\t\t\tboolean deletionCheck = results.getJsonArray(1).size() > 0 ?\n\t\t\t\t\t\t\tresults.getJsonArray(1).getJsonObject(0).getBoolean(\"deletioncheck\", false) :\n\t\t\t\t\t\t\tfalse;\n\t\t\t\t\tJsonObject resultJson = new JsonObject()\n\t\t\t\t\t\t.put(\"deletionCheck\", deletionCheck)\n\t\t\t\t\t\t.put(\"fileId\", attachment.getString(\"id\"))\n\t\t\t\t\t\t.put(\"fileSize\", attachment.getLong(\"size\"));\n\n\t\t\t\t\tresult.handle(new Either.Right<String, JsonObject>(resultJson));\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\t@Override\n\tpublic void forwardAttachments(String forwardId, String messageId, UserInfos user, Handler<Either<String, JsonObject>> result) {\n\t\tif (validationParamsError(user, result, messageId))\n\t\t\treturn;\n\n\t\tString query =\n\t\t\t\"WITH messageAttachments AS (\" +\n\t\t\t\t\"SELECT * FROM \" + userMessageAttachmentTable + \" \" +\n\t\t\t\t\"WHERE user_id = ? AND message_id = ?\" +\n\t\t\t\") \" +\n\t\t\t\"INSERT INTO \" + userMessageAttachmentTable + \" \" +\n\t\t\t\"SELECT user_id, ? AS message_id, attachment_id FROM messageAttachments\";\n\n\t\tJsonArray values = new fr.wseduc.webutils.collections.JsonArray()\n\t\t\t\t.add(user.getUserId())\n\t\t\t\t.add(forwardId)\n\t\t\t\t.add(messageId);\n\n\t\tsql.prepared(query, values, SqlResult.validUniqueResultHandler(result));\n\t}\n\n\t///////////\n\t/* Utils */\n\n\tprivate String formatArray(JsonArray array){\n\t\treturn formatArray(array, \",\", \"{\", \"}\");\n\t}\n\tprivate String formatArray(JsonArray array, String delimiter, String prefix, String postfix){\n\t\tif(array.size() == 0){\n\t\t\treturn \"{}\";\n\t\t}\n\t\tStringBuilder builder = new StringBuilder(prefix);\n\t\tfor(Object obj : array){\n\t\t\tbuilder.append(obj.toString() + delimiter);\n\t\t}\n\t\tif(array.size() > 0)\n\t\t\tbuilder.delete(0, builder.length() - delimiter.length());\n\t\tbuilder.append(postfix);\n\t\treturn builder.toString();\n\t}\n\n\tprivate String generateInVars(List<String> list, JsonArray values){\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"(\");\n\n\t\tfor(String item : list){\n\t\t\tbuilder.append(\"?,\");\n\t\t\tvalues.add(item);\n\t\t}\n\t\tif(list.size() > 0)\n\t\t\tbuilder.deleteCharAt(builder.length() - 1);\n\t\tbuilder.append(\")\");\n\n\t\treturn builder.toString();\n\t}\n\n\tprivate String addFolderCondition(String folder, JsonArray values, String userId){\n\t\tString additionalWhere = \"\";\n\t\tswitch(folder.toUpperCase()){\n\t\t\tcase \"INBOX\":\n\t\t\t\tadditionalWhere = \"AND (m.from <> ? OR m.to @> ?::jsonb OR m.cc @> ?::jsonb) AND m.state = ? AND um.trashed = false\";\n\t\t\t\tadditionalWhere += \" AND um.folder_id IS NULL\";\n\t\t\t\tvalues.add(userId);\n\t\t\t\tvalues.add(new fr.wseduc.webutils.collections.JsonArray().add(userId).toString());\n\t\t\t\tvalues.add(new fr.wseduc.webutils.collections.JsonArray().add(userId).toString());\n\t\t\t\tvalues.add(\"SENT\");\n\t\t\t\tbreak;\n\t\t\tcase \"OUTBOX\":\n\t\t\t\tadditionalWhere = \"AND m.from = ? AND m.state = ? AND um.trashed = false\";\n\t\t\t\tadditionalWhere += \" AND um.folder_id IS NULL\";\n\t\t\t\tvalues.add(userId);\n\t\t\t\tvalues.add(\"SENT\");\n\t\t\t\tbreak;\n\t\t\tcase \"DRAFT\":\n\t\t\t\tadditionalWhere = \"AND m.from = ? AND m.state = ? AND um.trashed = false\";\n\t\t\t\tadditionalWhere += \" AND um.folder_id IS NULL\";\n\t\t\t\tvalues.add(userId);\n\t\t\t\tvalues.add(\"DRAFT\");\n\t\t\t\tbreak;\n\t\t\tcase \"TRASH\":\n\t\t\t\tadditionalWhere = \"AND um.trashed = true\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn additionalWhere;\n\t}\n\n\tprivate String addCompleteFolderCondition(JsonArray values, String restrain, Boolean unread, String folder, UserInfos user) {\n\t\tString additionalWhere = \"\";\n\t\tif(unread != null && unread){\n\t\t\tadditionalWhere += \"AND unread = ? \";\n\t\t\tvalues.add(unread);\n\t\t}\n\t\tif(restrain != null){\n\t\t\tadditionalWhere += \"AND um.folder_id = ? AND um.trashed = false\";\n\t\t\tvalues.add(folder);\n\t\t} else {\n\t\t\tadditionalWhere += addFolderCondition(folder, values, user.getUserId());\n\t\t}\n\n\t\treturn additionalWhere;\n\t}\n\n\tprivate String addMessageConditionUnread(String folder, JsonArray values, Boolean unread, UserInfos user) {\n\t\tString messageConditionUnread = \"\";\n\n\t\tif (unread != null && unread) {\n\t\t\tString upFolder = folder.toUpperCase();\n\n\t\t\t// Only for user folders and trash\n\t\t\tif (!upFolder.equals(\"INBOX\") && !upFolder.equals(\"OUTBOX\") && !upFolder.equals(\"DRAFT\")) {\n\t\t\t\tmessageConditionUnread = \" AND m.state = ?\";\n\t\t\t\tvalues.add(\"SENT\");\n\t\t\t}\n\t\t}\n\n\t\treturn messageConditionUnread;\n\t}\n\n\tprivate boolean validationError(UserInfos user, Handler<Either<String, JsonArray>> results, String ... params) {\n\t\tif (user == null) {\n\t\t\tresults.handle(new Either.Left<String, JsonArray>(\"conversation.invalid.user\"));\n\t\t\treturn true;\n\t\t}\n\t\tif (params.length > 0) {\n\t\t\tfor (String s : params) {\n\t\t\t\tif (s == null) {\n\t\t\t\t\tresults.handle(new Either.Left<String, JsonArray>(\"conversation.invalid.parameter\"));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean validationParamsError(UserInfos user,\n\t\t\tHandler<Either<String, JsonObject>> result, String ... params) {\n\t\tif (user == null) {\n\t\t\tresult.handle(new Either.Left<String, JsonObject>(\"conversation.invalid.user\"));\n\t\t\treturn true;\n\t\t}\n\t\tif (params.length > 0) {\n\t\t\tfor (String s : params) {\n\t\t\t\tif (s == null) {\n\t\t\t\t\tresult.handle(new Either.Left<String, JsonObject>(\"conversation.invalid.parameter\"));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean validationError(UserInfos user, JsonObject c,\n\t\t\tHandler<Either<String, JsonObject>> result, String ... params) {\n\t\tif (c == null) {\n\t\t\tresult.handle(new Either.Left<String, JsonObject>(\"conversation.invalid.fields\"));\n\t\t\treturn true;\n\t\t}\n\t\treturn validationParamsError(user, result, params);\n\t}\n\n}\n"},
{"Line": "=>148", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (tile.equals(\"J0\")) { hand.add(new naya.Joker()); }else if (tile.equals(\"X\")) { hand.add(this.unusedTiles.drawTile()); }else { hand.add(new naya.Tile(tile)); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/90/buggy-version/src.main.java.naya.InputFileParser.java", "BodyUseAPI": ["java.lang.String.equals(java.lang.String)", "java.util.ArrayList<naya.Tile>.add(naya.Tile)"], "Fixed commit": "7851f2fca0ef78e0edde9b6c7c2ba796b1954865", "Url": "https://api.github.com/repos/nguyandy/naya", "Date": "2018-11-29T17:39:50Z"},
{"Line": "=>139", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((stepDetailFragment) != null) { getSupportFragmentManager().putFragment(outState, com.dappslocker.bakingapp.RecipeDetailActivity.KEY_STEP_DETAIL_FRAGMENT, stepDetailFragment); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/762/buggy-version/app.src.main.java.com.dappslocker.bakingapp.RecipeDetailActivity.java", "BodyUseAPI": [], "Fixed commit": "9949fdb317671b376f78c572260c1fdd28bd888a", "Url": "https://api.github.com/repos/applocker/baking-app", "Date": "2018-12-16T17:27:53Z", "Source Code Diff": "@@ -129,15 +129,17 @@ protected void onRestoreInstanceState(Bundle savedInstanceState) {\n         recipeId = savedInstanceState.getInt(RECIPE_ID);\n         detailListFragment = (DetailListFragment) getSupportFragmentManager().getFragment(savedInstanceState,KEY_DETAIL_FRAGMENT);\n         stepDetailFragment = (StepDetailFragment) getSupportFragmentManager().getFragment(savedInstanceState,KEY_STEP_DETAIL_FRAGMENT);\n+        setupViewModel(recipeId);\n     }\n \n     @Override\n     protected void onSaveInstanceState(Bundle outState) {\n-        super.onSaveInstanceState(outState);\n         outState.putInt(RECIPE_ID, recipeId);\n         getSupportFragmentManager().putFragment(outState,KEY_DETAIL_FRAGMENT,detailListFragment);\n-        getSupportFragmentManager().putFragment(outState,KEY_STEP_DETAIL_FRAGMENT,stepDetailFragment);\n-\n+        if(stepDetailFragment != null ){\n+            getSupportFragmentManager().putFragment(outState,KEY_STEP_DETAIL_FRAGMENT,stepDetailFragment);\n+        }\n+        super.onSaveInstanceState(outState);\n     }\n \n     @Override", "Complete After Code": "package com.dappslocker.bakingapp;\n\nimport android.arch.lifecycle.Observer;\nimport android.arch.lifecycle.ViewModelProviders;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.annotation.VisibleForTesting;\nimport android.support.test.espresso.IdlingResource;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentTransaction;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.MenuItem;\nimport android.widget.FrameLayout;\n\nimport com.dappslocker.bakingapp.model.Recipe;\nimport com.dappslocker.bakingapp.viewmodels.AddRecipeDetailViewModelFactory;\nimport com.dappslocker.bakingapp.viewmodels.RecipeDetailActivityViewModel;\n\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n\npublic class RecipeDetailActivity extends AppCompatActivity implements DetailListFragment.OnRecipeDetailClickedListener{\n    @SuppressWarnings(\"WeakerAccess\")\n    @BindView(R.id.frameLayoutDetailListFragment_container)\n    FrameLayout mFrameDetailListFragment;\n\n    private static final String TAG = \"RecipeDetailActivity\";\n    DetailListFragment detailListFragment;\n    private static final String RECIPE_ID = \"recipe_id\";\n    private static final String RECIPE_NAME = \"recipe_title\";\n    private static final String KEY_RECIPE = \"recipe\";\n    private static final String KEY_POSITION = \"position\";\n    private static final String KEY_DETAIL_FRAGMENT = \"detail_fragment\";\n    private static final String KEY_STEP_DETAIL_FRAGMENT = \"step_detail_fragment\";\n    private RecipeDetailActivityViewModel viewModel;\n    private Integer recipeId;\n    private StepDetailFragment stepDetailFragment;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_recipe_detail);\n        ButterKnife.bind(this);\n        if(savedInstanceState == null) {\n            ActionBar actionBar = getSupportActionBar();\n            if(actionBar != null){\n                actionBar.setDisplayHomeAsUpEnabled(true);\n            }\n\n            FragmentManager fm = getSupportFragmentManager();\n            detailListFragment = (DetailListFragment)fm.findFragmentById(R.id.frameLayoutDetailListFragment_container);\n\n            if (detailListFragment == null) {\n                detailListFragment = new DetailListFragment();\n                FragmentTransaction ft = fm.beginTransaction();\n                ft.add(R.id.frameLayoutDetailListFragment_container, detailListFragment);\n                ft.commit();\n            }\n            Intent intent = getIntent();\n            if(intent.hasExtra(RECIPE_ID)&&intent.hasExtra(RECIPE_NAME)){\n                recipeId = intent.getIntExtra(RECIPE_ID,0);\n                actionBar.setTitle(intent.getStringExtra(RECIPE_NAME));\n                setupViewModel(recipeId);\n            }\n        }\n    }\n\n\n    private void setupViewModel(Integer reciPeId) {\n        AddRecipeDetailViewModelFactory factory = new AddRecipeDetailViewModelFactory(getApplication(),reciPeId);\n        viewModel = ViewModelProviders.of(this,factory).get(RecipeDetailActivityViewModel.class);\n        viewModel.getRecipe().observe(this, new Observer<Recipe>() {\n            @Override\n            public void onChanged(@Nullable Recipe recipe) {\n                detailListFragment.setRecipe(recipe);\n            }\n        });\n\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (getSupportFragmentManager().getBackStackEntryCount() == 1){\n            getSupportFragmentManager().popBackStackImmediate();\n            setupViewModel(recipeId);\n        }\n        else {\n            finish();\n        }\n    }\n\n    @VisibleForTesting\n    @NonNull\n    public IdlingResource getIdlingResource() {\n        return viewModel.getIdlingResource();\n    }\n\n    @Override\n    public void OnRecipeDetailClicked(int position, Recipe recipe) {\n        Bundle bundle = new Bundle();\n        bundle.putParcelable(KEY_RECIPE,recipe);\n        bundle.putInt(KEY_POSITION,position);\n        if(position == 0){\n            //display the list of ingredients\n            IngredientsFrament ingredientsFrament = new IngredientsFrament();\n            ingredientsFrament.setArguments(bundle);\n            ingredientsFrament.show(getSupportFragmentManager(),\"Ingredients Fragment\");\n        }\n        else{\n            String Tag = StepDetailFragment.class.getSimpleName();\n            stepDetailFragment = (StepDetailFragment) getSupportFragmentManager().findFragmentByTag(Tag);\n            if(stepDetailFragment == null){\n                stepDetailFragment = new StepDetailFragment();\n            }\n            stepDetailFragment.setArguments(bundle);\n            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();\n            transaction.replace( R.id.frameLayoutDetailListFragment_container, stepDetailFragment);\n            transaction.addToBackStack(Tag);\n            transaction.commit();\n        }\n    }\n\n\n    @Override\n    protected void onRestoreInstanceState(Bundle savedInstanceState) {\n        super.onRestoreInstanceState(savedInstanceState);\n        recipeId = savedInstanceState.getInt(RECIPE_ID);\n        detailListFragment = (DetailListFragment) getSupportFragmentManager().getFragment(savedInstanceState,KEY_DETAIL_FRAGMENT);\n        stepDetailFragment = (StepDetailFragment) getSupportFragmentManager().getFragment(savedInstanceState,KEY_STEP_DETAIL_FRAGMENT);\n        setupViewModel(recipeId);\n    }\n\n    @Override\n    protected void onSaveInstanceState(Bundle outState) {\n        outState.putInt(RECIPE_ID, recipeId);\n        getSupportFragmentManager().putFragment(outState,KEY_DETAIL_FRAGMENT,detailListFragment);\n        if(stepDetailFragment != null ){\n            getSupportFragmentManager().putFragment(outState,KEY_STEP_DETAIL_FRAGMENT,stepDetailFragment);\n        }\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                if (getSupportFragmentManager().getBackStackEntryCount() == 1){\n                    getSupportFragmentManager().popBackStackImmediate();\n                    setupViewModel(recipeId);\n                    return true;\n                }\n                else{\n                    return super.onOptionsItemSelected(item);\n                }\n            default:\n                 // Invoke the superclass to handle it.\n                return super.onOptionsItemSelected(item);\n\n        }\n    }\n}\n"},
{"Line": "=>86", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (lastRoundPlayer == i) { flag2 = 1; }else { flag2 = cards.CardControl.checkCards(thisRoundCards, lastRoundCards); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/494/buggy-version/src.cards.PlayPoker.java", "BodyUseAPI": [], "Fixed commit": "490b25d96a5c919e489876c568726b98490fbf6b", "Url": "https://api.github.com/repos/cs3343group6/LandLordGame", "Date": "2018-12-03T14:10:37Z", "Source Code Diff": "@@ -48,7 +48,7 @@ public static void startPlay(List<Player> personList) {\n         List<Card> pokerList = null;//player's cards\n         List<Card> lastRoundCards = new ArrayList<Card>();//last round's cards\n         List<Card> thisRoundCards = null;\n-\n+        int lastRoundPlayer = 0;\n         while (!isEnd) {\n             for (int i = 0; i < personList.size(); i++) {\n                 person = personList.get(i);\n@@ -83,7 +83,13 @@ public static void startPlay(List<Player> personList) {\n                     Collections.sort(thisRoundCards);\n                     System.out.println(\"These are the cards you want to output\\n\");\n                     printPoker(thisRoundCards);\n-                    flag2 = CardControl.checkCards(thisRoundCards, lastRoundCards);\n+                    if (lastRoundPlayer == i) {\n+                        flag2 = 1;\n+                    }\n+                    else {\n+                        flag2 = CardControl.checkCards(thisRoundCards, lastRoundCards);\n+                    }\n+\n                     if (flag2 == 0) {\n                         System.out.println(\"Your card is smaller\\n\");\n                     }\n@@ -94,6 +100,7 @@ public static void startPlay(List<Player> personList) {\n                 if ((flag2 == -1) && (flag1 == -1)) {continue;}\n                 System.out.println(\"You have succeeded output all the cards\\n\");\n                 lastRoundCards = thisRoundCards;\n+                lastRoundPlayer = i;\n                 removeCards(thisRoundCards, pokerList);//remove all the cards in this player\n                 System.out.println(\"Now is the cards which you left\\n\");\n                 printPoker(pokerList);", "Complete After Code": "package cards;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class PlayPoker {\n    public static void main(String[] args) {\n        //first step init the shown table and set up poker's cards\n        Init();\n        List<Card> newPoker = newPoker();\n        //step2 wash all the cards\n        washPoker(newPoker);\n        //step3: send out the cards to three players\n        //set up the three players\n        List<Player> playerList = playerInit();\n        Player p1 = playerList.get(0);\n        Player p2 = playerList.get(1);\n        Player p3 = playerList.get(2);\n        //lastCards\n        List<Card> lastCards = sendPoker(newPoker,p1,p2,p3);\n\n        //Here for convenience, I have just set the player1 as the landlord for future versions the functions will be added\n        p1.setRoletType(Constant.LandLord);\n        System.out.println(\"This round\"+p1.getRoleName()+\"is the landlord\");\n        p2.setRoletType(Constant.NotLandLord);\n        p3.setRoletType(Constant.NotLandLord);\n        //Give all the lastCards to the landlord\n        List<Card> pList = p1.getPokerList();\n        pList.addAll(lastCards);\n        Collections.sort(pList);//reorder the cards\n        p1.setPokerList(pList);//renew the Poker list\n        System.out.println();\n        //start the game\n        startPlay(playerList);\n\n    }\n\n    public static void startPlay(List<Player> personList) {\n        System.out.println(\"********************************\u5f00\u59cb\u6597\u5730\u4e3b***********************\");\n        System.out.println();\n        //As the landlord set mechanism hasn't been coded yet, so there should be considered the first player as the landlor\n        Scanner sc = new Scanner(System.in);\n        //\u662f\u5426\u7ed3\u675f\n        boolean isEnd = false;\n        Player person = null;//player\n        List<Card> pokerList = null;//player's cards\n        List<Card> lastRoundCards = new ArrayList<Card>();//last round's cards\n        List<Card> thisRoundCards = null;\n        int lastRoundPlayer = 0;\n        while (!isEnd) {\n            for (int i = 0; i < personList.size(); i++) {\n                person = personList.get(i);\n                pokerList = person.getPokerList();\n                System.out.println(\"\\n\"+person.getRoleName() + \" starts to give the cards with\" + pokerList.size()+\" cards\");\n                System.out.println(\"\\n Now these are the pokers which he have\\n\");\n                printPoker(pokerList);\n                System.out.println(\"\\n Now please input the cards which you want to give out \\n\");\n                System.out.println(\"\\n If no cards can be given out please input \\'no\\' \\n\");\n\n                String cardInputString;//input the whole line of cards\n                //check the error, reads until all the input is right\n                int flag1 = 0;\n                int flag2 = 0;\n                do {\n                    flag1 = 0;\n                    do {\n                        cardInputString = sc.nextLine();\n                        if (cardInputString.equals(\"no\")) {\n                            flag1 = -1;\n                            flag2 = -1;\n                            break;\n                        }\n                        flag1 = errorHandler(cardInputString, pokerList);\n                        if (flag1==0) {\n                            System.out.println(\"You have just input a poker which you don't have \\n\");\n                        }\n                    } while (flag1 == 0);\n                    if (flag2 != 0) { break;} //it means that means this round skips\n                    //now generate the cards list\n                    thisRoundCards = generateCards(cardInputString, pokerList);\n                    Collections.sort(thisRoundCards);\n                    System.out.println(\"These are the cards you want to output\\n\");\n                    printPoker(thisRoundCards);\n                    if (lastRoundPlayer == i) {\n                        flag2 = 1;\n                    }\n                    else {\n                        flag2 = CardControl.checkCards(thisRoundCards, lastRoundCards);\n                    }\n\n                    if (flag2 == 0) {\n                        System.out.println(\"Your card is smaller\\n\");\n                    }\n                    //judge if thisRoundsCards is larger than last Round's cards\n\n                }while (flag2 == 0);\n                //\u6b63\u5e38\u51fa\u724c\n                if ((flag2 == -1) && (flag1 == -1)) {continue;}\n                System.out.println(\"You have succeeded output all the cards\\n\");\n                lastRoundCards = thisRoundCards;\n                lastRoundPlayer = i;\n                removeCards(thisRoundCards, pokerList);//remove all the cards in this player\n                System.out.println(\"Now is the cards which you left\\n\");\n                printPoker(pokerList);\n                //judge if anyone has no cards at all\n                if (pokerList.size() == 0) {\n                    isEnd = true;\n                    System.out.println(\"Player\" + i+1 + \"win\");\n                }\n            }\n        }\n    }\n    public static void Init() {\n        System.out.println(\"****************************Game starts********************\");\n        System.out.println();\n    }\n\n    public static void removeCards(List <Card> thisRoundCards, List <Card> allCards) {\n        for (int iterCard1 = 0; iterCard1 < thisRoundCards.size(); iterCard1++)\n            for (int iterCard2 = 0; iterCard2 < allCards.size(); iterCard2++)\n                if (thisRoundCards.get(iterCard1).compareWithCard(allCards.get(iterCard2))) {\n                    allCards.remove(iterCard2);\n                    break;\n                }\n    }\n    public static int errorHandler(String s, List <Card> pokerList) {\n        //This function is for to detect which card has been inputted and actually not in the card's list\n        int flag = 0; //flag marks if the String 1 means the pokerList contains the string\n        String [] attr = s.split(\"\\\\s+\");\n        for (String substring : attr) {\n            for (int i = 0; i < pokerList.size(); i++) {\n                if (pokerList.get(i).readCompare(substring)) {\n                    flag = 1;\n                    break;\n                }\n            }\n        }\n        return flag;\n\n    }\n\n    public static List <Card> generateCards(String s, List <Card> pokerList) {\n        //This function is for to generate a list of cards\n        String [] attr = s.split(\"\\\\s+\");\n        List <Card> generateCardsList = new ArrayList<Card>();\n        for (String substring : attr) {\n            for (int i = 0; i < pokerList.size(); i++) {\n                if ((!pokerList.get(i).getUse())&&pokerList.get(i).readCompare(substring)) {\n                    generateCardsList.add(pokerList.get(i));\n                    pokerList.get(i).setUse();\n                    break;\n                }\n            }\n        }\n        return generateCardsList;\n    }\n\n\n    public static void printPoker(List<Card> list) {\n        for (int i=0; i < list.size(); i++) {\n            System.out.print(list.get(i).getColor()+list.get(i).getName()+\" \");\n            //Here as to the color define, it is a little point to improve\n        }\n    }\n\n\n    public static List<Card> sendPoker(List<Card> list, Player p1, Player p2, Player p3){\n        //first man's cards\n        List<Card> pList1 = new ArrayList<Card>();\n        //second man's cards\n        List<Card> pList2 = new ArrayList<Card>();\n        //third man's cards\n        List<Card> pList3 = new ArrayList<Card>();\n        //\u5e95\u724c\n        List<Card> lastCards = new ArrayList<Card>();\n        for (int i = 0; i < list.size(); i++) {\n            if(i<list.size()-3){\n                pList1.add(list.get(i));\n                pList2.add(list.get(++i));\n                pList3.add(list.get(++i));\n            }else {\n                lastCards.add(list.get(i));\n            }\n        }\n        Collections.sort(pList1);\n        Collections.sort(pList2);\n        Collections.sort(pList3);\n        p1.setPokerList(pList1);\n        p2.setPokerList(pList2);\n        p3.setPokerList(pList3);\n        return lastCards;\n    }\n\n\n    public static List<Player> playerInit(){\n        List<Player> list = new ArrayList<Player>();\n        String P1name,P2name,P3name;\n        System.out.println(\"*****************Input the first player's name**********\");\n        System.out.println();\n        Scanner sc = new Scanner(System.in);\n        P1name = sc.nextLine();\n        System.out.println(\"*****************Input the second player's name**********\");\n        System.out.println();\n        P2name = sc.nextLine();\n        System.out.println(\"*****************Input the third player's name**********\");\n        System.out.println();\n        P3name = sc.nextLine();\n        Player p1 = new Player(P1name);\n        list.add(p1);\n        Player p2 = new Player(P2name);\n        list.add(p2);\n        Player p3 = new Player(P3name);\n        list.add(p3);\n        return list;\n    }\n    public static List<Card> newPoker(){\n        List<Card> list = new ArrayList<Card>();\n        Card poker = null;\n        String [] pokerName = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"1\", \"2\"};\n        String [] pokerColor = {\"1\", \"2\", \"3\", \"4\", \"5\"};//1,2,3,4 5 big or small king\n        for (int i = 0; i < pokerColor.length-1; i++) {\n            for (int j = 0; j < pokerName.length; j++) {\n                poker = new Card(pokerName[j],j);\n                poker.setColor(pokerColor[i]);\n                list.add(poker);\n            }\n        }\n        //specially deal with the king and joker\n        Card joker = new Card(\"s\", 14);//s is the small king\n        Card king = new Card(\"b\", 15);//b is the bigger king\n        joker.setColor(\"5\");\n        king.setColor(\"5\");\n        list.add(joker);\n        list.add(king);\n        return list;\n    }\n    public static void washPoker(List<Card> list){\n        Collections.shuffle(list);\n    }\n\n\n}"},
{"Line": "=>100", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((ads.size()) < 1) return;", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/967/buggy-version/resana.src.main.java.io.resana.SplashAdProvider.java", "BodyUseAPI": [], "Fixed commit": "908efcca125ea9d3c58c34523f12584c1b11e4f8", "Url": "https://api.github.com/repos/oddrun/resana-android-sdk", "Date": "2018-12-31T08:48:33Z"},
{"Line": "=>146", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (statement.toUpperCase().equals(\"QUIT\")) { response = \"Returning back to bot selector. Bye!\"; }else { response = \"Sorry, I didn't understand that. Type help to see what I can do\"; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/653/buggy-version/src.TennisGame.java", "BodyUseAPI": [], "Fixed commit": "8351d3a27c4a8bcdc7133cf32544090f81741c3f", "Url": "https://api.github.com/repos/T1lt3d/Minigames-Chatbot", "Date": "2018-11-14T05:05:07Z"},
{"Line": "=>294", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((gc) != null) gc.dispose();", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/102/buggy-version/de.scheidtbachmann.statemachine.parent.de.scheidtbachmann.statemachine.diagrams.src.main.java.de.cau.cs.kieler.klighd.piccolo.freehep.SemanticSVGGraphics2D.java", "BodyUseAPI": [], "Fixed commit": "6a0d135f6bfee2247fc0f809468e386292bb833a", "Url": "https://api.github.com/repos/ScheidtBachmann/statemachine", "Date": "2018-12-17T13:38:03Z", "Source Code Diff": "@@ -291,7 +291,8 @@ public void dispose() {\n         awtSwtFontCache = null;\n \n         // dispose the gc\n-        gc.dispose();\n+        if (gc != null)\n+            gc.dispose();\n         gc = null;\n \n         super.dispose();", "Complete After Code": "// CHECKSTYLEOFF |\n// Copyright 2000-2007 FreeHEP\npackage de.cau.cs.kieler.klighd.piccolo.freehep;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.TexturePaint;\nimport java.awt.font.TextAttribute;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.RenderedImage;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.text.AttributedCharacterIterator.Attribute;\nimport java.text.DateFormat;\nimport java.text.DecimalFormat;\nimport java.text.DecimalFormatSymbols;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Stack;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.graphics.GC;\nimport org.eclipse.swt.graphics.Path;\nimport org.eclipse.swt.graphics.PathData;\nimport org.eclipse.swt.widgets.Display;\nimport org.freehep.graphics2d.font.FontUtilities;\nimport org.freehep.graphicsbase.util.UserProperties;\nimport org.freehep.graphicsbase.util.Value;\nimport org.freehep.graphicsbase.xml.util.XMLWriter;\nimport org.freehep.graphicsio.AbstractVectorGraphicsIO;\nimport org.freehep.graphicsio.FontConstants;\nimport org.freehep.graphicsio.ImageConstants;\nimport org.freehep.graphicsio.ImageGraphics2D;\nimport org.freehep.graphicsio.InfoConstants;\nimport org.freehep.graphicsio.PageConstants;\nimport org.freehep.graphicsio.svg.SVGFontTable;\nimport org.freehep.util.io.Base64OutputStream;\nimport org.freehep.util.io.WriterOutputStream;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Maps;\n\nimport de.cau.cs.kieler.klighd.KlighdConstants;\nimport de.cau.cs.kieler.klighd.Klighd;\nimport de.cau.cs.kieler.klighd.piccolo.export.KlighdAbstractSVGGraphics.KlighdGradientPaint;\nimport de.cau.cs.kieler.klighd.util.KlighdSemanticDiagramData;\n\n/**\n * This class implements the Scalable Vector Graphics output. SVG specifications\n * can be found at http://www.w3c.org/Graphics/SVG/\n *\n * The current implementation is based on REC-SVG11-20030114\n *\n * @author Mark Donszelmann\n * @version $Id: freehep-graphicsio-svg/src/main/java/org/freehep/graphicsio/svg/SVGGraphics2D.java 4c4708a97391 2007/06/12 22:32:31 duns $\n * \n * - Added capabilities to add semantic information to the svg, ie key/value pairs within the 'klighd' namespace.\n * - Allow comments to be switched off.\n * - Corrected direction of color gradients.\n * - Added support for multi-line text and proper font sizing. \n * \n * @author uru\n */\npublic class SemanticSVGGraphics2D extends AbstractVectorGraphicsIO {\n\n    public static final String VERSION_1_1 = \"Version 1.1 (REC-SVG11-20030114)\";\n\n    private static final String rootKey = SemanticSVGGraphics2D.class.getName();\n\n    public static final String TRANSPARENT = rootKey + \".\"\n            + PageConstants.TRANSPARENT;\n\n    public static final String BACKGROUND = rootKey + \".\"\n            + PageConstants.BACKGROUND;\n\n    public static final String BACKGROUND_COLOR = rootKey + \".\"\n            + PageConstants.BACKGROUND_COLOR;\n\n    public static final String VERSION = rootKey + \".Version\";\n\n    public static final String COMPRESS = rootKey + \".Binary\";\n\n    /**\n     * use style=\"font-size:20\" instaed of font-size=\"20\"\n     * see {@link #style(java.util.Properties)} for details\n     */\n    public static final String STYLABLE = rootKey + \".Stylable\";\n\n    public static final String IMAGE_SIZE = rootKey + \".\"\n            + ImageConstants.IMAGE_SIZE;\n\n    public static final String EXPORT_IMAGES = rootKey + \".ExportImages\";\n\n    public static final String EXPORT_SUFFIX = rootKey + \".ExportSuffix\";\n\n    public static final String WRITE_IMAGES_AS = rootKey + \".\"\n            + ImageConstants.WRITE_IMAGES_AS;\n\n    public static final String FOR = rootKey + \".\" + InfoConstants.FOR;\n\n    public static final String TITLE = rootKey + \".\" + InfoConstants.TITLE;\n\n    private BasicStroke defaultStroke = new BasicStroke();\n\n    public static final String EMBED_FONTS = rootKey + \".\"\n            + FontConstants.EMBED_FONTS;\n    \n    public static final String DESCRIPTION = rootKey + \".Description\";\n    \n    public static final String ADDITIONAL_ROOT_DATA = rootKey + \".AdditionalData\";\n    \n    public static final String CSS = rootKey + \".css\";\n    \n    private SVGFontTable fontTable;\n\n    private static final UserProperties defaultProperties = new UserProperties();\n    static {\n        defaultProperties.setProperty(TRANSPARENT, true);\n        defaultProperties.setProperty(BACKGROUND, false);\n        defaultProperties.setProperty(BACKGROUND_COLOR, Color.GRAY);\n\n        defaultProperties.setProperty(VERSION, VERSION_1_1);\n        defaultProperties.setProperty(COMPRESS, false);\n\n        defaultProperties.setProperty(STYLABLE, false);\n\n        defaultProperties.setProperty(IMAGE_SIZE, new Dimension(0, 0)); // ImageSize\n\n        defaultProperties.setProperty(EXPORT_IMAGES, false);\n        defaultProperties.setProperty(EXPORT_SUFFIX, \"image\");\n\n        defaultProperties.setProperty(WRITE_IMAGES_AS, ImageConstants.SMALLEST);\n\n        defaultProperties.setProperty(FOR, \"\");\n        defaultProperties.setProperty(TITLE, \"\");\n\n        defaultProperties.setProperty(CLIP, true);\n\n        defaultProperties.setProperty(EMBED_FONTS, false);\n        defaultProperties.setProperty(TEXT_AS_SHAPES, true);\n        defaultProperties.setProperty(DESCRIPTION, \"\");\n        \n        defaultProperties.setProperty(ADDITIONAL_ROOT_DATA, \"\");\n        defaultProperties.setProperty(CSS, \"\");\n    }\n\n    public static Properties getDefaultProperties() {\n        return defaultProperties;\n    }\n\n    public static void setDefaultProperties(Properties newProperties) {\n        defaultProperties.setProperties(newProperties);\n    }\n\n    public static final String version = \"$Revision$\";\n\n    // current filename including path\n    private String filename;\n\n    // The lowerleft and upper right points of the bounding box.\n    private int bbx, bby, bbw, bbh;\n\n    // The private writer used for this file.\n    private OutputStream ros;\n\n    private PrintWriter os;\n\n    // table for gradients\n    Hashtable<GradientPaint, String> gradients = new Hashtable<GradientPaint, String>();\n\n    // table for textures\n    Hashtable<?, ?> textures = new Hashtable<Object, Object>();\n\n    private Stack<String> closeTags = new Stack<String>();\n\n    private int imageNumber = 0;\n\n    private Value clipNumber;\n\n    private int width, height;\n    \n    private KlighdSemanticDiagramData semanticData = null;\n    \n    private boolean writeComments = false;\n    \n    /** The display used to render diagrams, if available, otherwhise {@code null}. */\n    private Display display;\n    /** If a display exists, this {@link GC} is used to perform font size calculations. */  \n    private GC gc;\n    /** A mapping of awt fonts to swt fonts. The latter are used for font size calculations. */\n    private Map<Font, org.eclipse.swt.graphics.Font> awtSwtFontCache = Maps.newHashMap();\n\n    /*\n     * ================================================================================ |\n     * 1. Constructors & Factory Methods\n     * ================================================================================\n     */\n    public SemanticSVGGraphics2D(File file, Dimension size) throws IOException {\n        this(new FileOutputStream(file), size);\n        this.filename = file.getPath();\n    }\n\n    public SemanticSVGGraphics2D(File file, Component component) throws IOException {\n        this(new FileOutputStream(file), component);\n        this.filename = file.getPath();\n    }\n\n    public SemanticSVGGraphics2D(OutputStream os, Dimension size) {\n        super(size, false);\n        init(os);\n        width = size.width;\n        height = size.height;\n    }\n\n    public SemanticSVGGraphics2D(OutputStream os, Component component) {\n        super(component, false);\n        init(os);\n        width = getSize().width;\n        height = getSize().height;\n    }\n\n    private void init(OutputStream os) {\n        this.ros = os;\n        initProperties(getDefaultProperties());\n\n        this.filename = null;\n\n        this.clipNumber = new Value().set(0);\n        \n        // Dont use #getDefault() as we do not want to \n        //  create a display if none exists so far.\n        display = Display.getCurrent();\n        if (display != null && gc == null) {\n            // remember to dispose the gc later\n            gc = new GC(display);\n        }\n    }\n\n    protected SemanticSVGGraphics2D(SemanticSVGGraphics2D graphics, boolean doRestoreOnDispose) {\n        super(graphics, doRestoreOnDispose);\n        // Now initialize the new object.\n        filename = graphics.filename;\n        os = graphics.os;\n        bbx = graphics.bbx;\n        bby = graphics.bby;\n        bbw = graphics.bbw;\n        bbh = graphics.bbh;\n        gradients = graphics.gradients;\n        textures = graphics.textures;\n        clipNumber = graphics.clipNumber;\n        fontTable = graphics.fontTable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void dispose() {\n        // dispose cached swt fonts\n        for (org.eclipse.swt.graphics.Font f : awtSwtFontCache.values()) {\n            f.dispose();\n        }\n        awtSwtFontCache.clear();\n        awtSwtFontCache = null;\n\n        // dispose the gc\n        if (gc != null)\n            gc.dispose();\n        gc = null;\n\n        super.dispose();\n    }\n\n    /*\n     * ================================================================================ |\n     * 2. Document Settings\n     * ================================================================================\n     */\n\n    /**\n     * Get the bounding box for this image.\n     */\n    public void setBoundingBox() {\n        bbx = 0;\n        bby = 0;\n\n        Dimension size = getSize();\n        bbw = size.width;\n        bbh = size.height;\n    }\n\n    /**\n     * @param writeComments the writeComments to set\n     */\n    public void setWriteComments(boolean writeComments) {\n        this.writeComments = writeComments;\n    }\n    \n    /*\n     * ================================================================================ |\n     * 3. Header, Trailer, Multipage & Comments\n     * ================================================================================\n     */\n\n    /*--------------------------------------------------------------------------------\n     | 3.1 Header & Trailer\n     *--------------------------------------------------------------------------------*/\n    /**\n     * Write out the header of this SVG file.\n     */\n    public void writeHeader() throws IOException {\n        ros = new BufferedOutputStream(ros);\n        if (isProperty(COMPRESS)) {\n            ros = new GZIPOutputStream(ros);\n        }\n\n        os = new PrintWriter(ros, true);\n        fontTable = new SVGFontTable();\n\n        // Do the bounding box calculation.\n        setBoundingBox();\n        imageNumber = 0;\n\n        os.println(\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?>\");\n        \n        // Insert css document if path is set\n        if (!getProperty(CSS).equals(\"\")) {\n            os.println(\"<?xml-stylesheet href=\\\"\"+ getProperty(CSS) +\"\\\" type=\\\"text/css\\\"?>\");\n        }\n        \n        if (getProperty(VERSION).equals(VERSION_1_1)) {\n            // no DTD anymore\n        } else {\n            // FIXME experimental version\n        }\n        os.println();\n\n        int x = 0;\n        int y = 0;\n        Dimension size = getPropertyDimension(IMAGE_SIZE);\n        int w = size.width;\n        if (w <= 0)\n            w = width;\n        int h = size.height;\n        if (h <= 0)\n            h = height;\n\n        os.println(\"<svg \");\n        if (getProperty(VERSION).equals(VERSION_1_1)) {\n            os.println(\"     version=\\\"1.1\\\"\");\n            os.println(\"     baseProfile=\\\"full\\\"\");\n            os.println(\"     xmlns=\\\"http://www.w3.org/2000/svg\\\"\");\n            os.println(\"     xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\");\n            os.println(\"     xmlns:ev=\\\"http://www.w3.org/2001/xml-events\\\"\");\n            os.println(\"     xmlns:klighd=\\\"http://de.cau.cs.kieler/klighd\\\"\");\n            // KIPRA-1637: preserve multiple spaces when displaying an svg\n            //  this affects all <text> elements of the document\n            os.println(\"     xml:space=\\\"preserve\\\"\");\n        }\n        os.println(\"     x=\\\"\" + x + \"px\\\"\");\n        os.println(\"     y=\\\"\" + y + \"px\\\"\");\n        os.println(\"     width=\\\"\" + w + \"px\\\"\");\n        os.println(\"     height=\\\"\" + h + \"px\\\"\");\n        os.println(\"     viewBox=\\\"\" + bbx + \" \" + bby + \" \" + bbw + \" \" + bbh\n                + \"\\\"\");\n        \n        // KIPRA-1849 Allow adding additional data to the root element\n        if (!getProperty(ADDITIONAL_ROOT_DATA).equals(\"\")) {\n            os.println(\"     \" + getProperty(ADDITIONAL_ROOT_DATA));\n        }\n        \n        os.println(\"     >\");\n        closeTags.push(\"</svg>\");\n        if (writeComments) {\n            pushComment(closeTags, \" <!-- bounding box -->\");\n        }\n\n        os.print(\"<title>\");\n        os.print(XMLWriter.normalizeText(getProperty(TITLE)));\n        os.println(\"</title>\");\n\n        String producer = getClass().getName();\n        if (!isDeviceIndependent()) {\n            producer += \" \" + version.substring(1, version.length() - 1);\n        }\n\n        os.print(\"<desc>\");\n        if (Strings.isNullOrEmpty(getProperty(DESCRIPTION))) {\n            os.print(\"Creator: \" + XMLWriter.normalizeText(getCreator()));\n            os.print(\" Producer: \" + XMLWriter.normalizeText(producer));\n            os.print(\" Source: \" + XMLWriter.normalizeText(getProperty(FOR)));\n            if (!isDeviceIndependent()) {\n                os.print(\" Date: \"\n                        + DateFormat.getDateTimeInstance(DateFormat.FULL,\n                                DateFormat.FULL, Locale.US).format(new Date()));\n            }\n        } else {\n            os.print(getProperty(DESCRIPTION));\n        }\n        os.println(\"</desc>\");\n\n        // write default stroke\n        os.print(\"<g \");\n        Properties style = getStrokeProperties(defaultStroke,  true);\n        os.print(style(style));\n        os.println(\">\");\n\n        // close default settings at the end\n        closeTags.push(\"</g>\");\n        pushComment(closeTags, \"<!-- default stroke -->\");\n    }\n\n    public void writeBackground() throws IOException {\n        if (isProperty(TRANSPARENT)) {\n            setBackground(null);\n        } else if (isProperty(BACKGROUND)) {\n            setBackground(getPropertyColor(BACKGROUND_COLOR));\n            clearRect(0.0, 0.0, getSize().width, getSize().height);\n        } else {\n            setBackground(getComponent() != null ? getComponent()\n                    .getBackground() : Color.WHITE);\n            clearRect(0.0, 0.0, getSize().width, getSize().height);\n        }\n    }\n\n    /**\n     * Writes the font definitions and calls {@link #writeGraphicsRestore()} to\n     * close all open XML Tags\n     *\n     * @throws IOException\n     */\n    public void writeTrailer() throws IOException {\n        // write font definition\n        if (isProperty(EMBED_FONTS)) {\n            os.println(\"<defs>\");\n            os.println(fontTable.toString());\n            os.println(\"</defs>\");\n            writeComment(\"<!-- font definitions -->\");\n        }\n\n        // restor graphic\n        writeGraphicsRestore();\n    }\n\n    public void closeStream() throws IOException {\n        os.close();\n    }\n\n    /*\n     * ================================================================================ |\n     * 4. Create\n     * ================================================================================\n     */\n\n    public Graphics create() {\n        try {\n            writeGraphicsSave();\n        } catch (IOException e) {\n            handleException(e);\n        }\n        return new SemanticSVGGraphics2D(this, true);\n    }\n\n    public Graphics create(double x, double y, double width, double height) {\n        try {\n            writeGraphicsSave();\n        } catch (IOException e) {\n            handleException(e);\n        }\n        SemanticSVGGraphics2D graphics = new SemanticSVGGraphics2D(this, true);\n        // FIXME: All other drivers have a translate(x,y), clip(0,0,w,h) here\n        os.println(\"<svg x=\\\"\" + fixedPrecision(x) + \"\\\" \" + \"y=\\\"\"\n                + fixedPrecision(y) + \"\\\" \" + \"width=\\\"\"\n                + fixedPrecision(width) + \"\\\" \" + \"height=\\\"\"\n                + fixedPrecision(height) + \"\\\" \" + \">\");\n        graphics.closeTags.push(\"</svg>\");\n        pushComment(graphics.closeTags, \" <!-- graphics context -->\");\n        \n        // write default stroke\n        os.print(\"<g \");\n        Properties style = getStrokeProperties(defaultStroke,  true);\n        os.print(style(style));\n        os.println(\">\");\n\n        graphics.closeTags.push(\"</g>\");\n        pushComment(graphics.closeTags, \" <!-- default stroke -->\");\n\n        return graphics;\n    }\n\n    protected void writeGraphicsSave() throws IOException {\n        // not applicable\n    }\n\n    protected void writeGraphicsRestore() throws IOException {\n        while (!closeTags.empty()) {\n            os.println(closeTags.pop());\n        }\n    }\n\n    /*\n     * ================================================================================ |\n     * 5. Drawing Methods\n     * ================================================================================\n     */\n    /* 5.1 shapes */\n    /* 5.1.4. shapes */\n\n    /**\n     * Draws the shape using the current paint as border\n     *\n     * @param shape Shape to draw\n     */\n    public void draw(Shape shape) {\n        // others than BasicStrokes are written by its\n        // {@link Stroke#createStrokedShape()}\n        if (getStroke() instanceof BasicStroke) {\n            PathIterator path = shape.getPathIterator(null);\n\n            Properties style = new Properties();\n            if (getPaint() != null) {\n                style.put(\"stroke\", hexColor(getPaint()));\n                style.put(\"stroke-opacity\", fixedPrecision(alphaColor(getPaint())));\n            }\n\n            // no filling\n            style.put(\"fill\", \"none\");\n            style.putAll(getStrokeProperties(getStroke(), false));\n\n            writePathIterator(path, style);\n        } else if (getStroke() != null) {\n            // fill the shape created by stroke\n            fill(getStroke().createStrokedShape(shape));\n        } else {\n            // FIXME: do nothing or draw using defaultStroke?\n            fill(defaultStroke.createStrokedShape(shape));\n        }\n    }\n\n    /**\n     * Fills the shape without a border using the current paint\n     *\n     * @param shape Shape to be filled with the current paint\n     */\n    public void fill(Shape shape) {\n        // draw paint as image if needed\n        if (!(getPaint() instanceof Color || getPaint() instanceof GradientPaint)) {\n            // draw paint as image\n            fill(shape, getPaint());\n        } else {\n            PathIterator path = shape.getPathIterator(null);\n\n            Properties style = new Properties();\n\n            if (path.getWindingRule() == PathIterator.WIND_EVEN_ODD) {\n                style.put(\"fill-rule\", \"evenodd\");\n            } else {\n                style.put(\"fill-rule\", \"nonzero\");\n            }\n\n            // fill with paint\n            if (getPaint() != null) {\n                style.put(\"fill\", hexColor(getPaint()));\n                style.put(\"fill-opacity\", fixedPrecision(alphaColor(getPaint())));\n            }\n\n            // no border\n            style.put(\"stroke\", \"none\");\n\n            writePathIterator(path, style);\n        }\n    }\n\n    /**\n     * writes a path using {@link #getPath(java.awt.geom.PathIterator)}\n     * and the given style\n     *\n     * @param pi PathIterator\n     * @param style Properties for <g> tag\n     */\n    private void writePathIterator(PathIterator pi, Properties style) {\n        StringBuffer result = new StringBuffer();\n\n        // write style\n        result.append(\"<g \");\n        result.append(style(style));\n        result.append(\">\\n  \");\n\n        // draw shape\n        result.append(getPath(pi));\n\n        // close style\n        result.append(\"\\n</g>\");\n        if (writeComments) {\n           result.append(\" <!-- drawing style -->\"); \n        }\n\n        boolean drawClipped = false;\n\n        // test if clip intersects pi\n        if (getClip() != null) {\n            GeneralPath gp = new GeneralPath();\n            gp.append(pi, true);\n            // create the stroked shape\n            Stroke stroke = getStroke() == null? defaultStroke : getStroke();\n            Rectangle2D bounds = stroke.createStrokedShape(gp).getBounds();\n            // clip should intersect the path\n            // if clip contains the bounds completely, clipping is not needed\n            drawClipped = getClip().intersects(bounds) && !getClip().contains(bounds);\n        }\n\n        if (drawClipped) {\n            // write in a transformed and clipped context\n            os.println(\n                getTransformedString(\n                    getTransform(),\n                    getClippedString(result.toString())));\n        } else {\n            // write in a transformed context\n            os.println(\n                getTransformedString(\n                    getTransform(),\n                    result.toString()));\n        }\n    }\n\n    /* 5.2. Images */\n    public void copyArea(int x, int y, int width, int height, int dx, int dy) {\n        writeWarning(getClass()\n                + \": copyArea(int, int, int, int, int, int) not implemented.\");\n    }\n\n    protected void writeImage(RenderedImage image, AffineTransform xform,\n            Color bkg) throws IOException {\n\n        StringBuffer result = new StringBuffer();\n\n        result.append(\"<image x=\\\"0\\\" y=\\\"0\\\" \" + \"width=\\\"\");\n        result.append(image.getWidth());\n        result.append(\"\\\" \" + \"height=\\\"\");\n        result.append(image.getHeight());\n        result.append(\"\\\" \" + attributes(true));\n        result.append(\" xlink:href=\\\"\");\n\n        String writeAs = getProperty(WRITE_IMAGES_AS);\n        boolean isTransparent = image.getColorModel().hasAlpha()\n                && (bkg == null);\n\n        String encode;\n        byte[] imageBytes;\n\n        // write as PNG\n        if (ImageConstants.PNG.equalsIgnoreCase(writeAs) || isTransparent) {\n            encode = ImageConstants.PNG;\n            imageBytes = ImageGraphics2D.toByteArray(\n                image, ImageConstants.PNG, null, null);\n        }\n\n        // write as JPG\n        else if (ImageConstants.JPG.equalsIgnoreCase(writeAs)) {\n            encode = ImageConstants.JPG;\n            imageBytes = ImageGraphics2D.toByteArray(\n                image, ImageConstants.JPG, null, null);\n        }\n\n        // write as SMALLEST\n        else {\n            byte[] pngBytes = ImageGraphics2D.toByteArray(image, ImageConstants.PNG, null, null);\n            byte[] jpgBytes = ImageGraphics2D.toByteArray(image, ImageConstants.JPG, null, null);\n\n            // define encode and imageBytes\n            if (jpgBytes.length < 0.5 * pngBytes.length) {\n                encode = ImageConstants.JPG;\n                imageBytes = jpgBytes;\n            } else {\n                encode = ImageConstants.PNG;\n                imageBytes = pngBytes;\n            }\n        }\n\n        if (isProperty(EXPORT_IMAGES)) {\n            imageNumber++;\n\n            // create filenames\n            if (filename == null) {\n                writeWarning(\"SVG: cannot write embedded images, since SVGGraphics2D\");\n                writeWarning(\"     was created from an OutputStream rather than a File.\");\n                return;\n            }\n            int pos = filename.lastIndexOf(File.separatorChar);\n            String dirName = (pos < 0) ? \"\" : filename.substring(0, pos + 1);\n            String imageName = (pos < 0) ? filename : filename\n                    .substring(pos + 1);\n            imageName += \".\" + getProperty(EXPORT_SUFFIX) + \"-\" + imageNumber\n                    + \".\" + encode;\n\n            result.append(imageName);\n\n            // write the image separately\n            FileOutputStream imageStream = new FileOutputStream(dirName\n                    + imageName);\n\n            imageStream.write(imageBytes);\n            imageStream.close();\n        } else {\n            result.append(\"data:image/\");\n            result.append(encode);\n            result.append(\";base64,\");\n\n            StringWriter writer = new StringWriter();\n            @SuppressWarnings(\"resource\") // closing a StringWriter has no effect\n            Base64OutputStream b64 = new Base64OutputStream(\n                    new WriterOutputStream(writer));\n            b64.write(imageBytes);\n            b64.finish();\n\n            result.append(writer.toString());\n        }\n\n        result.append(\"\\\"/>\");\n\n        os.println(getTransformedString(getTransform(),\n            getClippedString(getTransformedString(xform, result\n                .toString()))));\n    }\n\n    /**\n     * Copied from {@link AbstractVectorGraphicsIO} to change the handling of text as shapes.\n     * \n     * Draws the string at (x, y). If TEXT_AS_SHAPES is set\n     * {@link #drawGlyphVector(java.awt.font.GlyphVector, float, float)} is used, otherwise\n     * {@link #writeString(String, double, double)} for a more direct output of the string.\n     *\n     * @param string\n     * @param x\n     * @param y\n     */\n    public void drawString(String string, double x, double y) {\n        // something to draw?\n        if (string == null || string.equals(\"\")) {\n            return;\n        }\n\n        // Draw strings as shapes?\n        // We reuse SWT's font size estimation here, as\n        //  KLighD uses it to determine the sizes of nodes etc.\n        if (isProperty(TEXT_AS_SHAPES)) {\n            Path path = new Path(display);\n            path.addString(string, (float) x, (float) y, getSWTFont());\n            path.close();\n\n            // convert to awt path\n            Path2D p2d = createAWTPath(path.getPathData());\n            path.dispose();\n\n            fill(p2d);\n\n        } else {\n            // write string directly\n            try {\n                writeString(string, x, y);\n            } catch (IOException e) {\n                handleException(e);\n            }\n        }\n    }\n\n    /* 5.3. Strings */\n    protected void writeString(String str, double x, double y)\n            throws IOException {\n        // str = FontEncoder.getEncodedString(str, getFont().getName());\n\n        if (isProperty(EMBED_FONTS)) {\n            // FIXME not supported yet, the #addGlyphs method is protected\n            // fontTable.addGlyphs(str, getFont());\n            throw new UnsupportedOperationException(\"Embedding fonts is not supported.\");\n        }\n\n        // font transformation should _not_ transform string position\n        // so we draw at 0:0 and translate _before_ using getFont().getTransform()\n        // we could not just translate before and reverse translation after\n        // writing because the clipping area\n\n        // create font properties\n        Properties style = getFontProperties(getFont());\n\n        // add stroke properties\n        if (getPaint() != null) {\n            style.put(\"fill\", hexColor(getPaint()));\n            style.put(\"fill-opacity\", fixedPrecision(alphaColor(getPaint())));\n        } else {\n            style.put(\"fill\", \"none\");\n        }\n        style.put(\"stroke\", \"none\");\n\n        // convert tags to string values\n        str = XMLWriter.normalizeText(str);\n\n        // replace leading space by &#00a0; otherwise firefox 1.5 fails\n        if (str.startsWith(\" \")) {\n            str = \"&#x00a0;\" + str.substring(1);\n        }\n\n        os.println(getTransformedString(\n            // general transformation\n            getTransform(),\n            // general clip\n            getClippedString(\n                getTransformedString(\n                    // text offset\n                    new AffineTransform(1, 0, 0, 1, x, y),\n                    getTransformedString(\n                        // font transformation and text\n                        getFont().getTransform(),\n                        \"<text \"\n                            // style\n                            + addFontHeightUnit(style(style))\n                            // semantic data\n                            + attributes(false)\n                            // Coordinates\n                            + \" x=\\\"0\\\" y=\\\"0\\\">\"\n                            // text\n                            + insertTSpan(str)\n                            + \"</text>\")))));\n\n        resetSemanticData();\n    }\n\n    \n    /**\n     * Parse the attributes string and add a unit to the font-size attribute.\n     * \n     * A font's size is specified in 'pt' which is a relative size where a height of 72pt\n     * corresponds to 1 inch. When a font is rendered on a screen however, these pts are converted\n     * to pixels and sizes of nodes and boxes are determined correspondingly. We thus use a px size\n     * if we are able to determine the device with wich the font was rendered (i.e. the device).\n     * \n     * @param attributes\n     *            the text attributes\n     * @return the text attributes with added font-size unit.\n     */\n    private String addFontHeightUnit(final String attributes) {\n        String fontWithUnit;\n        if (display != null) {\n            fontWithUnit =\n                    attributes.replaceFirst(\"font-size=\\\"(\\\\d*(\\\\.\\\\d*)?)\\\"\", \"font-size=\\\"$1px\\\"\");\n        } else {\n            fontWithUnit =\n                    attributes.replaceFirst(\"font-size=\\\"(\\\\d*(\\\\.\\\\d*)?)\\\"\", \"font-size=\\\"$1pt\\\"\");\n        }\n        return fontWithUnit;\n    }\n    \n    /**\n     * Insert TSpan elements into a multiline text string.\n     * @param text string where lines are indicated by \"\\n\"\n     * @return the string enriched by TSpan elements.\n     */\n    private String insertTSpan(final String text) {\n        \n        // empty string\n        if (Strings.isNullOrEmpty(text)) {\n            return \"\";\n        }\n\n        int i = 0;\n        final String[] lines = text.split(\"\\\\r?\\\\n|\\\\r\");\n        final StringBuffer content = new StringBuffer();\n        if (display != null) {\n            // Translate font size in 'pt' to display 'px'\n            //  see #addFontHeightUnit javadoc for more information\n            // As opposed to the font metrics used below, the determined\n            //  size is a non-rounded decimal number \n            float size = this.getFont().getSize2D() * ((float) display.getDPI().x) / 72;\n            \n            // Translate the font back to an swt font\n            //  KLighD used SWT to determine font sizes and as SWT and AWT font metrics\n            //  differ we have to use swt here\n            // Note that the font style constants in SWT and AWT are identical\n\n            gc.setFont(getSWTFont());\n            org.eclipse.swt.graphics.FontMetrics fm = gc.getFontMetrics();\n            \n            // FIXME \n            // The following values are determined experimentally\n            //  as each of the browser/awt/swt seem to determine \n            //  slightly different values ...\n            // fm.getLeading / 2 seems to be a good value at least under windows\n            \n            // to the 1st baseline \n            double firstLineHeight = fm.getLeading() / 2d + fm.getAscent();\n            // actually we want to use fm.getHeight, however this seems to be too much\n            double lineHeight = size + fm.getLeading() / 2d; \n            // use tspans to emulate multiline text\n            boolean first = true;\n            for (final String line : lines) {\n                content.append(\"<tspan x=\\\"0\\\" dy=\\\"\");\n                content.append(first ? firstLineHeight : lineHeight);\n                content.append(\"\\\"\");\n                content.append(tSpanAttributes(line, i++));\n                content.append(\">\");\n                content.append(line);\n                content.append(\"</tspan>\" + Klighd.LINE_SEPARATOR);\n                first = false;\n            }\n            \n        } else {\n            // without a display just use the pt size as line height for multiline text\n\n            // use tspans to emulate multiline text\n            for (final String line : lines) {\n                content.append(\"<tspan x=\\\"0\\\" dy=\\\"\");\n                content.append(getFont().getSize());\n                content.append(\"\\\"\");\n                content.append(tSpanAttributes(line, i++));\n                content.append(\">\");\n                content.append(line);\n                content.append(\"</tspan>\" + Klighd.LINE_SEPARATOR);\n            }\n        }\n\n        return content.toString();\n    }\n    \n\n    /**\n     * KLighD uses SWT to estimate font sizes, hence we do \n     * the same when exporting svgs.\n     */\n    @Override\n    public FontMetrics getFontMetrics() {\n        // use swt functionality if a display is available\n        if (display != null) {\n            gc.setFont(getSWTFont());\n            return new PseudoAWTFontMetrics(getFont(), gc.getFontMetrics());\n        } else {\n            // fallback to the awt metrics\n            return super.getFontMetrics();\n        }\n    }\n\n    /**\n     * Gets the height of the current font.\n     * @return The current font height.\n     */\n    public float getFontHeight() {\n        Font font = this.getFont();\n        Map<?, ?> attributes = FontUtilities.getAttributes(font);\n        return (Float) attributes.get(TextAttribute.SIZE);\n    }\n    \n    /**\n     * Creates the properties list for the given font.\n     * Family, size, bold italic, underline and strikethrough are converted.\n     * {@link java.awt.font.TextAttribute#SUPERSCRIPT}\n     * is handled by {@link java.awt.Font#getTransform()}\n     *\n     * @return properties in svg style  for the font\n     * @param font Font to\n     */\n    private Properties getFontProperties(Font font) {\n        Properties result = new Properties();\n\n        // attribute for font properties\n        Map /*<TextAttribute, ?>*/<Attribute, Object> attributes = FontUtilities.getAttributes(font);\n\n        // dialog.bold -> Helvetica with TextAttribute.WEIGHT_BOLD\n        SVGFontTable.normalize(attributes);\n\n        // family\n        result.put(\"font-family\", attributes.get(TextAttribute.FAMILY));\n\n        // weight\n        if (TextAttribute.WEIGHT_BOLD.equals(attributes.get(TextAttribute.WEIGHT))) {\n            result.put(\"font-weight\", \"bold\");\n        } else {\n            result.put(\"font-weight\", \"normal\");\n        }\n\n        // posture\n        if (TextAttribute.POSTURE_OBLIQUE.equals(attributes.get(TextAttribute.POSTURE))) {\n            result.put(\"font-style\", \"italic\");\n        } else {\n            result.put(\"font-style\", \"normal\");\n        }\n\n        Object ul = attributes.get(TextAttribute.UNDERLINE);\n        if (ul != null) {\n            // underline style, only supported by CSS 3\n            if (TextAttribute.UNDERLINE_LOW_DOTTED.equals(ul)) {\n                result.put(\"text-underline-style\", \"dotted\");\n            } else if (TextAttribute.UNDERLINE_LOW_DASHED.equals(ul)) {\n                result.put(\"text-underline-style\", \"dashed\");\n            } else if (TextAttribute.UNDERLINE_ON.equals(ul)) {\n                result.put(\"text-underline-style\", \"solid\");\n            }\n\n            // the underline itself, supported by CSS 2\n            result.put(\"text-decoration\", \"underline\");\n        }\n\n        if (attributes.get(TextAttribute.STRIKETHROUGH) != null) {\n            // is the property allready witten?\n            if  (ul == null) {\n                result.put(\"text-decoration\", \"underline, line-through\");\n            } else {\n                result.put(\"text-decoration\", \"line-through\");\n            }\n        }\n\n        Float size = (Float) attributes.get(TextAttribute.SIZE);\n        if (display != null) {\n            result.put(\"font-size\", fixedPrecision(size.floatValue() * display.getDPI().x / 72));\n        } else {\n            result.put(\"font-size\", fixedPrecision(size.floatValue()));\n        }\n\n        return result;\n    }\n\n    /*\n     * ================================================================================ |\n     * 6. Transformations\n     * ================================================================================\n     */\n    protected void writeTransform(AffineTransform transform) throws IOException {\n        // written when needed\n    }\n\n    protected void writeSetTransform(AffineTransform transform)\n            throws IOException {\n        // written when needed\n    }\n\n    /*\n     * ================================================================================ |\n     * 7. Clipping\n     * ================================================================================\n     */\n    protected void writeClip(Shape s) throws IOException {\n        // written when needed\n    }\n\n    protected void writeSetClip(Shape s) throws IOException {\n        // written when needed\n    }\n\n    /*\n     * ================================================================================ |\n     * 8. Graphics State\n     * ================================================================================\n     */\n    /* 8.1. stroke/linewidth */\n    protected void writeWidth(float width) throws IOException {\n        // written when needed\n    }\n\n    protected void writeCap(int cap) throws IOException {\n        // Written when needed\n    }\n\n    protected void writeJoin(int join) throws IOException {\n        // written when needed\n    }\n\n    protected void writeMiterLimit(float limit) throws IOException {\n        // written when needed\n    }\n\n    protected void writeDash(float[] dash, float phase) throws IOException {\n        // written when needed\n    }\n\n    /**\n     * return the style tag for the stroke\n     *\n     * @param s\n     *            Stroke to convert\n     * @param all\n     *            all attributes (not only the differences to defaultStroke) are\n     *            handled\n     * @return corresponding style string\n     */\n    private Properties getStrokeProperties(Stroke s, boolean all) {\n        Properties result = new Properties();\n\n        // only BasisStrokes are written\n        if (!(s instanceof BasicStroke)) {\n            return result;\n        }\n\n        BasicStroke stroke = (BasicStroke) s;\n\n        // append linecap\n        if (all || (stroke.getEndCap() != defaultStroke.getEndCap())) {\n            // append cap\n            switch (stroke.getEndCap()) {\n                default:\n                case BasicStroke.CAP_BUTT:\n                    result.put(\"stroke-linecap\", \"butt\");\n                    break;\n                case BasicStroke.CAP_ROUND:\n                    result.put(\"stroke-linecap\", \"round\");\n                    break;\n                case BasicStroke.CAP_SQUARE:\n                    result.put(\"stroke-linecap\", \"square\");\n                    break;\n            }\n        }\n\n        // append dasharray\n        if (all\n                || !Arrays.equals(stroke.getDashArray(), defaultStroke\n                        .getDashArray())) {\n            if (stroke.getDashArray() != null\n                    && stroke.getDashArray().length > 0) {\n                StringBuffer array = new StringBuffer();\n                for (int i = 0; i < stroke.getDashArray().length; i++) {\n                    if (i > 0) {\n                        array.append(\",\");\n                    }\n                    // SVG does not allow dash entry to be zero (Firefox 2.0).\n                    float dash = stroke.getDashArray()[i];\n                    array.append(fixedPrecision(dash > 0 ? dash : 0.1));\n                }\n                result.put(\"stroke-dasharray\", array.toString());\n            } else {\n                result.put(\"stroke-dasharray\", \"none\");\n            }\n        }\n\n        if (all || (stroke.getDashPhase() != defaultStroke.getDashPhase())) {\n            result.put(\"stroke-dashoffset\", fixedPrecision(stroke.getDashPhase()));\n        }\n\n        // append meter limit\n        if (all || (stroke.getMiterLimit() != defaultStroke.getMiterLimit())) {\n            result.put(\"stroke-miterlimit\", fixedPrecision(stroke.getMiterLimit()));\n        }\n\n        // append join\n        if (all || (stroke.getLineJoin() != defaultStroke.getLineJoin())) {\n            switch (stroke.getLineJoin()) {\n                default:\n                case BasicStroke.JOIN_MITER:\n                    result.put(\"stroke-linejoin\", \"miter\");\n                    break;\n                case BasicStroke.JOIN_ROUND:\n                    result.put(\"stroke-linejoin\", \"round\");\n                    break;\n                case BasicStroke.JOIN_BEVEL:\n                    result.put(\"stroke-linejoin\", \"bevel\");\n                    break;\n            }\n        }\n\n        // append linewidth\n        if (all || (stroke.getLineWidth() != defaultStroke.getLineWidth())) {\n            // width of 0 means thinnest line, which does not exist in SVG\n            if (stroke.getLineWidth() == 0) {\n                result.put(\"stroke-width\", fixedPrecision(0.000001f));\n            } else {\n                result.put(\"stroke-width\", fixedPrecision(stroke.getLineWidth()));\n            }\n        }\n\n        return result;\n    }\n\n    /* 8.2. paint/color */\n    public void setPaintMode() {\n        writeWarning(getClass() + \": setPaintMode() not implemented.\");\n    }\n\n    public void setXORMode(Color c1) {\n        writeWarning(getClass() + \": setXORMode(Color) not implemented.\");\n    }\n\n    protected void writePaint(Color c) throws IOException {\n        // written with every draw\n    }\n\n    protected void writePaint(GradientPaint paint) throws IOException {\n        if (gradients.get(paint) == null) {\n            String name = \"gradient-\" + gradients.size();\n            gradients.put(paint, name);\n            Point2D p1 = paint.getPoint1();\n            Point2D p2 = paint.getPoint2();\n            os.println(\"<defs>\");\n            os.print(\"  <linearGradient id=\\\"\" + name + \"\\\" \");\n\n            // special treatment of klighd's gradients, to support rotations\n            if (paint instanceof KlighdGradientPaint) {\n                // To make things easier and be able to reuse specified gradients, \n                //  we let the gradient always fill the whole bounding box. Thus we do not \n                //  need to specify explicit coordinates and can easily rotate \n                //  the gradient\n                os.print(\"gradientUnits=\\\"objectBoundingBox\\\" \");\n                os.print(\"gradientTransform=\\\"rotate(\"\n                        + (((KlighdGradientPaint) paint).getRotation()) + \")\\\" \");\n            } else {\n                os.print(\"x1=\\\"\" + fixedPrecision(p1.getX()) + \"\\\" \");\n                os.print(\"y1=\\\"\" + fixedPrecision(p1.getY()) + \"\\\" \");\n                os.print(\"x2=\\\"\" + fixedPrecision(p2.getX()) + \"\\\" \");\n                os.print(\"y2=\\\"\" + fixedPrecision(p2.getY()) + \"\\\" \");\n                os.print(\"gradientUnits=\\\"userSpaceOnUse\\\" \");\n                os.print(\"spreadMethod=\\\"\"\n                        + ((paint.isCyclic()) ? \"reflect\" : \"pad\") + \"\\\" \");\n            }\n            os.println(\">\");\n            os.println(\"    <stop offset=\\\"0\\\" stop-color=\\\"\"\n                    + hexColor(paint.getColor1()) + \"\\\" \" + \"opacity-stop=\\\"\"\n                    + alphaColor(paint.getColor1()) + \"\\\" />\");\n            os.println(\"    <stop offset=\\\"1\\\" stop-color=\\\"\"\n                    + hexColor(paint.getColor2()) + \"\\\" \" + \"opacity-stop=\\\"\"\n                    + alphaColor(paint.getColor2()) + \"\\\" />\");\n            os.println(\"  </linearGradient>\");\n            os.println(\"</defs>\");\n        }\n\n        // create style\n        Properties style = new Properties();\n        style.put(\"stroke\", hexColor(getPaint()));\n\n        // write style\n        os.print(\"<g \");\n        os.print(style(style));\n        os.println(\">\");\n\n        // close color later\n        closeTags.push(\"</g>\");\n        pushComment(closeTags, \" <!-- color -->\");\n    }\n\n    protected void writePaint(TexturePaint paint) throws IOException {\n        // written when needed\n    }\n\n    protected void writePaint(Paint p) throws IOException {\n        // written when needed\n    }\n\n    /* 8.3. font */\n    protected void writeFont(Font font) throws IOException {\n        // written when needed\n    }\n\n    /*\n     * ================================================================================ |\n     * 9. Auxiliary\n     * ================================================================================\n     */\n    public GraphicsConfiguration getDeviceConfiguration() {\n        writeWarning(getClass() + \": getDeviceConfiguration() not implemented.\");\n        return null;\n    }\n\n    public void writeComment(String s) throws IOException {\n        if (writeComments) {\n            os.println(\"<!-- \" + s + \" -->\");\n        }\n    }\n    \n    public void pushComment(final Stack<String> stack, String s) {\n        if (writeComments) {\n            // assure that the same number of elements is on the stack as before\n            stack.push(stack.pop() + s);\n        }\n    }\n\n    public String toString() {\n        return \"SVGGraphics2D\";\n    }\n\n    /*\n     * ================================================================================ |\n     * 10. Private/Utility Methos\n     * ================================================================================\n     */\n\n    /**\n     * Encapsulates a SVG-Tag by the given transformation matrix\n     *\n     * @param t\n     *            Transformation\n     * @param s\n     *            SVG-Tag\n     */\n    private String getTransformedString(AffineTransform t, String s) {\n        StringBuffer result = new StringBuffer();\n\n        if (t != null && !t.isIdentity()) {\n            result.append(\"<g transform=\\\"matrix(\");\n            result.append(fixedPrecision(t.getScaleX()));\n            result.append(\", \");\n            result.append(fixedPrecision(t.getShearY()));\n            result.append(\", \");\n            result.append(fixedPrecision(t.getShearX()));\n            result.append(\", \");\n            result.append(fixedPrecision(t.getScaleY()));\n            result.append(\", \");\n            result.append(fixedPrecision(t.getTranslateX()));\n            result.append(\", \");\n            result.append(fixedPrecision(t.getTranslateY()));\n            result.append(\")\\\">\\n\");\n        }\n\n        result.append(s);\n\n        if (t != null && !t.isIdentity()) {\n            result.append(\"\\n</g>\");\n            if (writeComments) {\n                result.append(\" <!-- transform -->\");\n            }\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Encapsulates a SVG-Tag by the current clipping area matrix\n     *\n     * @param s SVG-Tag\n     * @return SVG Tag encapsulated by the current clip\n     */\n    private String getClippedString(String s) {\n        StringBuffer result = new StringBuffer();\n\n        // clipping\n        if (isProperty(CLIP) && getClip() != null) {\n            // SVG uses unique lip numbers, don't reset allways increment them\n            clipNumber.set(clipNumber.getInt() + 1);\n\n            // define clip\n            result.append(\"<clipPath id=\\\"clip\");\n            result.append(clipNumber.getInt());\n            result.append(\"\\\">\\n  \");\n            result.append(getPath(getClip().getPathIterator(null)));\n            result.append(\"\\n</clipPath>\\n\");\n\n            // use clip\n            result.append(\"<g clip-path=\\\"url(#clip\");\n            result.append(clipNumber.getInt());\n            result.append(\")\\\">\\n\");\n        }\n\n        // append the string\n        result.append(s);\n\n        // close clipping\n        if (isProperty(CLIP) && getClip() != null) {\n            result.append(\"\\n</g>\");\n            if (writeComments) {\n                result.append(\"<!-- clip\");\n                result.append(clipNumber.getInt());\n                result.append(\" -->\");\n            }\n        }\n\n        return result.toString();\n    }\n\n    private float alphaColor(Paint p) {\n        if (p instanceof Color) {\n            return (float) (getPrintColor((Color) p).getAlpha() / 255.0);\n        } else if (p instanceof GradientPaint) {\n            return 1.0f;\n        } else if (p instanceof TexturePaint) {\n            return 1.0f;\n        }\n        writeWarning(getClass() + \": alphaColor() not implemented for \"\n                + p.getClass() + \".\");\n        return 1.0f;\n    }\n\n    private String hexColor(Paint p) {\n        if (p instanceof Color) {\n            return hexColor(getPrintColor((Color) p));\n        } else if (p instanceof GradientPaint) {\n            return hexColor((GradientPaint) p);\n        } else if (p instanceof TexturePaint) {\n            return hexColor((TexturePaint) p);\n        }\n        writeWarning(getClass() + \": hexColor() not implemented for \"\n                + p.getClass() + \".\");\n        return \"#000000\";\n    }\n\n    private String hexColor(Color c) {\n        String s1 = Integer.toHexString(c.getRed());\n        s1 = (s1.length() != 2) ? \"0\" + s1 : s1;\n\n        String s2 = Integer.toHexString(c.getGreen());\n        s2 = (s2.length() != 2) ? \"0\" + s2 : s2;\n\n        String s3 = Integer.toHexString(c.getBlue());\n        s3 = (s3.length() != 2) ? \"0\" + s3 : s3;\n\n        return \"#\" + s1 + s2 + s3;\n    }\n\n    private String hexColor(GradientPaint p) {\n        return \"url(#\" + gradients.get(p) + \")\";\n    }\n\n    private String hexColor(TexturePaint p) {\n        return \"url(#\" + textures.get(p) + \")\";\n    }\n\n    protected static String getPathContent(PathIterator path) {\n        StringBuffer result = new StringBuffer();\n\n        double[] coords = new double[6];\n        result.append(\"d=\\\"\");\n        while (!path.isDone()) {\n            int segType = path.currentSegment(coords);\n\n            switch (segType) {\n                case PathIterator.SEG_MOVETO:\n                    result.append(\"M \");\n                    result.append(fixedPrecision(coords[0]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[1]));\n                    break;\n                case PathIterator.SEG_LINETO:\n                    result.append(\"L \");\n                    result.append(fixedPrecision(coords[0]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[1]));\n                    break;\n                case PathIterator.SEG_CUBICTO:\n                    result.append(\"C \");\n                    result.append(fixedPrecision(coords[0]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[1]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[2]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[3]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[4]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[5]));\n                    break;\n                case PathIterator.SEG_QUADTO:\n                    result.append(\"Q \");\n                    result.append(fixedPrecision(coords[0]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[1]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[2]));\n                    result.append(\" \");\n                    result.append(fixedPrecision(coords[3]));\n                    break;\n                case PathIterator.SEG_CLOSE:\n                    result.append(\"z\");\n                    break;\n            }\n\n            // Move to the next segment.\n            path.next();\n\n            // Not needed but makes the output readable\n            if (!path.isDone()) {\n                result.append(\" \");\n            }\n        }\n        result.append(\"\\\"\");\n\n        return result.toString();\n    }\n\n    protected String getPath(PathIterator path) {\n        StringBuffer result = new StringBuffer();\n\n        result.append(\"<path \");\n        result.append(attributes(true));\n        result.append(getPathContent(path));\n        result.append(\"/>\");\n\n        return result.toString();\n    }\n\n\n    public void addSemanticData(final KlighdSemanticDiagramData nextSemanticData) {\n        this.semanticData = nextSemanticData;\n    }\n\n    private String attributes(boolean resetSemData) {\n        if (semanticData == null) {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer(\" \");\n\n        for (final Entry<String, String> e : semanticData) {\n\n            // special tags\n            if (e.getKey().equals(KlighdConstants.SEMANTIC_DATA_ID)) {\n                sb.append(\"id\" + \"=\\\"\" + e.getValue() + \"\\\"\");\n\n            } else if (e.getKey().equals(KlighdConstants.SEMANTIC_DATA_CLASS)) {\n                sb.append(\"class\" + \"=\\\"\" + e.getValue() + \"\\\"\");\n\n            } else if (e.getKey().equals(KlighdConstants.SEMANTIC_DATA_RAW)) {\n                sb.append(e.getValue());\n                \n            } else {\n                sb.append(\"klighd:\" + e.getKey() + \"=\\\"\" + e.getValue() + \"\\\"\");\n            }\n\n            sb.append(\" \");\n        }\n\n        if (resetSemData) {\n            resetSemanticData();\n        }\n        return sb.toString();\n    }\n\n    private String tSpanAttributes(final String textLine, final int noOfLine) {\n        if (semanticData == null) {\n            return \"\";\n        }\n\n        final StringBuffer sb = new StringBuffer(\" \");\n\n        for (final Entry<String, String> e : semanticData.textLineIterable(textLine, noOfLine)) {\n\n            // special tags\n            if (e.getKey().equals(KlighdConstants.SEMANTIC_DATA_ID)) {\n                sb.append(\"id\" + \"=\\\"\" + e.getValue() + \"\\\"\");\n\n            } else if (e.getKey().equals(KlighdConstants.SEMANTIC_DATA_RAW)) {\n                sb.append(e.getValue());\n\n            } else {\n                sb.append(\"klighd:\" + e.getKey() + \"=\\\"\" + e.getValue() + \"\\\"\");\n            }\n\n            sb.append(\" \");\n        }\n\n        return sb.toString();\n    }\n\n    private void resetSemanticData() {\n        this.semanticData = null;\n    }\n\n\n    //If no semantic data is set these groups are unnecessary clutter. This\n    // stack keeps track of them and prevents printing of those that are not needed.\n    private Stack<Boolean> groupsStack = new Stack<Boolean>();\n    public void startGroup(KlighdSemanticDiagramData nextSemanticData) {\n        this.semanticData = nextSemanticData;\n        if ((this.semanticData != null && this.semanticData.iterator().hasNext())) {\n            os.write(\"<g \");\n            os.write(attributes(true));\n            os.write(\" >\\n\");\n            groupsStack.push(true);\n        } else {\n            groupsStack.push(false);\n        }\n    }\n\n    public void endGroup() {\n        if (groupsStack.peek()) {\n            os.write(\"</g>\\n\");\n        }\n        groupsStack.pop();\n    }\n    \n\n    /**\n     * For a given \"key -> value\" property set the\n     * method creates\n     * style=\"key1:value1;key2:value2;\" or\n     * key2=\"value2\" key2=\"value2\" depending on\n     * {@link #STYLABLE}.\n     *\n     * @param style properties to convert\n     * @return String\n     */\n    private String style(Properties style) {\n        if (style == null || style.isEmpty()) {\n            return \"\";\n        }\n\n        StringBuffer result = new StringBuffer();\n        boolean styleable = isProperty(STYLABLE);\n\n        // embed everything in a \"style\" attribute\n        if (styleable) {\n            result.append(\"style=\\\"\");\n        }\n\n        Enumeration<?> keys = style.keys();\n        while (keys.hasMoreElements()) {\n            String key = (String) keys.nextElement();\n            String value = style.getProperty(key);\n\n            result.append(key);\n\n            if (styleable) {\n                result.append(\":\");\n                result.append(value);\n                result.append(\";\");\n            } else {\n                result.append(\"=\\\"\");\n                result.append(value);\n                result.append(\"\\\"\");\n                if (keys.hasMoreElements()) {\n                    result.append(\" \");\n                }\n            }\n        }\n\n        // close the style attribute\n        if (styleable) {\n            result.append(\"\\\"\");\n        }\n\n        return result.toString();\n    }\n\n    \n    /**\n     * Builds up a AWT {@link Path2D} according to a given SWT Geometry {@link PathData}.\n     * \n     * @param pathData\n     *            provides the segments the new path shall contain.\n     *            the device to create the path on\n     * @return the desired {@link Path2D} object.\n     */\n    public static Path2D createAWTPath(final PathData pathData) {\n        final Path2D p2d = new Path2D.Double();\n        final float[] pts = pathData.points;\n\n        int i = 0;\n        for (byte type : pathData.types) {\n            switch (type) {\n            case SWT.PATH_MOVE_TO:\n                p2d.moveTo(pts[i++], pts[i++]);\n                break;\n            case SWT.PATH_LINE_TO:\n                p2d.lineTo(pts[i++], pts[i++]);\n                break;\n            case SWT.PATH_CLOSE:\n                p2d.closePath();\n                break;\n            case SWT.PATH_QUAD_TO:\n                p2d.quadTo(pts[i++], pts[i++], pts[i++], pts[i++]);\n                break;\n            case SWT.PATH_CUBIC_TO:\n                p2d.curveTo(pts[i++], pts[i++], pts[i++], pts[i++], pts[i++], pts[i++]);\n                break;\n            default:\n            }\n        }\n        return p2d;\n    }\n    \n    private org.eclipse.swt.graphics.Font getSWTFont() {\n        return getSWTFont(getFont());\n    }\n    \n    /**\n     * @param font\n     *            the awt font for which to assemble an swt font.\n     * @return either the corresponding swt font, or {@code null} if no dispaly exists.\n     */\n    private org.eclipse.swt.graphics.Font getSWTFont(final Font font) {\n        if (!awtSwtFontCache.containsKey(font) && display != null) {\n            // note that the style constants for swt and awt are equal\n            org.eclipse.swt.graphics.Font swtFont =\n                    new org.eclipse.swt.graphics.Font(display, getFont().getName(), getFont()\n                            .getSize(), getSWTFontStyle());\n            awtSwtFontCache.put(font, swtFont);\n        }\n        return awtSwtFontCache.get(font);\n    }\n    \n    private int getSWTFontStyle() {\n        switch (getFont().getStyle()) {\n        case Font.PLAIN:\n            return SWT.NORMAL;\n        case Font.BOLD:\n            return SWT.BOLD;\n        case Font.ITALIC:\n            return SWT.ITALIC;\n        }\n        // default\n        return SWT.NORMAL;\n    }\n    \n    /**\n     * for fixedPrecision(double d), SVG does not understand \"1E-7\"\n     * we have to use \".0000007\" instead\n     */\n    private static DecimalFormat scientific = new DecimalFormat(\n        \"#.####################\",\n        new DecimalFormatSymbols(Locale.US));\n\n    /**\n     * converts the double value to a representing string\n     *\n     * @param d double value to convert\n     * @return same as string\n     */\n    public static String fixedPrecision(double d) {\n        return scientific.format(d);\n    }\n\n    protected PrintWriter getOutputStream() {\n        return os;\n    }\n}\n"},
{"Line": "=>166", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (!(((match.getAwayTeamGoals()) == null) || ((match.getHomeTeamGoals()) == null))) { if (this.getWinner(match).equals(team)) { victories += 1; } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/719/buggy-version/sm-service.src.main.java.cz.fi.muni.pa165.soccermanager.service.MatchServiceImpl.java", "BodyUseAPI": ["cz.fi.muni.pa165.soccermanager.service.MatchServiceImpl.getWinner(cz.fi.muni.pa165.soccermanager.data.Match)", "cz.fi.muni.pa165.soccermanager.data.Team.equals(cz.fi.muni.pa165.soccermanager.data.Team)"], "Fixed commit": "ccd1c9d07662d2b64ba651bb5048c56327e2a3f1", "Url": "https://api.github.com/repos/Gobanit/SoccerManager", "Date": "2018-11-22T18:30:20Z", "Source Code Diff": "@@ -162,9 +162,11 @@ public Team getWinner(Match match) {\n     public int getVictoriesOfTeam(Team team) {\n         int victories = 0;\n \n-        for (Match match : this.findAll()) {\n-            if (this.getWinner(match).equals(team)) {\n-                victories += 1;\n+        for (Match match : this.findByTeam(team)) {\n+            if (!(match.getAwayTeamGoals() == null || match.getHomeTeamGoals() == null)) {\n+                if (this.getWinner(match).equals(team)) {\n+                    victories += 1;\n+                }\n             }\n         }\n         return victories;", "Complete After Code": "package cz.fi.muni.pa165.soccermanager.service;\n\nimport cz.fi.muni.pa165.soccermanager.api.exceptions.ErrorStatus;\nimport cz.fi.muni.pa165.soccermanager.api.exceptions.SoccerManagerServiceException;\nimport cz.fi.muni.pa165.soccermanager.dao.MatchDAO;\nimport cz.fi.muni.pa165.soccermanager.data.Match;\nimport cz.fi.muni.pa165.soccermanager.data.SoccerPlayer;\nimport cz.fi.muni.pa165.soccermanager.data.Team;\nimport org.springframework.stereotype.Service;\n\nimport javax.inject.Inject;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Implementation of {@link MatchService}\n *\n * @author Lenka Horvathova\n */\n@Service\npublic class MatchServiceImpl implements MatchService {\n\n    private final MatchDAO matchDAO;\n\n    @Inject\n    public MatchServiceImpl(MatchDAO matchDAO) {\n        this.matchDAO = matchDAO;\n    }\n\n    @Override\n    public void create(Match match) {\n        matchDAO.save(match);\n    }\n\n    @Override\n    public void remove(Match match) {\n        Match matchToBeDeleted = this.findById(match.getId());\n        matchDAO.delete(matchToBeDeleted);\n    }\n\n    @Override\n    public Match findById(Long id) {\n        Match foundMatch = matchDAO.findById(id);\n        if (foundMatch == null) {\n            throw new SoccerManagerServiceException(\"No match found with an ID: \" + id, ErrorStatus.RESOURCE_NOT_FOUND);\n        }\n        return foundMatch;\n    }\n\n    @Override\n    public List<Match> findAll() {\n        return matchDAO.findAll();\n    }\n\n    @Override\n    public List<Match> findByTeam(Team team) {\n        List<Match> teamMatches = new ArrayList<>();\n\n        for (Match match : this.findAll()) {\n            if (match.getHomeTeam().equals(team) || match.getAwayTeam().equals(team)) {\n                teamMatches.add(match);\n            }\n        }\n        return teamMatches;\n    }\n\n    @Override\n    public List<Match> findAwaitingMatches() {\n        List<Match> awaitingMatches = new ArrayList<>();\n\n        for (Match match : this.findAll()) {\n            if (LocalDateTime.now().isAfter(match.getDate())\n                    && match.getHomeTeamGoals() == null && match.getAwayTeamGoals() == null) {\n                awaitingMatches.add(match);\n            }\n        }\n        return awaitingMatches;\n    }\n\n    @Override\n    public void simulateMatch(Match match) {\n        if (match.getAwayTeamGoals() != null || match.getHomeTeamGoals() != null) {\n            throw new SoccerManagerServiceException(\n                    \"A match with an ID \\\"\" + match.getId() + \"\\\" has already been simulated!\",\n                    ErrorStatus.MATCH_ALREADY_SIMULATED\n            );\n        }\n\n        if (LocalDateTime.now().isBefore(match.getDate())) {\n            throw new SoccerManagerServiceException(\n                    \"A match with an ID \\\"\" + match.getId() + \"\\\" has not taken place yet!\",\n                    ErrorStatus.MATCH_DATE_IN_THE_FUTURE\n            );\n        }\n\n        int awayTeamChance = 0;\n        int homeTeamChance = 0;\n\n        for (SoccerPlayer player : match.getAwayTeam().getPlayers()) {\n            awayTeamChance += player.getRating();\n        }\n        for (SoccerPlayer player : match.getHomeTeam().getPlayers()) {\n            homeTeamChance += player.getRating();\n        }\n\n        awayTeamChance = ((awayTeamChance * 100) / (awayTeamChance + homeTeamChance));\n        homeTeamChance = ((homeTeamChance * 100) / (awayTeamChance + homeTeamChance));\n\n        int random = (int) (Math.random() * 100);\n\n        if (awayTeamChance < homeTeamChance) {\n            if (random < awayTeamChance) {\n                int divider = randomWithRange(0, 10);\n\n                match.setAwayTeamGoals(randomWithRange(divider, 0));\n                match.setHomeTeamGoals(randomWithRange(0, divider));\n            } else {\n                int divider = randomWithRange(0, 10);\n\n                match.setAwayTeamGoals(randomWithRange(0, divider));\n                match.setHomeTeamGoals(randomWithRange(divider, 10));\n            }\n        } else {\n            if (random < homeTeamChance) {\n                int divider = randomWithRange(0, 10);\n\n                match.setAwayTeamGoals(randomWithRange(0, divider));\n                match.setHomeTeamGoals(randomWithRange(divider, 10));\n            } else {\n                int divider = randomWithRange(0, 10);\n\n                match.setAwayTeamGoals(randomWithRange(divider, 0));\n                match.setHomeTeamGoals(randomWithRange(0, divider));\n            }\n        }\n    }\n\n    private int randomWithRange(int min, int max) {\n        int range = (max - min) + 1;\n        return (int) (Math.random() * range) + min;\n    }\n\n    @Override\n    public Team getWinner(Match match) {\n        if (match.getAwayTeamGoals() == null || match.getHomeTeamGoals() == null) {\n            throw new SoccerManagerServiceException(\n                    \"A match with an ID \\\"\" + match.getId() + \"\\\" has not been simulated yet!\",\n                    ErrorStatus.MATCH_NOT_SIMULATED\n            );\n        }\n\n        if (match.getHomeTeamGoals() > match.getAwayTeamGoals()) {\n            return match.getHomeTeam();\n        } else if (match.getHomeTeamGoals() < match.getAwayTeamGoals()) {\n            return match.getAwayTeam();\n        }\n        return null;\n    }\n\n    @Override\n    public int getVictoriesOfTeam(Team team) {\n        int victories = 0;\n\n        for (Match match : this.findByTeam(team)) {\n            if (!(match.getAwayTeamGoals() == null || match.getHomeTeamGoals() == null)) {\n                if (this.getWinner(match).equals(team)) {\n                    victories += 1;\n                }\n            }\n        }\n        return victories;\n    }\n}\n"},
{"Line": "=>1438", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["jloda.util.parse.NexusStreamParser.getWordRespectCase()"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if (word.startsWith(\"#\")) { javafx.scene.paint.Color fx = javafx.scene.paint.Color.web(word); return new java.awt.Color(((float) (fx.getRed())), ((float) (fx.getGreen())), ((float) (fx.getBlue())), ((float) (fx.getOpacity()))); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/29/buggy-version/src.jloda.util.parse.NexusStreamParser.java", "BodyUseAPI": ["javafx.scene.paint.Color.web(java.lang.String)"], "Fixed commit": "fb5b35edf1e23c16f1258c6578d8d2b4925c936a", "Url": "https://api.github.com/repos/danielhuson/jloda", "Date": "2018-12-20T13:20:08Z"},
{"Line": "=>253", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (((getConfigOverrides()) != null) && ((getConfigOverrides().length()) > 0)) { container.addVolumeMountsItem(oracle.kubernetes.operator.helpers.JobStepContext.readOnlyVolumeMount(((getConfigOverrides()) + \"-volume\"), oracle.kubernetes.operator.helpers.OVERRIDES_CM_MOUNT_PATH)); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/828/buggy-version/operator.src.main.java.oracle.kubernetes.operator.helpers.JobStepContext.java", "BodyUseAPI": [], "Fixed commit": "4f0ae919db5cc94000d6f0d66576c2b8083bf221", "Url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator", "Date": "2018-11-21T07:05:23Z", "Source Code Diff": "@@ -4,6 +4,7 @@\n import java.io.File;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Optional;\n import oracle.kubernetes.operator.KubernetesConstants;\n import oracle.kubernetes.operator.LabelConstants;\n import oracle.kubernetes.operator.ProcessingConstants;\n@@ -70,8 +71,13 @@ private List<V1PersistentVolumeClaim> getClaims() {\n     return info.getClaims().getItems();\n   }\n \n+  private String getDiscoveredClaim() {\n+    return getClaims().isEmpty() ? null : getClaims().iterator().next().getMetadata().getName();\n+  }\n+\n   private String getClaimName() {\n-    return getClaims().iterator().next().getMetadata().getName();\n+    return Optional.ofNullable(info.getDomain().getPersistentVolumeClaimName())\n+        .orElse(getDiscoveredClaim());\n   }\n \n   // ----------------------- step methods ------------------------------\n@@ -208,7 +214,7 @@ private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n \n     podSpec.setImagePullSecrets(info.getDomain().getSpec().getImagePullSecrets());\n \n-    if (!getClaims().isEmpty()) {\n+    if (getClaimName() != null) {\n       podSpec.addVolumesItem(\n           new V1Volume()\n               .name(STORAGE_VOLUME)\n@@ -222,10 +228,12 @@ private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n               .name(secretName + \"-volume\")\n               .secret(getOverrideSecretVolumeSource(secretName)));\n     }\n-    podSpec.addVolumesItem(\n-        new V1Volume()\n-            .name(getConfigOverrides() + \"-volume\")\n-            .configMap(getOverridesVolumeSource(getConfigOverrides())));\n+    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n+      podSpec.addVolumesItem(\n+          new V1Volume()\n+              .name(getConfigOverrides() + \"-volume\")\n+              .configMap(getOverridesVolumeSource(getConfigOverrides())));\n+    }\n \n     return podSpec;\n   }\n@@ -239,11 +247,14 @@ private V1Container createContainer(TuningParameters tuningParameters) {\n             .command(getContainerCommand())\n             .env(getEnvironmentVariables(tuningParameters))\n             .addVolumeMountsItem(volumeMount(STORAGE_VOLUME, STORAGE_MOUNT_PATH))\n-            .addVolumeMountsItem(\n-                readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH))\n             .addVolumeMountsItem(readOnlyVolumeMount(SECRETS_VOLUME, SECRETS_MOUNT_PATH))\n             .addVolumeMountsItem(readOnlyVolumeMount(SCRIPTS_VOLUME, SCRIPTS_MOUNTS_PATH));\n \n+    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n+      container.addVolumeMountsItem(\n+          readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH));\n+    }\n+\n     List<String> configOverrideSecrets = getConfigOverrideSecrets();\n     for (String secretName : configOverrideSecrets) {\n       container.addVolumeMountsItem(", "Complete After Code": "package oracle.kubernetes.operator.helpers;\n\nimport io.kubernetes.client.models.*;\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport oracle.kubernetes.operator.KubernetesConstants;\nimport oracle.kubernetes.operator.LabelConstants;\nimport oracle.kubernetes.operator.ProcessingConstants;\nimport oracle.kubernetes.operator.TuningParameters;\nimport oracle.kubernetes.operator.VersionConstants;\nimport oracle.kubernetes.operator.calls.CallResponse;\nimport oracle.kubernetes.operator.logging.LoggingFacade;\nimport oracle.kubernetes.operator.logging.LoggingFactory;\nimport oracle.kubernetes.operator.work.NextAction;\nimport oracle.kubernetes.operator.work.Packet;\nimport oracle.kubernetes.operator.work.Step;\nimport oracle.kubernetes.weblogic.domain.v2.Domain;\n\npublic abstract class JobStepContext implements StepContextConstants {\n  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n\n  private static final String WEBLOGIC_OPERATOR_SCRIPTS_INTROSPECT_DOMAIN_SH =\n      \"/weblogic-operator/scripts/introspectDomain.sh\";\n\n  private final DomainPresenceInfo info;\n  private V1Job jobModel;\n\n  JobStepContext(Packet packet) {\n    info = packet.getSPI(DomainPresenceInfo.class);\n  }\n\n  void init() {\n    jobModel = createJobModel();\n  }\n\n  private V1Job getJobModel() {\n    return jobModel;\n  }\n\n  // ------------------------ data methods ----------------------------\n\n  String getNamespace() {\n    return info.getNamespace();\n  }\n\n  String getDomainUID() {\n    return getDomain().getDomainUID();\n  }\n\n  Domain getDomain() {\n    return info.getDomain();\n  }\n\n  String getDomainName() {\n    return getDomain().getDomainName();\n  }\n\n  private String getDomainResourceName() {\n    return info.getDomain().getMetadata().getName();\n  }\n\n  abstract String getJobName();\n\n  private String getAdminSecretName() {\n    return getDomain().getAdminSecret().getName();\n  }\n\n  private List<V1PersistentVolumeClaim> getClaims() {\n    return info.getClaims().getItems();\n  }\n\n  private String getDiscoveredClaim() {\n    return getClaims().isEmpty() ? null : getClaims().iterator().next().getMetadata().getName();\n  }\n\n  private String getClaimName() {\n    return Optional.ofNullable(info.getDomain().getPersistentVolumeClaimName())\n        .orElse(getDiscoveredClaim());\n  }\n\n  // ----------------------- step methods ------------------------------\n\n  /**\n   * Creates the specified new pod and performs any additional needed processing.\n   *\n   * @param next the next step to perform after the pod creation is complete.\n   * @return a step to be scheduled.\n   */\n  abstract Step createNewJob(Step next);\n\n  /**\n   * Creates the specified new job.\n   *\n   * @param next the next step to perform after the job creation is complete.\n   * @return a step to be scheduled.\n   */\n  Step createJob(Step next) {\n    return new CallBuilder().createJobAsync(getNamespace(), getJobModel(), createResponse(next));\n  }\n\n  protected void logJobCreated() {\n    LOGGER.info(getJobCreatedMessageKey(), getJobName());\n  }\n\n  abstract String getJobCreatedMessageKey();\n\n  protected String getNodeManagerHome() {\n    return NODEMGR_HOME;\n  }\n\n  protected String getLogHome() {\n    return getDomain().getLogHome();\n  }\n\n  protected boolean isDomainHomeInImage() {\n    return getDomain().isDomainHomeInImage();\n  }\n\n  String getEffectiveLogHome() {\n    String logHome = getLogHome();\n    if (logHome == null || \"\".equals(logHome.trim())) {\n      // logHome not specified, use default value\n      return DEFAULT_LOG_HOME + File.separator + getDomainUID();\n    }\n    return logHome;\n  }\n\n  String getIncludeServerOutInPodLog() {\n    return getDomain().getIncludeServerOutInPodLog();\n  }\n\n  protected String getIntrospectHome() {\n    return getDomainHome();\n  }\n\n  List<String> getConfigOverrideSecrets() {\n    return getDomain().getConfigOverrideSecrets();\n  }\n\n  String getConfigOverrides() {\n    return getDomain().getConfigOverrides();\n  }\n\n  private ResponseStep<V1Job> createResponse(Step next) {\n    return new CreateResponseStep(next);\n  }\n\n  private class CreateResponseStep extends ResponseStep<V1Job> {\n    CreateResponseStep(Step next) {\n      super(next);\n    }\n\n    @Override\n    public NextAction onFailure(Packet packet, CallResponse<V1Job> callResponse) {\n      return super.onFailure(packet, callResponse);\n    }\n\n    @Override\n    public NextAction onSuccess(Packet packet, CallResponse<V1Job> callResponse) {\n      logJobCreated();\n      V1Job job = callResponse.getResult();\n      if (job != null) {\n        packet.put(ProcessingConstants.DOMAIN_INTROSPECTOR_JOB, job);\n      }\n      return doNext(packet);\n    }\n  }\n\n  // ---------------------- model methods ------------------------------\n\n  private V1Job createJobModel() {\n    return new V1Job()\n        .metadata(createMetadata())\n        .spec(createJobSpec(TuningParameters.getInstance()));\n  }\n\n  V1ObjectMeta createMetadata() {\n    V1ObjectMeta metadata =\n        new V1ObjectMeta()\n            .name(getJobName())\n            .namespace(getNamespace())\n            .putLabelsItem(LabelConstants.RESOURCE_VERSION_LABEL, VersionConstants.DOMAIN_V1)\n            .putLabelsItem(LabelConstants.DOMAINUID_LABEL, getDomainUID())\n            .putLabelsItem(LabelConstants.DOMAINNAME_LABEL, getDomainName())\n            .putLabelsItem(LabelConstants.CREATEDBYOPERATOR_LABEL, \"true\");\n    return metadata;\n  }\n\n  protected V1JobSpec createJobSpec(TuningParameters tuningParameters) {\n    V1JobSpec jobSpec =\n        new V1JobSpec().backoffLimit(0).template(createPodTemplateSpec(tuningParameters));\n\n    return jobSpec;\n  }\n\n  private V1PodTemplateSpec createPodTemplateSpec(TuningParameters tuningParameters) {\n    V1ObjectMeta metadata = new V1ObjectMeta().name(getJobName());\n    V1PodTemplateSpec podTemplateSpec =\n        new V1PodTemplateSpec().metadata(metadata).spec(createPodSpec(tuningParameters));\n    return podTemplateSpec;\n  }\n\n  private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n    V1PodSpec podSpec =\n        new V1PodSpec()\n            .activeDeadlineSeconds(60L)\n            .restartPolicy(\"Never\")\n            .addContainersItem(createContainer(tuningParameters))\n            .addVolumesItem(new V1Volume().name(SECRETS_VOLUME).secret(getSecretsVolume()))\n            .addVolumesItem(\n                new V1Volume().name(SCRIPTS_VOLUME).configMap(getConfigMapVolumeSource()));\n\n    podSpec.setImagePullSecrets(info.getDomain().getSpec().getImagePullSecrets());\n\n    if (getClaimName() != null) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(STORAGE_VOLUME)\n              .persistentVolumeClaim(getPersistenVolumeClaimVolumeSource(getClaimName())));\n    }\n\n    List<String> configOverrideSecrets = getConfigOverrideSecrets();\n    for (String secretName : configOverrideSecrets) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(secretName + \"-volume\")\n              .secret(getOverrideSecretVolumeSource(secretName)));\n    }\n    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(getConfigOverrides() + \"-volume\")\n              .configMap(getOverridesVolumeSource(getConfigOverrides())));\n    }\n\n    return podSpec;\n  }\n\n  private V1Container createContainer(TuningParameters tuningParameters) {\n    V1Container container =\n        new V1Container()\n            .name(getJobName())\n            .image(getImageName())\n            .imagePullPolicy(getImagePullPolicy())\n            .command(getContainerCommand())\n            .env(getEnvironmentVariables(tuningParameters))\n            .addVolumeMountsItem(volumeMount(STORAGE_VOLUME, STORAGE_MOUNT_PATH))\n            .addVolumeMountsItem(readOnlyVolumeMount(SECRETS_VOLUME, SECRETS_MOUNT_PATH))\n            .addVolumeMountsItem(readOnlyVolumeMount(SCRIPTS_VOLUME, SCRIPTS_MOUNTS_PATH));\n\n    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n      container.addVolumeMountsItem(\n          readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH));\n    }\n\n    List<String> configOverrideSecrets = getConfigOverrideSecrets();\n    for (String secretName : configOverrideSecrets) {\n      container.addVolumeMountsItem(\n          readOnlyVolumeMount(secretName + \"-volume\", OVERRIDE_SECRETS_MOUNT_PATH));\n    }\n    return container;\n  }\n\n  String getImageName() {\n    String imageName = getDomain().getSpec().getImage();\n    if (imageName == null) {\n      imageName = KubernetesConstants.DEFAULT_IMAGE;\n    }\n    return imageName;\n  }\n\n  String getImagePullPolicy() {\n    return KubernetesConstants.IFNOTPRESENT_IMAGEPULLPOLICY;\n  }\n\n  protected List<String> getContainerCommand() {\n    return Arrays.asList(WEBLOGIC_OPERATOR_SCRIPTS_INTROSPECT_DOMAIN_SH);\n  }\n\n  abstract List<V1EnvVar> getEnvironmentVariables(TuningParameters tuningParameters);\n\n  protected String getDomainHome() {\n    return \"/shared/domains/\" + getDomainUID();\n  }\n\n  static void addEnvVar(List<V1EnvVar> vars, String name, String value) {\n    vars.add(new V1EnvVar().name(name).value(value));\n  }\n\n  private static V1VolumeMount readOnlyVolumeMount(String volumeName, String mountPath) {\n    return volumeMount(volumeName, mountPath).readOnly(true);\n  }\n\n  private static V1VolumeMount volumeMount(String volumeName, String mountPath) {\n    return new V1VolumeMount().name(volumeName).mountPath(mountPath);\n  }\n\n  protected V1SecretVolumeSource getSecretsVolume() {\n    return new V1SecretVolumeSource().secretName(getAdminSecretName()).defaultMode(420);\n  }\n\n  protected V1ConfigMapVolumeSource getConfigMapVolumeSource() {\n    return new V1ConfigMapVolumeSource()\n        .name(KubernetesConstants.DOMAIN_CONFIG_MAP_NAME)\n        .defaultMode(ALL_READ_AND_EXECUTE);\n  }\n\n  protected V1ConfigMapVolumeSource getConfigMapVolumeSource(String name, int mode) {\n    return new V1ConfigMapVolumeSource().name(name).defaultMode(mode);\n  }\n\n  protected V1PersistentVolumeClaimVolumeSource getPersistenVolumeClaimVolumeSource(\n      String claimName) {\n    return new V1PersistentVolumeClaimVolumeSource().claimName(claimName);\n  }\n\n  protected V1SecretVolumeSource getOverrideSecretVolumeSource(String name) {\n    return new V1SecretVolumeSource().secretName(name).defaultMode(420);\n  }\n\n  protected V1ConfigMapVolumeSource getOverridesVolumeSource(String name) {\n    return new V1ConfigMapVolumeSource().name(name).defaultMode(ALL_READ_AND_EXECUTE);\n  }\n}\n"},
{"Line": "=>231", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (((getConfigOverrides()) != null) && ((getConfigOverrides().length()) > 0)) { podSpec.addVolumesItem(new oracle.kubernetes.operator.helpers.V1Volume().name(((getConfigOverrides()) + \"-volume\")).configMap(getOverridesVolumeSource(getConfigOverrides()))); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/828/buggy-version/operator.src.main.java.oracle.kubernetes.operator.helpers.JobStepContext.java", "BodyUseAPI": [], "Fixed commit": "4f0ae919db5cc94000d6f0d66576c2b8083bf221", "Url": "https://api.github.com/repos/oracle/weblogic-kubernetes-operator", "Date": "2018-11-21T07:05:23Z", "Source Code Diff": "@@ -4,6 +4,7 @@\n import java.io.File;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Optional;\n import oracle.kubernetes.operator.KubernetesConstants;\n import oracle.kubernetes.operator.LabelConstants;\n import oracle.kubernetes.operator.ProcessingConstants;\n@@ -70,8 +71,13 @@ private List<V1PersistentVolumeClaim> getClaims() {\n     return info.getClaims().getItems();\n   }\n \n+  private String getDiscoveredClaim() {\n+    return getClaims().isEmpty() ? null : getClaims().iterator().next().getMetadata().getName();\n+  }\n+\n   private String getClaimName() {\n-    return getClaims().iterator().next().getMetadata().getName();\n+    return Optional.ofNullable(info.getDomain().getPersistentVolumeClaimName())\n+        .orElse(getDiscoveredClaim());\n   }\n \n   // ----------------------- step methods ------------------------------\n@@ -208,7 +214,7 @@ private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n \n     podSpec.setImagePullSecrets(info.getDomain().getSpec().getImagePullSecrets());\n \n-    if (!getClaims().isEmpty()) {\n+    if (getClaimName() != null) {\n       podSpec.addVolumesItem(\n           new V1Volume()\n               .name(STORAGE_VOLUME)\n@@ -222,10 +228,12 @@ private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n               .name(secretName + \"-volume\")\n               .secret(getOverrideSecretVolumeSource(secretName)));\n     }\n-    podSpec.addVolumesItem(\n-        new V1Volume()\n-            .name(getConfigOverrides() + \"-volume\")\n-            .configMap(getOverridesVolumeSource(getConfigOverrides())));\n+    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n+      podSpec.addVolumesItem(\n+          new V1Volume()\n+              .name(getConfigOverrides() + \"-volume\")\n+              .configMap(getOverridesVolumeSource(getConfigOverrides())));\n+    }\n \n     return podSpec;\n   }\n@@ -239,11 +247,14 @@ private V1Container createContainer(TuningParameters tuningParameters) {\n             .command(getContainerCommand())\n             .env(getEnvironmentVariables(tuningParameters))\n             .addVolumeMountsItem(volumeMount(STORAGE_VOLUME, STORAGE_MOUNT_PATH))\n-            .addVolumeMountsItem(\n-                readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH))\n             .addVolumeMountsItem(readOnlyVolumeMount(SECRETS_VOLUME, SECRETS_MOUNT_PATH))\n             .addVolumeMountsItem(readOnlyVolumeMount(SCRIPTS_VOLUME, SCRIPTS_MOUNTS_PATH));\n \n+    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n+      container.addVolumeMountsItem(\n+          readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH));\n+    }\n+\n     List<String> configOverrideSecrets = getConfigOverrideSecrets();\n     for (String secretName : configOverrideSecrets) {\n       container.addVolumeMountsItem(", "Complete After Code": "package oracle.kubernetes.operator.helpers;\n\nimport io.kubernetes.client.models.*;\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport oracle.kubernetes.operator.KubernetesConstants;\nimport oracle.kubernetes.operator.LabelConstants;\nimport oracle.kubernetes.operator.ProcessingConstants;\nimport oracle.kubernetes.operator.TuningParameters;\nimport oracle.kubernetes.operator.VersionConstants;\nimport oracle.kubernetes.operator.calls.CallResponse;\nimport oracle.kubernetes.operator.logging.LoggingFacade;\nimport oracle.kubernetes.operator.logging.LoggingFactory;\nimport oracle.kubernetes.operator.work.NextAction;\nimport oracle.kubernetes.operator.work.Packet;\nimport oracle.kubernetes.operator.work.Step;\nimport oracle.kubernetes.weblogic.domain.v2.Domain;\n\npublic abstract class JobStepContext implements StepContextConstants {\n  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n\n  private static final String WEBLOGIC_OPERATOR_SCRIPTS_INTROSPECT_DOMAIN_SH =\n      \"/weblogic-operator/scripts/introspectDomain.sh\";\n\n  private final DomainPresenceInfo info;\n  private V1Job jobModel;\n\n  JobStepContext(Packet packet) {\n    info = packet.getSPI(DomainPresenceInfo.class);\n  }\n\n  void init() {\n    jobModel = createJobModel();\n  }\n\n  private V1Job getJobModel() {\n    return jobModel;\n  }\n\n  // ------------------------ data methods ----------------------------\n\n  String getNamespace() {\n    return info.getNamespace();\n  }\n\n  String getDomainUID() {\n    return getDomain().getDomainUID();\n  }\n\n  Domain getDomain() {\n    return info.getDomain();\n  }\n\n  String getDomainName() {\n    return getDomain().getDomainName();\n  }\n\n  private String getDomainResourceName() {\n    return info.getDomain().getMetadata().getName();\n  }\n\n  abstract String getJobName();\n\n  private String getAdminSecretName() {\n    return getDomain().getAdminSecret().getName();\n  }\n\n  private List<V1PersistentVolumeClaim> getClaims() {\n    return info.getClaims().getItems();\n  }\n\n  private String getDiscoveredClaim() {\n    return getClaims().isEmpty() ? null : getClaims().iterator().next().getMetadata().getName();\n  }\n\n  private String getClaimName() {\n    return Optional.ofNullable(info.getDomain().getPersistentVolumeClaimName())\n        .orElse(getDiscoveredClaim());\n  }\n\n  // ----------------------- step methods ------------------------------\n\n  /**\n   * Creates the specified new pod and performs any additional needed processing.\n   *\n   * @param next the next step to perform after the pod creation is complete.\n   * @return a step to be scheduled.\n   */\n  abstract Step createNewJob(Step next);\n\n  /**\n   * Creates the specified new job.\n   *\n   * @param next the next step to perform after the job creation is complete.\n   * @return a step to be scheduled.\n   */\n  Step createJob(Step next) {\n    return new CallBuilder().createJobAsync(getNamespace(), getJobModel(), createResponse(next));\n  }\n\n  protected void logJobCreated() {\n    LOGGER.info(getJobCreatedMessageKey(), getJobName());\n  }\n\n  abstract String getJobCreatedMessageKey();\n\n  protected String getNodeManagerHome() {\n    return NODEMGR_HOME;\n  }\n\n  protected String getLogHome() {\n    return getDomain().getLogHome();\n  }\n\n  protected boolean isDomainHomeInImage() {\n    return getDomain().isDomainHomeInImage();\n  }\n\n  String getEffectiveLogHome() {\n    String logHome = getLogHome();\n    if (logHome == null || \"\".equals(logHome.trim())) {\n      // logHome not specified, use default value\n      return DEFAULT_LOG_HOME + File.separator + getDomainUID();\n    }\n    return logHome;\n  }\n\n  String getIncludeServerOutInPodLog() {\n    return getDomain().getIncludeServerOutInPodLog();\n  }\n\n  protected String getIntrospectHome() {\n    return getDomainHome();\n  }\n\n  List<String> getConfigOverrideSecrets() {\n    return getDomain().getConfigOverrideSecrets();\n  }\n\n  String getConfigOverrides() {\n    return getDomain().getConfigOverrides();\n  }\n\n  private ResponseStep<V1Job> createResponse(Step next) {\n    return new CreateResponseStep(next);\n  }\n\n  private class CreateResponseStep extends ResponseStep<V1Job> {\n    CreateResponseStep(Step next) {\n      super(next);\n    }\n\n    @Override\n    public NextAction onFailure(Packet packet, CallResponse<V1Job> callResponse) {\n      return super.onFailure(packet, callResponse);\n    }\n\n    @Override\n    public NextAction onSuccess(Packet packet, CallResponse<V1Job> callResponse) {\n      logJobCreated();\n      V1Job job = callResponse.getResult();\n      if (job != null) {\n        packet.put(ProcessingConstants.DOMAIN_INTROSPECTOR_JOB, job);\n      }\n      return doNext(packet);\n    }\n  }\n\n  // ---------------------- model methods ------------------------------\n\n  private V1Job createJobModel() {\n    return new V1Job()\n        .metadata(createMetadata())\n        .spec(createJobSpec(TuningParameters.getInstance()));\n  }\n\n  V1ObjectMeta createMetadata() {\n    V1ObjectMeta metadata =\n        new V1ObjectMeta()\n            .name(getJobName())\n            .namespace(getNamespace())\n            .putLabelsItem(LabelConstants.RESOURCE_VERSION_LABEL, VersionConstants.DOMAIN_V1)\n            .putLabelsItem(LabelConstants.DOMAINUID_LABEL, getDomainUID())\n            .putLabelsItem(LabelConstants.DOMAINNAME_LABEL, getDomainName())\n            .putLabelsItem(LabelConstants.CREATEDBYOPERATOR_LABEL, \"true\");\n    return metadata;\n  }\n\n  protected V1JobSpec createJobSpec(TuningParameters tuningParameters) {\n    V1JobSpec jobSpec =\n        new V1JobSpec().backoffLimit(0).template(createPodTemplateSpec(tuningParameters));\n\n    return jobSpec;\n  }\n\n  private V1PodTemplateSpec createPodTemplateSpec(TuningParameters tuningParameters) {\n    V1ObjectMeta metadata = new V1ObjectMeta().name(getJobName());\n    V1PodTemplateSpec podTemplateSpec =\n        new V1PodTemplateSpec().metadata(metadata).spec(createPodSpec(tuningParameters));\n    return podTemplateSpec;\n  }\n\n  private V1PodSpec createPodSpec(TuningParameters tuningParameters) {\n    V1PodSpec podSpec =\n        new V1PodSpec()\n            .activeDeadlineSeconds(60L)\n            .restartPolicy(\"Never\")\n            .addContainersItem(createContainer(tuningParameters))\n            .addVolumesItem(new V1Volume().name(SECRETS_VOLUME).secret(getSecretsVolume()))\n            .addVolumesItem(\n                new V1Volume().name(SCRIPTS_VOLUME).configMap(getConfigMapVolumeSource()));\n\n    podSpec.setImagePullSecrets(info.getDomain().getSpec().getImagePullSecrets());\n\n    if (getClaimName() != null) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(STORAGE_VOLUME)\n              .persistentVolumeClaim(getPersistenVolumeClaimVolumeSource(getClaimName())));\n    }\n\n    List<String> configOverrideSecrets = getConfigOverrideSecrets();\n    for (String secretName : configOverrideSecrets) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(secretName + \"-volume\")\n              .secret(getOverrideSecretVolumeSource(secretName)));\n    }\n    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n      podSpec.addVolumesItem(\n          new V1Volume()\n              .name(getConfigOverrides() + \"-volume\")\n              .configMap(getOverridesVolumeSource(getConfigOverrides())));\n    }\n\n    return podSpec;\n  }\n\n  private V1Container createContainer(TuningParameters tuningParameters) {\n    V1Container container =\n        new V1Container()\n            .name(getJobName())\n            .image(getImageName())\n            .imagePullPolicy(getImagePullPolicy())\n            .command(getContainerCommand())\n            .env(getEnvironmentVariables(tuningParameters))\n            .addVolumeMountsItem(volumeMount(STORAGE_VOLUME, STORAGE_MOUNT_PATH))\n            .addVolumeMountsItem(readOnlyVolumeMount(SECRETS_VOLUME, SECRETS_MOUNT_PATH))\n            .addVolumeMountsItem(readOnlyVolumeMount(SCRIPTS_VOLUME, SCRIPTS_MOUNTS_PATH));\n\n    if (getConfigOverrides() != null && getConfigOverrides().length() > 0) {\n      container.addVolumeMountsItem(\n          readOnlyVolumeMount(getConfigOverrides() + \"-volume\", OVERRIDES_CM_MOUNT_PATH));\n    }\n\n    List<String> configOverrideSecrets = getConfigOverrideSecrets();\n    for (String secretName : configOverrideSecrets) {\n      container.addVolumeMountsItem(\n          readOnlyVolumeMount(secretName + \"-volume\", OVERRIDE_SECRETS_MOUNT_PATH));\n    }\n    return container;\n  }\n\n  String getImageName() {\n    String imageName = getDomain().getSpec().getImage();\n    if (imageName == null) {\n      imageName = KubernetesConstants.DEFAULT_IMAGE;\n    }\n    return imageName;\n  }\n\n  String getImagePullPolicy() {\n    return KubernetesConstants.IFNOTPRESENT_IMAGEPULLPOLICY;\n  }\n\n  protected List<String> getContainerCommand() {\n    return Arrays.asList(WEBLOGIC_OPERATOR_SCRIPTS_INTROSPECT_DOMAIN_SH);\n  }\n\n  abstract List<V1EnvVar> getEnvironmentVariables(TuningParameters tuningParameters);\n\n  protected String getDomainHome() {\n    return \"/shared/domains/\" + getDomainUID();\n  }\n\n  static void addEnvVar(List<V1EnvVar> vars, String name, String value) {\n    vars.add(new V1EnvVar().name(name).value(value));\n  }\n\n  private static V1VolumeMount readOnlyVolumeMount(String volumeName, String mountPath) {\n    return volumeMount(volumeName, mountPath).readOnly(true);\n  }\n\n  private static V1VolumeMount volumeMount(String volumeName, String mountPath) {\n    return new V1VolumeMount().name(volumeName).mountPath(mountPath);\n  }\n\n  protected V1SecretVolumeSource getSecretsVolume() {\n    return new V1SecretVolumeSource().secretName(getAdminSecretName()).defaultMode(420);\n  }\n\n  protected V1ConfigMapVolumeSource getConfigMapVolumeSource() {\n    return new V1ConfigMapVolumeSource()\n        .name(KubernetesConstants.DOMAIN_CONFIG_MAP_NAME)\n        .defaultMode(ALL_READ_AND_EXECUTE);\n  }\n\n  protected V1ConfigMapVolumeSource getConfigMapVolumeSource(String name, int mode) {\n    return new V1ConfigMapVolumeSource().name(name).defaultMode(mode);\n  }\n\n  protected V1PersistentVolumeClaimVolumeSource getPersistenVolumeClaimVolumeSource(\n      String claimName) {\n    return new V1PersistentVolumeClaimVolumeSource().claimName(claimName);\n  }\n\n  protected V1SecretVolumeSource getOverrideSecretVolumeSource(String name) {\n    return new V1SecretVolumeSource().secretName(name).defaultMode(420);\n  }\n\n  protected V1ConfigMapVolumeSource getOverridesVolumeSource(String name) {\n    return new V1ConfigMapVolumeSource().name(name).defaultMode(ALL_READ_AND_EXECUTE);\n  }\n}\n"},
{"Line": "=>36", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if ((IDs.size()) > 0) taskService.deleteTask(IDs);", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/529/buggy-version/app.src.main.java.com.organiser.asyncTasks.TaskDeleter.java", "BodyUseAPI": ["com.organiser.services.TaskService.deleteTask(java.util.ArrayList<java.lang.Integer>)"], "Fixed commit": "d5c7b980be2211d7b5ea22ff494e16bbbf5a9cec", "Url": "https://api.github.com/repos/Patrysiek/OrganiserAndroidClient", "Date": "2018-12-06T16:56:50Z", "Source Code Diff": "@@ -33,6 +33,7 @@ protected Void doInBackground(Void... voids) {\n             }\n         }\n         try {\n+            if(IDs.size()>0)\n             taskService.deleteTask(IDs);\n         } catch (Exception e) {\n             e.printStackTrace();", "Complete After Code": "package com.organiser.asyncTasks;\n\nimport android.os.AsyncTask;\n\nimport com.organiser.asyncTasks.asyncTasksCallbacks.ILoadTasksCallback;\nimport com.organiser.services.TaskService;\nimport com.organiser.task.Task;\nimport com.organiser.taskList.TaskListManager;\n\nimport java.util.ArrayList;\n\npublic class TaskDeleter extends AsyncTask<Void,Void,Void> {\n\n    private TaskListManager taskListManager;\n    private TaskService taskService;\n    private ILoadTasksCallback listener;\n\n\n    public TaskDeleter(TaskService taskService, TaskListManager taskListManager,ILoadTasksCallback listener){\n        this.taskListManager = taskListManager;\n        this.taskService = taskService;\n        this.listener = listener;\n    }\n\n    @Override\n    protected Void doInBackground(Void... voids) {\n        int size = taskListManager.getAllTasksList().size();\n        ArrayList<Integer> IDs = new ArrayList<>();\n        for(int i =0; i<size; i++){\n            Task t = taskListManager.getAllTasksList().get(i);\n            if(t.isChecked()) {\n                IDs.add(t.getID());\n            }\n        }\n        try {\n            if(IDs.size()>0)\n            taskService.deleteTask(IDs);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    @Override\n    protected void onPostExecute(Void aVoid) {\n        listener.loadTasksAfterChange();\n    }\n}\n"},
{"Line": "=>174", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["fex.signs.util.PlayerSign.getAblaufDatum()"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfNull]", "Content": "=>if (date != null) return date; else { throw new fex.signs.util.NoSignFoundException(\"Schild ist nicht aktiv\"); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/601/buggy-version/Signs.src.fex.signs.signs.CommandTransformer.java", "BodyUseAPI": [], "Fixed commit": "34dd09a7396db5220f6e83780600fe51a6f2e223", "Url": "https://api.github.com/repos/fex594/signs", "Date": "2018-11-13T20:26:32Z", "Source Code Diff": "@@ -7,9 +7,11 @@\n import java.util.List;\r\n \r\n import org.bukkit.Bukkit;\r\n+import org.bukkit.ChatColor;\r\n import org.bukkit.entity.Player;\r\n \r\n import fex.signs.util.Messages;\r\n+import fex.signs.util.NoSignFoundException;\r\n import fex.signs.util.PlayerSign;\r\n import fex.signs.util.Util;\r\n \r\n@@ -167,17 +169,26 @@ public boolean commentSign(int ID, String text) {\n \t\treturn x;\r\n \t}\r\n \r\n-\tpublic java.sql.Date getDate(int ID) {\r\n-\t\treturn getSignOutOfList(ID, active).getAblaufDatum();\r\n+\tpublic java.sql.Date getDate(int ID) throws NoSignFoundException {\r\n+\t\tjava.sql.Date date = getSignOutOfList(ID, active).getAblaufDatum();\r\n+\t\tif (date != null)\r\n+\t\t\treturn date;\r\n+\t\telse {\r\n+\t\t\tthrow new NoSignFoundException(\"Schild ist nicht aktiv\");\r\n+\t\t}\r\n \t}\r\n \r\n \tpublic String setDate(int ID, int days, boolean override) {\r\n \t\tPlayerSign p = getSignOutOfList(ID, active);\r\n-\t\tjava.sql.Date d = new java.sql.Date(CommandTransformer.getInstance().getDate(ID).getTime());\r\n+\t\tif (p == null) {\r\n+\t\t\treturn ChatColor.RED + \"Schild ist nicht mehr aktiv\";\r\n+\t\t}\r\n+\t\t// java.sql.Date d = new\r\n+\t\t// java.sql.Date(CommandTransformer.getInstance().getDate(ID).getTime());\r\n \t\tCalendar c = Calendar.getInstance();\r\n \t\tc.setTime(p.getAblaufDatum());\r\n \t\tc.add(Calendar.DAY_OF_MONTH, days);\r\n-\t\td = new java.sql.Date(c.getTimeInMillis());\r\n+\t\tjava.sql.Date d = new java.sql.Date(c.getTimeInMillis());\r\n \r\n \t\tboolean finished = false;\r\n \t\tif (d.before(p.getMaxExpandDate()) || override) {\r", "Complete After Code": "package fex.signs.signs;\r\n\r\nimport java.sql.Date;\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.List;\r\n\r\nimport org.bukkit.Bukkit;\r\nimport org.bukkit.ChatColor;\r\nimport org.bukkit.entity.Player;\r\n\r\nimport fex.signs.util.Messages;\r\nimport fex.signs.util.NoSignFoundException;\r\nimport fex.signs.util.PlayerSign;\r\nimport fex.signs.util.Util;\r\n\r\npublic class CommandTransformer {\r\n\r\n\tprivate List<PlayerSign> active;\r\n\tprivate List<PlayerSign> abgelaufen;\r\n\tprivate List<PlayerSign> inactive;\r\n\tprivate int maxID;\r\n\tprivate Messages mess = Messages.getInstance();\r\n\tprivate static CommandTransformer instance;\r\n\r\n\tprivate CommandTransformer() {\r\n\t\tupdate();\r\n\t}\r\n\r\n\tpublic static CommandTransformer getInstance() {\r\n\t\tif (instance == null) {\r\n\t\t\tinstance = new CommandTransformer();\r\n\t\t}\r\n\t\treturn CommandTransformer.instance;\r\n\t}\r\n\r\n\tpublic List<PlayerSign> getActive(String name) {\r\n\t\tif (name == null) {\r\n\t\t\treturn active;\r\n\t\t} else {\r\n\t\t\tList<PlayerSign> pActive = new ArrayList<PlayerSign>();\r\n\t\t\tfor (PlayerSign ps : active) {\r\n\t\t\t\tif (ps.getBesitzerUUID().equals(name)) {\r\n\t\t\t\t\tpActive.add(ps);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn pActive;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Wenn Name null: Alle Schilder, sonst nur von Name\r\n\t * \r\n\t * @param name\r\n\t *            UUID des Spielers\r\n\t * @return Liste mit allen abgelaufenen Schildern (eines Spielers)\r\n\t */\r\n\tpublic List<PlayerSign> getAbgelaufen(String name) {\r\n\t\tif (name == null) {\r\n\t\t\treturn abgelaufen;\r\n\t\t} else {\r\n\t\t\tList<PlayerSign> pAbgelaufen = new ArrayList<PlayerSign>();\r\n\t\t\tfor (PlayerSign ps : abgelaufen) {\r\n\t\t\t\tif (ps.getBesitzerUUID().equals(name)) {\r\n\t\t\t\t\tpAbgelaufen.add(ps);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn pAbgelaufen;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic List<PlayerSign> getInactive(String name) {\r\n\t\tif (name == null) {\r\n\t\t\treturn inactive;\r\n\t\t} else {\r\n\t\t\tList<PlayerSign> pInactive = new ArrayList<PlayerSign>();\r\n\t\t\tfor (PlayerSign ps : inactive) {\r\n\t\t\t\tif (ps.getBesitzerUUID().equals(name)) {\r\n\t\t\t\t\tpInactive.add(ps);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn pInactive;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Infos \u00fcber aktives Schild, Kennung \u00fcber ID\r\n\t * \r\n\t * @param ID\r\n\t *            ID\r\n\t */\r\n\tpublic void getInfo(int ID, Player p) {\r\n\t\tif (ID > maxID) {\r\n\t\t\tmess.toPlayer(p, \"Kein Schild mit der Nummer \" + ID + \" vorhanden!\", Messages.IMPORTANT);\r\n\t\t} else {\r\n\t\t\tPlayerSign ps = null;\r\n\t\t\tfor (PlayerSign pa : active) {\r\n\t\t\t\tif (pa.getID() == ID) {\r\n\t\t\t\t\tps = pa;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ps == null) {\r\n\t\t\t\tps = SQLHandler.getInstance().sendResultStatements(\"SELECT * FROM Schilder WHERE ID = \" + ID).get(0);\r\n\t\t\t}\r\n\t\t\tmess.toPlayer(p, ps.toString(), Messages.NORMAL);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic boolean isActive(int ID) {\r\n\t\tfor (PlayerSign ps : active) {\r\n\t\t\tif (ps.getID() == ID) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic boolean setInaktiv(int ID) {\r\n\t\tString args = \"UPDATE Schilder SET Active=0 WHERE ID=\" + ID;\r\n\t\tboolean result = SQLHandler.getInstance().sendStatement(args);\r\n\t\tupdate();\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tpublic void update() {\r\n\t\tBukkit.getScheduler().runTaskAsynchronously(Main.getProvidingPlugin(getClass()), new Runnable() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t\t\t// for(Player p : Bukkit.getServer().getOnlinePlayers()) {\r\n\t\t\t\t// p.sendMessage(\"Update Gestartet\");\r\n\t\t\t\t// }\r\n\t\t\t\t// System.out.println(\"Update gestartet\");\r\n\t\t\t\ttry {\r\n\t\t\t\t\tSQLHandler handle = SQLHandler.getInstance();\r\n\t\t\t\t\tactive = handle.update(); // Update aktive Schilder\r\n\t\t\t\t\tabgelaufen = new ArrayList<PlayerSign>();\r\n\t\t\t\t\tfor (PlayerSign ps : active) // Update abgelaufene Schilder\r\n\t\t\t\t\t\tif (ps.getAblaufDatum().before(Util.now())) {\r\n\t\t\t\t\t\t\tabgelaufen.add(ps);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaxID = handle.getMaxID(); // Update MaxID\r\n\r\n\t\t\t\t\tinactive = handle.getInactiveSigns();\r\n\r\n\t\t\t\t} catch (SQLException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t\t// for(Player p : Bukkit.getServer().getOnlinePlayers()) {\r\n\t\t\t\t// p.sendMessage(\"Update Beendet\");\r\n\t\t\t\t// }\r\n\t\t\t\t// System.out.println(\"Update beendet\");\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tpublic boolean commentSign(int ID, String text) {\r\n\r\n\t\tString output = \"UPDATE Schilder SET Text = '\" + text + \"' WHERE ID = \" + ID;\r\n\t\tboolean x = SQLHandler.getInstance().sendStatement(output);\r\n\t\tupdate();\r\n\t\treturn x;\r\n\t}\r\n\r\n\tpublic java.sql.Date getDate(int ID) throws NoSignFoundException {\r\n\t\tjava.sql.Date date = getSignOutOfList(ID, active).getAblaufDatum();\r\n\t\tif (date != null)\r\n\t\t\treturn date;\r\n\t\telse {\r\n\t\t\tthrow new NoSignFoundException(\"Schild ist nicht aktiv\");\r\n\t\t}\r\n\t}\r\n\r\n\tpublic String setDate(int ID, int days, boolean override) {\r\n\t\tPlayerSign p = getSignOutOfList(ID, active);\r\n\t\tif (p == null) {\r\n\t\t\treturn ChatColor.RED + \"Schild ist nicht mehr aktiv\";\r\n\t\t}\r\n\t\t// java.sql.Date d = new\r\n\t\t// java.sql.Date(CommandTransformer.getInstance().getDate(ID).getTime());\r\n\t\tCalendar c = Calendar.getInstance();\r\n\t\tc.setTime(p.getAblaufDatum());\r\n\t\tc.add(Calendar.DAY_OF_MONTH, days);\r\n\t\tjava.sql.Date d = new java.sql.Date(c.getTimeInMillis());\r\n\r\n\t\tboolean finished = false;\r\n\t\tif (d.before(p.getMaxExpandDate()) || override) {\r\n\t\t\tp.setAblaufDatum(d);\r\n\t\t\tfinished = true;\r\n\r\n\t\t} else {\r\n\t\t\tp.setAblaufDatum(p.getMaxExpandDate());\r\n\t\t}\r\n\t\tString args = \"UPDATE Schilder SET Datum = '\" + p.getAblaufDatum() + \"' WHERE ID=\" + ID;\r\n\t\tSQLHandler.getInstance().sendStatement(args);\r\n\t\tupdate();\r\n\t\tif (finished) {\r\n\t\t\treturn \"Schild erfolgreich um \" + days + \" Tage verl\u00e4ngert\";\r\n\t\t} else {\r\n\t\t\treturn \"Maximale Verl\u00e4ngerungszeit erreicht!\";\r\n\t\t}\r\n\t}\r\n\r\n\tpublic int getMaxID() {\r\n\t\treturn this.maxID;\r\n\t}\r\n\r\n\tpublic String getLocation(int ID) {\r\n\t\tString s = null;\r\n\t\tfor (PlayerSign ps : active) {\r\n\t\t\tif (ps.getID() == ID) {\r\n\t\t\t\ts = ps.getLocation();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\tpublic PlayerSign getSignOutOfList(int ID, List<PlayerSign> list) {\r\n\t\tPlayerSign p = null;\r\n\t\tfor (PlayerSign ps : list) {\r\n\t\t\tif (ps.getID() == ID) {\r\n\t\t\t\tp = ps;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/**\r\n\t * Legt eine neues Schild in der Datenbank an\r\n\t * \r\n\t * @param name\r\n\t *            Spielername\r\n\t * @param date\r\n\t *            Ablaufdatum\r\n\t * @param active\r\n\t *            Aktivit\u00e4t: 1 - Aktiv, 0 - Inaktiv\r\n\t * @param loc\r\n\t *            Schildposition\r\n\t * @param text\r\n\t *            Beschreibung zum Schild\r\n\t * @param typ\r\n\t *            Schild-Typ\r\n\t * @return ID des Schilds\r\n\t */\r\n\tpublic int putNewSign(String name, Date date, int active, String loc, String typ, String ersteller, Date lastDate) {\r\n\t\tString type = typ.replace(\"[\", \"\").replace(\"]\", \"\");\r\n\t\tString st = \"INSERT INTO Schilder (Player, Active, Loc, Datum, Typ, Ersteller, Lastdate) VALUES ('\" + name\r\n\t\t\t\t+ \"', \" + active + \", '\" + loc + \"', '\" + date + \"', '\" + type + \"', '\" + ersteller + \"', '\" + lastDate\r\n\t\t\t\t+ \"')\";\r\n\t\tSQLHandler.getInstance().sendStatement(st);\r\n\t\tupdate();\r\n\t\treturn maxID;\r\n\t}\r\n\r\n\t/**\r\n\t * Not yet implementet\r\n\t * \r\n\t * @param s\r\n\t * @return\r\n\t */\r\n\tpublic List<String> deleteAllSigns(String s) {\r\n\t\tList<String> list = new ArrayList<String>();\r\n\t\tList<PlayerSign> delete = new ArrayList<PlayerSign>();\r\n\t\tfor (PlayerSign ps : active) {\r\n\t\t\tif (ps.getBesitzerUUID().equals(s)) {\r\n\t\t\t\tlist.add(ps.getLocation());\r\n\t\t\t\tdelete.add(ps);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (PlayerSign ps : delete) {\r\n\t\t\tif (ps.getBesitzerUUID().equals(s)) {\r\n\t\t\t\tactive.remove(ps);\r\n\t\t\t\tabgelaufen.remove(ps);\r\n\t\t\t}\r\n\t\t}\r\n\t\tSQLHandler.getInstance().sendStatement(\"UPDATE Schilder SET Active = 0 WHERE Player = '\" + s + \"'\");\r\n\t\treturn list;\r\n\t}\r\n}\r\n"},
{"Line": "=>390", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (guild.getUsers().contains(user)) { user.removeRole(muteRole); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/968/buggy-version/src.main.java.de.nikos410.discordBot.modules.ModStuff.java", "BodyUseAPI": ["de.nikos410.discordBot.modules.IUser.removeRole(de.nikos410.discordBot.modules.IRole)"], "Fixed commit": "7b3b122c0ae918fce6e1d6650d0f30d1ec534fea", "Url": "https://api.github.com/repos/DACH-Discord/de-DiscordBot", "Date": "2018-11-13T11:47:46Z", "Source Code Diff": "@@ -386,7 +386,10 @@ private String muteUserForGuild(final IUser user, final IGuild guild, final int\n \n         // Wird ausgef\u00fchrt, um Nutzer wieder zu entmuten\n         final Runnable unmuteTask = () -> {\n-            user.removeRole(muteRole);\n+            // Only remove the mute role if th user is still a member of the guild\n+            if (guild.getUsers().contains(user)) {\n+                user.removeRole(muteRole);\n+            }\n             userMuteFutures.get(guild).remove(user);\n \n             LOG.info(String.format(\"Nutzer %s wurde entmuted.\", UserUtils.makeUserString(user, guild)));", "Complete After Code": "package de.nikos410.discordBot.modules;\n\nimport de.nikos410.discordBot.DiscordBot;\nimport de.nikos410.discordBot.framework.PermissionLevel;\nimport de.nikos410.discordBot.framework.annotations.CommandModule;\nimport de.nikos410.discordBot.framework.annotations.CommandSubscriber;\nimport de.nikos410.discordBot.util.discord.DiscordIO;\nimport de.nikos410.discordBot.util.discord.GuildUtils;\nimport de.nikos410.discordBot.util.discord.UserUtils;\nimport de.nikos410.discordBot.util.io.IOUtil;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport sx.blah.discord.api.IDiscordClient;\nimport sx.blah.discord.api.events.EventSubscriber;\nimport sx.blah.discord.handle.impl.events.ReadyEvent;\nimport sx.blah.discord.handle.impl.events.guild.member.UserBanEvent;\nimport sx.blah.discord.handle.impl.events.guild.member.UserJoinEvent;\nimport sx.blah.discord.handle.impl.events.guild.voice.user.UserVoiceChannelJoinEvent;\nimport sx.blah.discord.handle.impl.events.guild.voice.user.UserVoiceChannelLeaveEvent;\nimport sx.blah.discord.handle.impl.events.guild.voice.user.UserVoiceChannelMoveEvent;\nimport sx.blah.discord.handle.impl.obj.ReactionEmoji;\nimport sx.blah.discord.handle.obj.*;\nimport sx.blah.discord.util.EmbedBuilder;\nimport sx.blah.discord.util.cache.LongMap;\n\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.temporal.ChronoUnit;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n@CommandModule(moduleName = \"Modzeugs\", commandOnly = false)\npublic class ModStuff {\n    private final DiscordBot bot;\n\n    private final static Path MODSTUFF_PATH = Paths.get(\"data/modstuff.json\");\n    private final JSONObject modstuffJSON;\n\n    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n\n\n    private final Map<IGuild, Map<IUser, ScheduledFuture>> userMuteFutures = new HashMap<>();\n    private final Map<IGuild, Map<IChannel, Map<IUser, ScheduledFuture>>> channelMuteFutures = new HashMap<>();\n\n    private final Map<IGuild, List<String>> voiceLog = new HashMap<>();\n\n    private final static Logger LOG = LoggerFactory.getLogger(ModStuff.class);\n\n    public ModStuff (final DiscordBot bot) {\n        this.bot = bot;\n        final IDiscordClient client = bot.client;\n\n        final String rolesFileContent = IOUtil.readFile(MODSTUFF_PATH);\n        if (rolesFileContent == null) {\n            LOG.error(\"Could not read modstuff file.\");\n            System.exit(1);\n        }\n        this.modstuffJSON = new JSONObject(rolesFileContent);\n        LOG.info(String.format(\"Loaded modstuff file for %s guilds.\", modstuffJSON.keySet().size()));\n    }\n\n    @CommandSubscriber(command = \"kick\", help = \"Kickt den angegebenen Nutzer mit der angegeben Nachricht vom Server\",\n            pmAllowed = false)\n    public void command_Kick(final IMessage message, final String kickUserString, String customMessage) {\n        if (this.bot.getUserPermissionLevel(message.getAuthor(), message.getGuild()).getLevel() >=\n                PermissionLevel.MODERATOR.getLevel()) {\n\n            final List<IUser> mentions = message.getMentions();\n            if (mentions.size() <1) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Kein Nutzer angegeben!\");\n                return;\n            }\n            else if (mentions.size() > 1) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: In der Nachricht keine Nutzer erw\u00e4hnen!\");\n                return;\n            }\n\n            final IUser kickUser = mentions.get(0);\n            if (kickUser == null) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Nutzer nicht gefunden!\");\n                return;\n            }\n\n            if (customMessage.isEmpty()) {\n                customMessage = \"kein\";\n            }\n\n            final String kickMessage = String.format(\"**Du wurdest gekickt!** (Du kannst dem Server jedoch erneut beitreten.) \\nHinweis: _%s_\",\n                    customMessage);\n\n\n            DiscordIO.sendMessage(kickUser.getOrCreatePMChannel(), kickMessage);\n            message.getGuild().kickUser(kickUser, customMessage);\n\n            message.addReaction(ReactionEmoji.of(\"\\uD83D\\uDEAA\")); // :door:\n            //Util.sendMessage(message.getChannel(), \":door:\");\n\n            // Modlog\n            LOG.info(String.format(\"%s hat Nutzer %s vom Server gekickt. Hinweis: %s\",\n                    UserUtils.makeUserString(message.getAuthor(), message.getGuild()),\n                    UserUtils.makeUserString(kickUser, message.getGuild()),\n                    customMessage));\n\n            final IGuild guild = message.getGuild();\n            final IChannel modLogChannel = getModlogChannelForGuild(guild);\n\n            if (modLogChannel != null) {\n                final String modLogMessage = String.format(\"**%s** hat Nutzer **%s** im Kanal %s vom Server **gekickt**. \\nHinweis: _%s _\",\n                        UserUtils.makeUserString(message.getAuthor(), guild),\n                        UserUtils.makeUserString(kickUser, guild),\n                        message.getChannel().mention(),\n                        customMessage);\n                DiscordIO.sendMessage(modLogChannel, modLogMessage);\n            }\n        }\n        else {\n            message.getGuild().kickUser(message.getAuthor());\n            message.addReaction(ReactionEmoji.of(\"tja\", 401835325434888192L));\n        }\n    }\n\n    @CommandSubscriber(command = \"ban\", help = \"Bannt den angegebenen Nutzer mit der angegeben Nachricht vom Server\",\n            pmAllowed = false)\n    public void command_Ban(final IMessage message, final String banUserString, String customMessage) {\n        if (this.bot.getUserPermissionLevel(message.getAuthor(), message.getGuild()).getLevel() >=\n                PermissionLevel.MODERATOR.getLevel()) {\n\n            final List<IUser> mentions = message.getMentions();\n            if (mentions.size() <1) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Kein Nutzer angegeben!\");\n            }\n            else if (mentions.size() > 1) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: In der Nachricht keine Nutzer erw\u00e4hnen!\");\n            }\n\n            final IUser banUser = mentions.get(0);\n            if (banUser == null) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Nutzer nicht gefunden!\");\n                return;\n            }\n\n            if (customMessage.isEmpty()) {\n                customMessage = \"kein\";\n            }\n\n            final String banMessage = String.format(\"**Du wurdest gebannt!** \\nHinweis: _%s_\", customMessage);\n\n            DiscordIO.sendMessage(banUser.getOrCreatePMChannel(), banMessage);\n            message.getGuild().banUser(banUser, customMessage, 0);\n\n            //Util.sendMessage(message.getChannel(), \":hammer:\");\n            message.addReaction(ReactionEmoji.of(\"\\uD83D\\uDD28\")); // :hammer:\n\n            // Modlog\n            LOG.info(String.format(\"%s hat Nutzer %s vom Server gebannt. Hinweis: %s\",\n                    UserUtils.makeUserString(message.getAuthor(), message.getGuild()),\n                    UserUtils.makeUserString(banUser, message.getGuild()),\n                    customMessage));\n\n            final IGuild guild = message.getGuild();\n            final IChannel modLogChannel = getModlogChannelForGuild(guild);\n\n            if (modLogChannel != null) {\n                final String modLogMessage = String.format(\"**%s** hat Nutzer **%s** im Kanal %s vom Server **gebannt**. \\nHinweis: _%s _\",\n                        UserUtils.makeUserString(message.getAuthor(), guild),\n                        UserUtils.makeUserString(banUser, guild),\n                        message.getChannel().mention(),\n                        customMessage);\n                DiscordIO.sendMessage(modLogChannel, modLogMessage);\n            }\n        }\n        else {\n            message.getGuild().kickUser(message.getAuthor(), customMessage);\n            message.addReaction(ReactionEmoji.of(\"tja\", 401835325434888192L));\n        }\n    }\n\n    @EventSubscriber\n    public void onUserBanned (final UserBanEvent event) {\n        final IGuild guild = event.getGuild();\n        final IChannel modLogChannel = getModlogChannelForGuild(guild);\n\n        if (modLogChannel != null) {\n            final String modLogMessage = String.format(\"**%s** wurde vom Server **gebannt**.\",\n                    UserUtils.makeUserString(event.getUser(), event.getGuild()));\n            DiscordIO.sendMessage(modLogChannel, modLogMessage);\n        }\n    }\n\n    @CommandSubscriber(command = \"mute\", help = \"Einen Nutzer f\u00fcr eine bestimmte Zeit muten\", pmAllowed = false,\n            permissionLevel = PermissionLevel.MODERATOR)\n    public void command_Mute(final IMessage message, final String muteUserString, final String muteDurationInput) {\n        // Nutzer der gemuted werden soll auslesen\n        final List<IUser> mentions = message.getMentions();\n        if (mentions.size() < 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Kein Nutzer angegeben!\");\n            return;\n        }\n        else if (mentions.size() > 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: mehrere Nutzer erw\u00e4hnt\");\n            return;\n        }\n\n        final IUser muteUser = mentions.get(0);\n        if (muteUser == null) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Nutzer nicht gefunden!\");\n            return;\n        }\n\n        // Mute Dauer auslesen\n        final Pattern pattern = Pattern.compile(\"(\\\\d+)\\\\s*([smhd])\\\\s*(.*)\");\n        final Matcher matcher = pattern.matcher(muteDurationInput);\n\n        if (!matcher.matches()) {\n            DiscordIO.sendMessage(message.getChannel(), \"Ung\u00fcltige Eingabe! M\u00f6gliche Zeitformate sind s, m, h und d.\");\n            return;\n        }\n\n        final int muteDuration = Integer.parseInt(matcher.group(1));\n        final String muteDurationUnitString = matcher.group(2);\n        ChronoUnit muteDurationUnit = parseChronoUnit(muteDurationUnitString);\n\n        final IGuild guild = message.getGuild();\n\n        // Nutzer muten und unmuten schedulen\n        // Es wird nur ein String returned wenn der mute nicht erfolgt ist\n        final String output = muteUserForGuild(muteUser, guild, muteDuration, muteDurationUnit);\n        if (output.isEmpty()) {\n            message.addReaction(ReactionEmoji.of(\"\\uD83D\\uDD07\")); // :mute:\n        }\n        else {\n            DiscordIO.sendMessage(message.getChannel(), output);\n            return;\n        }\n\n        // Hinweis auslesen\n        String customMessage = matcher.group(3);\n\n        if (customMessage.isEmpty()) {\n            customMessage = \"kein\";\n        }\n\n        final String muteMessage = String.format(\"**Du wurdest f\u00fcr %s %s gemuted!** \\nHinweis: _%s_\",\n                muteDuration, muteDurationUnitString, customMessage);\n\n        // Einen Bot nicht benachrichtigen\n        if (!muteUser.isBot()) {\n            DiscordIO.sendMessage(muteUser.getOrCreatePMChannel(), muteMessage);\n        }\n\n        // Modlog\n        LOG.info(String.format(\"Nutzer %s wurde f\u00fcr %s gemuted.\", UserUtils.makeUserString(muteUser, message.getGuild()), muteDurationInput));\n\n        final IChannel modLogChannel = getModlogChannelForGuild(guild);\n\n        if (modLogChannel != null) {\n            final String modLogMessage = String.format(\"**%s** hat Nutzer **%s** im Kanal %s f\u00fcr %s %s **gemuted**. \\nHinweis: _%s _\",\n                    UserUtils.makeUserString(message.getAuthor(), message.getGuild()),\n                    UserUtils.makeUserString(muteUser, message.getGuild()), message.getChannel().mention(),\n                    muteDuration, muteDurationUnitString, customMessage);\n            DiscordIO.sendMessage(modLogChannel, modLogMessage);\n        }\n\n        saveMutedUsers();\n    }\n\n    @CommandSubscriber(command = \"selfmute\", help = \"Schalte dich selber f\u00fcr die angegebene Zeit stumm\", pmAllowed = false)\n    public void command_Selfmute(final IMessage message, final String muteDurationInput) {\n        // Autor der Nachricht soll gemuted werden\n        final IUser muteUser = message.getAuthor();\n\n        // Mute Dauer auslesen\n        final Pattern pattern = Pattern.compile(\"(\\\\d+)\\\\s*([smhd])\\\\s*(.*)\");\n        final Matcher matcher = pattern.matcher(muteDurationInput);\n\n        if (!matcher.matches()) {\n            DiscordIO.sendMessage(message.getChannel(), \"Ung\u00fcltige Eingabe! M\u00f6gliche Zeitformate sind s, m, h und d.\");\n            return;\n        }\n\n        final int muteDuration = Integer.parseInt(matcher.group(1));\n        final String muteDurationUnitString = matcher.group(2);\n        ChronoUnit muteDurationUnit = parseChronoUnit(muteDurationUnitString);\n\n        // Nutzer k\u00f6nnen sich f\u00fcr maximal einen Tag selber muten\n        final LocalDateTime muteEnd = LocalDateTime.now().plus(muteDuration, muteDurationUnit);\n        if (muteEnd.isAfter(LocalDateTime.now().plusDays(1))) {\n            // L\u00e4nger als 1 Tag\n            DiscordIO.sendMessage(message.getChannel(), \"Du kannst dich f\u00fcr maximal einen Tag muten!\");\n            return;\n        }\n\n        final IGuild guild = message.getGuild();\n\n        // Nutzer muten und unmuten schedulen\n        // Es wird nur ein String returned wenn der mute nicht erfolgt ist\n        final String output = muteUserForGuild(muteUser, guild, muteDuration, muteDurationUnit);\n        if (output.isEmpty()) {\n            message.addReaction(ReactionEmoji.of(\"\\uD83D\\uDD07\")); // :mute:\n        }\n        else {\n            DiscordIO.sendMessage(message.getChannel(), output);\n        }\n\n        saveMutedUsers();\n    }\n\n    @CommandSubscriber(command = \"unmute\", help = \"Nutzer entmuten\", pmAllowed = false,\n            permissionLevel = PermissionLevel.MODERATOR)\n    public void command_Unmute(final IMessage message) {\n        final List<IUser> mentions = message.getMentions();\n        if (mentions.size() <1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Kein Nutzer angegeben!\");\n            return;\n        }\n        else if (mentions.size() > 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: mehrere Nutzer erw\u00e4hnt\");\n            return;\n        }\n\n        final IUser muteUser = mentions.get(0);\n        final IRole muteRole = getMuteRoleForGuild(message.getGuild());\n\n        if (muteRole == null) {\n            DiscordIO.sendMessage(message.getChannel(), \"Keine g\u00fcltige Mute Rolle konfiguriert!\");\n            return;\n        }\n\n        muteUser.removeRole(muteRole);\n\n        if (userMuteFutures.containsKey(message.getGuild()) &&\n                userMuteFutures.get(message.getGuild()).containsKey(muteUser)) {\n            ScheduledFuture future = userMuteFutures.get(message.getGuild()).remove(muteUser);\n            future.cancel(false);\n        }\n\n        message.addReaction(ReactionEmoji.of(\"\u2705\")); // :white_check_mark:\n    }\n\n    private String muteUserForGuild(final IUser user, final IGuild guild, final int muteDuration, final ChronoUnit muteDurationUnit) {\n        // Mute Rolle f\u00fcr diesen Server auslesen\n        final IRole muteRole = getMuteRoleForGuild(guild);\n        if (muteRole == null) {\n            return \"Keine g\u00fcltige Mute Rolle konfiguriert!\";\n        }\n\n        // Pr\u00fcfen ob Nutzer bereits gemuted ist\n        if (isUserMutedForGuild(user, guild)) {\n            // Nutzer ist bereits gemuted\n            // \u00dcberpr\u00fcfen, ob angegebener Zeitpunkt nach dem bisherigen Zeitpunkt liegt\n            final ScheduledFuture oldFuture = userMuteFutures.get(guild).get(user);\n\n            // Unmute Zeitpunkte in LocalDateTime\n            final LocalDateTime oldDateTime = LocalDateTime.now().plusSeconds(oldFuture.getDelay(TimeUnit.SECONDS));\n            final LocalDateTime newDateTime = LocalDateTime.now().plus(muteDuration, muteDurationUnit);\n\n            // Pr\u00fcfen welcher Unmute Zeitpunkt zuerst eintritt\n            if (newDateTime.isBefore(oldDateTime)) {\n                // neuer Zeitpunkt ist vor altem -> nichts tun (l\u00e4ngerer Mute bleibt bestehen)\n                return \"Nutzer ist bereits f\u00fcr einen l\u00e4ngeren Zeitraum gemuted!\";\n            }\n            else {\n                // neuer Zeitpunkt ist nach altem -> neu schedulen\n                userMuteFutures.get(guild).remove(user, oldFuture);\n                oldFuture.cancel(false);\n            }\n        }\n        else {\n            // Nutzer ist noch nicht gemuted\n            user.addRole(muteRole);\n            LOG.info(String.format(\"Muted user %s.\", UserUtils.makeUserString(user, guild)));\n        }\n\n        // Wird ausgef\u00fchrt, um Nutzer wieder zu entmuten\n        final Runnable unmuteTask = () -> {\n            // Only remove the mute role if th user is still a member of the guild\n            if (guild.getUsers().contains(user)) {\n                user.removeRole(muteRole);\n            }\n            userMuteFutures.get(guild).remove(user);\n\n            LOG.info(String.format(\"Nutzer %s wurde entmuted.\", UserUtils.makeUserString(user, guild)));\n            saveMutedUsers();\n        };\n\n        // Unmute schedulen\n        final ScheduledFuture newFuture = scheduler.schedule(unmuteTask, muteDuration, chronoUnitToTimeUnit(muteDurationUnit));\n\n        if (userMuteFutures.containsKey(guild)) {\n            userMuteFutures.get(guild).put(user, newFuture);\n        }\n        else {\n            final Map<IUser, ScheduledFuture> guildMap = new HashMap<>();\n            guildMap.put(user, newFuture);\n            userMuteFutures.put(guild, guildMap);\n        }\n\n        return \"\";\n    }\n\n    private boolean isUserMutedForGuild (final IUser user, final IGuild guild) {\n        return (userMuteFutures.containsKey(guild) && userMuteFutures.get(guild).containsKey(user));\n    }\n\n    @CommandSubscriber(command = \"channelMute\", help = \"Nutzer in einem Channel f\u00fcr eine bestimmte Zeit stummschalten\", pmAllowed = false, permissionLevel = PermissionLevel.MODERATOR)\n    public void command_channelMute(final IMessage message, final String user, final String channelOrMuteDurationInput, final String muteDurationInput) {\n        // Nutzer auslesen\n        final List<IUser> userMentions = message.getMentions();\n        if (userMentions.size() < 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Kein Nutzer angegeben!\");\n            return;\n        }\n        else if (userMentions.size() > 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: mehrere Nutzer erw\u00e4hnt\");\n            return;\n        }\n\n        final IUser muteUser = userMentions.get(0);\n        if (muteUser == null) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: Nutzer nicht gefunden!\");\n            return;\n        }\n\n        // Kanal auslesen\n        final List<IChannel> channelMentions = message.getChannelMentions();\n        final IChannel muteChannel;\n\n        if (channelMentions.size() > 1) {\n            DiscordIO.sendMessage(message.getChannel(), \":x: Fehler: mehrere Kan\u00e4le erw\u00e4hnt\");\n            return;\n        }\n        else if (channelMentions.size() < 1) {\n            // Kein Kanal erw\u00e4hnt -> Kanal der Nachricht verwenden\n            muteChannel = message.getChannel();\n        }\n        else {\n            // Kanal erw\u00e4hnt -> diesen verwenden\n            muteChannel = channelMentions.get(0);\n        }\n\n        // Mute Dauer auslesen\n        final Pattern pattern = Pattern.compile(\"(\\\\d+)\\\\s*([smhd])\\\\s*(.*)\");\n\n        final Matcher matcher;\n        if (channelMentions.size() < 1) {\n            matcher = pattern.matcher(channelOrMuteDurationInput);\n        }\n        else {\n            matcher = pattern.matcher(muteDurationInput);\n        }\n\n        if (!matcher.matches()) {\n            DiscordIO.sendMessage(message.getChannel(), \"Ung\u00fcltige Eingabe! M\u00f6gliche Zeitformate sind s, m, h und d.\");\n            return;\n        }\n\n        final int muteDuration = Integer.parseInt(matcher.group(1));\n        final String muteDurationUnitString = matcher.group(2);\n        ChronoUnit muteDurationUnit = parseChronoUnit(muteDurationUnitString);\n\n        // Nutzer muten und unmuten schedulen\n        // Es wird nur ein String returned wenn der mute nicht erfolgt ist\n        final String output = muteUserForChannel(muteUser, muteChannel, muteDuration, muteDurationUnit);\n        if (output.isEmpty()) {\n            message.addReaction(ReactionEmoji.of(\"\\uD83D\\uDD07\")); // :mute:\n        }\n        else {\n            DiscordIO.sendMessage(message.getChannel(), output);\n            return;\n        }\n\n        // Hinweis auslesen\n        String customMessage = matcher.group(3);\n\n        if (customMessage.isEmpty()) {\n            customMessage = \"kein\";\n        }\n\n        final IGuild guild = message.getGuild();\n\n        final String muteMessage = String.format(\"**Du wurdest f\u00fcr %s %s f\u00fcr den Kanal %s auf dem Server %s gemuted!** \\nHinweis: _%s_\",\n                muteDuration, muteDurationUnitString, muteChannel.getName(), guild.getName(), customMessage);\n\n        // Einen Bot nicht benachrichtigen\n        if (!muteUser.isBot()) {\n            DiscordIO.sendMessage(muteUser.getOrCreatePMChannel(), muteMessage);\n        }\n\n        // Modlog\n        LOG.info(String.format(\"Nutzer %s wurde f\u00fcr %s %s f\u00fcr den Kanal %s auf dem Server %s gemuted. \\nHinweis: %s\",\n                UserUtils.makeUserString(muteUser, guild), muteDuration, muteDurationUnitString,\n                muteChannel.getName(), guild.getName(), customMessage));\n\n        final IChannel modLogChannel = getModlogChannelForGuild(guild);\n\n        if (modLogChannel != null) {\n            final String modLogMessage = String.format(\"**%s** hat Nutzer **%s** im Kanal %s f\u00fcr %s %s f\u00fcr den Kanal %s **gemuted**. \\nHinweis: _%s _\",\n                    UserUtils.makeUserString(message.getAuthor(), message.getGuild()),\n                    UserUtils.makeUserString(muteUser, message.getGuild()), message.getChannel().mention(),\n                    muteDuration, muteDurationUnitString, muteChannel.mention(), customMessage);\n            DiscordIO.sendMessage(modLogChannel, modLogMessage);\n        }\n    }\n\n    private String muteUserForChannel (final IUser user, final IChannel channel, final int muteDuration, final ChronoUnit muteDurationUnit) {\n        final LongMap<PermissionOverride> oldOverrides = channel.getUserOverrides();\n\n        // Pr\u00fcfen ob bereits Overrides f\u00fcr den Nutzer existieren\n        if (oldOverrides.containsKey(user.getLongID())) {\n            // Bisherige Overrides f\u00fcr den Nutzer auslesen\n            final PermissionOverride oldUserOverrides = oldOverrides.get(user.getLongID());\n\n            // Bisherige Overrides f\u00fcr den Nutzer kopieren\n            final EnumSet<Permissions> userAllow = oldUserOverrides.allow().clone();\n            final EnumSet<Permissions> userDeny = oldUserOverrides.deny().clone();\n\n            // Rechte zum Senden entfernen\n            userAllow.remove(Permissions.SEND_MESSAGES);\n            userDeny.add(Permissions.SEND_MESSAGES);\n\n            // Rechte aktualisieren\n            channel.overrideUserPermissions(user, userAllow, userDeny);\n        }\n        else {\n            // Rechte zum Senden entfernen\n            channel.overrideUserPermissions(user, EnumSet.noneOf(Permissions.class), EnumSet.of(Permissions.SEND_MESSAGES));\n        }\n\n        final IGuild guild = channel.getGuild();\n\n        // Pr\u00fcfen ob Nutzer bereits gemuted ist\n        if (isUserMutedForChannel(user, channel)) {\n            // Nutzer ist bereits gemuted\n            // \u00dcberpr\u00fcfen, ob angegebener Zeitpunkt nach dem bisherigen Zeitpunkt liegt\n            final ScheduledFuture oldFuture = channelMuteFutures.get(guild).get(channel).get(user);\n\n            // Unmute Zeitpunkte in LocalDateTime\n            final LocalDateTime oldDateTime = LocalDateTime.now().plusSeconds(oldFuture.getDelay(TimeUnit.SECONDS));\n            final LocalDateTime newDateTime = LocalDateTime.now().plus(muteDuration, muteDurationUnit);\n\n            // Pr\u00fcfen welcher Unmute Zeitpunkt zuerst eintritt\n            if (newDateTime.isBefore(oldDateTime)) {\n                // neuer Zeitpunkt ist vor altem -> nichts tun (l\u00e4ngerer Mute bleibt bestehen)\n                return \"Nutzer ist bereits f\u00fcr einen l\u00e4ngeren Zeitraum gemuted!\";\n            }\n            else {\n                // neuer Zeitpunkt ist nach altem -> neu schedulen\n                channelMuteFutures.get(guild).get(channel).remove(user, oldFuture);\n                oldFuture.cancel(false);\n            }\n        }\n        else {\n            // Nutzer ist noch nicht gemuted\n            LOG.info(String.format(\"Muted user %s.\", UserUtils.makeUserString(user, guild)));\n        }\n\n        // Wird ausgef\u00fchrt, um Nutzer wieder zu entmuten\n        final Runnable unmuteTask = () -> {\n            final LongMap<PermissionOverride> currentOverrides = channel.getUserOverrides();\n\n            if (currentOverrides.containsKey(user.getLongID())) {\n                // Aktuelle Permissions f\u00fcr den Nutzer auslesen\n                final PermissionOverride currentUserOverride = currentOverrides.get(user.getLongID());\n\n                final EnumSet<Permissions> currentUserAllowed = currentUserOverride.allow();\n                final EnumSet<Permissions> currentUserDenied = currentUserOverride.deny();\n\n                if (oldOverrides.containsKey(user.getLongID())) {\n                    final PermissionOverride oldUserOverride = oldOverrides.get(user.getLongID());\n\n                    // alte Berechtigungen\n                    final EnumSet<Permissions> oldUserAllowed = oldUserOverride.allow();\n                    final EnumSet<Permissions> oldUserDenied = oldUserOverride.deny();\n\n                    // Die SEND_MESSAGES Permission auf den Zustand vor de Mute setzen\n                    currentUserAllowed.remove(Permissions.SEND_MESSAGES);\n                    currentUserDenied.remove(Permissions.SEND_MESSAGES);\n\n                    if (oldUserAllowed.contains(Permissions.SEND_MESSAGES)) {\n                        currentUserAllowed.add(Permissions.SEND_MESSAGES);\n                    }\n\n                    if (oldUserDenied.contains(Permissions.SEND_MESSAGES)) {\n                        currentUserDenied.add(Permissions.SEND_MESSAGES);\n                    }\n                }\n                else {\n                    // Keine alten Overrides f\u00fcr den Nutzer bekannt\n                    currentUserAllowed.remove(Permissions.SEND_MESSAGES);\n                    currentUserDenied.remove(Permissions.SEND_MESSAGES);\n                }\n\n                // Wenn Override leer ist entfernen\n                if (currentUserAllowed.size() == 0 && currentUserDenied.size() == 0) {\n                    channel.removePermissionsOverride(user);\n                }\n                else {\n                    channel.overrideUserPermissions(user, currentUserAllowed, currentUserDenied);\n                }\n            }\n            else {\n                // Override existiert nicht mehr, wurde vmtl. von Hand entfernt\n                LOG.info(String.format(\"Can't unmute user %s for channel %s. Override does not exist.\",\n                        UserUtils.makeUserString(user, guild), channel.getName()));\n            }\n\n            channelMuteFutures.get(guild).get(channel).remove(user);\n\n            LOG.info(String.format(\"Nutzer %s wurde entmuted.\", UserUtils.makeUserString(user, guild)));\n\n            saveMutedUsers();\n        };\n\n        // Unmute schedulen\n        final ScheduledFuture newFuture = scheduler.schedule(unmuteTask, muteDuration, chronoUnitToTimeUnit(muteDurationUnit));\n\n        final Map<IChannel, Map<IUser, ScheduledFuture>> guildMap;\n        if (channelMuteFutures.containsKey(guild)) {\n            guildMap = channelMuteFutures.get(guild);\n        }\n        else {\n            guildMap = new HashMap<>();\n            channelMuteFutures.put(guild, guildMap);\n        }\n\n        final Map<IUser, ScheduledFuture> channelMap;\n        if (guildMap.containsKey(channel)) {\n            channelMap = guildMap.get(channel);\n        }\n        else {\n            channelMap = new HashMap<>();\n            guildMap.put(channel, channelMap);\n        }\n\n        channelMap.put(user, newFuture);\n\n        return \"\";\n    }\n\n\n\n    private boolean isUserMutedForChannel (final IUser user, final IChannel channel) {\n        final IGuild guild = channel.getGuild();\n        if (channelMuteFutures.containsKey(guild)) {\n            final Map<IChannel, Map<IUser, ScheduledFuture>> guildMap = channelMuteFutures.get(guild);\n\n            if (guildMap.containsKey(channel)) {\n                final Map<IUser, ScheduledFuture> channelMap = guildMap.get(channel);\n\n                return channelMap.containsKey(user);\n            }\n        }\n\n        return false;\n    }\n\n    @CommandSubscriber(command = \"voicelog\", help = \"Die letzten 20 Aktivit\u00e4ten in Sprachkan\u00e4len auflisten\",\n    pmAllowed = false, permissionLevel = PermissionLevel.MODERATOR, ignoreParameterCount = true)\n    public void command_voicelog(final IMessage message, final String listCountArg) {\n        final int listCount;\n\n        if (listCountArg == null) {\n            listCount = 20;\n        }\n        else {\n            try {\n                listCount = Integer.parseInt(listCountArg);\n            }\n            catch (NumberFormatException e) {\n                DiscordIO.sendMessage(message.getChannel(), \":x: Die angegebene Anzahl ist keine g\u00fcltige Zahl!\");\n                return;\n            }\n        }\n\n        final List<String> voiceLog = getVoiceLogForGuild(message.getGuild());\n\n        final StringBuilder stringBuilder = new StringBuilder();\n        boolean entriesSkipped = false;\n\n        for (int i = voiceLog.size()-1; i > (voiceLog.size() - listCount - 1) && i >= 0; i--) {\n            final String lineToAdd = voiceLog.get(i);\n            if (stringBuilder.length() + lineToAdd.length() <= 1024) {\n                stringBuilder.append(voiceLog.get(i));\n                stringBuilder.append('\\n');\n            }\n            else {\n                entriesSkipped = true;\n            }\n        }\n\n        final EmbedBuilder responseBuilder = new EmbedBuilder();\n        final String content = stringBuilder.length() > 0 ? stringBuilder.toString() : \"_keine_\";\n        responseBuilder.appendField(String.format(\"Die letzten %s Voice-Interaktionen (von neu nach alt)\", listCount), content, false);\n        if (entriesSkipped) {\n            responseBuilder.withFooterText(\"Einer oder mehrere Eintr\u00e4ge wurden ignoriert, weil die maximale Textl\u00e4nge erreicht wurde.\");\n        }\n\n        DiscordIO.sendEmbed(message.getChannel(), responseBuilder.build());\n    }\n\n    @EventSubscriber\n    public void onUserMove (final UserVoiceChannelMoveEvent event) {\n        LOG.debug(\"Logged voice move event.\");\n        final IUser user = event.getUser();\n        final IVoiceChannel newChannel = event.getNewChannel();\n        final IGuild guild = event.getGuild();\n        final String eventString = String.format(\"**%s** :arrow_forward: ` %s`\", UserUtils.makeUserString(user, guild), newChannel.getName());\n        getVoiceLogForGuild(guild).add(eventString);\n    }\n\n    @EventSubscriber\n    public void onUserConnect(final UserVoiceChannelJoinEvent event) {\n        LOG.debug(\"Logged voice connect event.\");\n        final IUser user = event.getUser();\n        final IVoiceChannel channel = event.getVoiceChannel();\n        final IGuild guild = event.getGuild();\n        final String eventString = String.format(\"**%s** :arrow_forward: `%s`\", UserUtils.makeUserString(user, guild), channel.getName());\n        getVoiceLogForGuild(guild).add(eventString);\n    }\n\n    @EventSubscriber\n    public void onUserDisconnect(final UserVoiceChannelLeaveEvent event) {\n        LOG.debug(\"Logged voice disconnect event.\");\n        final IUser user = event.getUser();\n        final IVoiceChannel channel = event.getVoiceChannel();\n        final IGuild guild = event.getGuild();\n        final String eventString = String.format(\"**%s** :small_red_triangle_down: `%s`\", UserUtils.makeUserString(user, guild), channel.getName());\n        getVoiceLogForGuild(guild).add(eventString);\n    }\n\n    @CommandSubscriber(command = \"setModlogChannel\", help = \"Kanal in dem die Modlog Nachrichten gesendet werden einstellen\",\n            pmAllowed = false, passContext = false, permissionLevel = PermissionLevel.ADMIN)\n    public void command_setModlogChannel(final IMessage message, final String channel) {\n        final IChannel modlogChannel;\n        final List<IChannel> channelMentions = message.getChannelMentions();\n\n        if (GuildUtils.channelExists(message.getGuild(), channel)) {\n            // Kanal ID wurde als Parameter angegeben\n            modlogChannel = message.getGuild().getChannelByID(Long.parseLong(channel));\n        }\n        else if (channelMentions.size() == 1) {\n            // ein Kanal wurde erw\u00e4hnt\n            modlogChannel = channelMentions.get(0);\n        }\n        else {\n            // Kein Kanal angegeben\n            DiscordIO.sendMessage(message.getChannel(), \"Kein g\u00fcltiger Kanal angegeben!\");\n            return;\n        }\n\n        final IGuild guild = message.getGuild();\n        final JSONObject guildJSON;\n        if (modstuffJSON.has(guild.getStringID())) {\n            guildJSON = modstuffJSON.getJSONObject(guild.getStringID());\n        }\n        else {\n            guildJSON = new JSONObject();\n            modstuffJSON.put(guild.getStringID(), guildJSON);\n        }\n\n        guildJSON.put(\"modlogChannel\", modlogChannel.getLongID());\n        saveJSON();\n\n        message.addReaction(ReactionEmoji.of(\"\u2705\")); // :white_check_mark:\n    }\n\n    @CommandSubscriber(command = \"setMuteRole\", help = \"Mute Rolle einstellen einstellen\",\n            pmAllowed = false, passContext = false, permissionLevel = PermissionLevel.ADMIN)\n    public void command_setMuteRole(final IMessage message, final String role) {\n        final IRole muteRole;\n        final List<IRole> roleMentions = message.getRoleMentions();\n\n        if (GuildUtils.roleExists(message.getGuild(), role)) {\n            // Rollen ID wurde als Parameter angegeben\n            muteRole = message.getGuild().getRoleByID(Long.parseLong(role));\n        }\n        else if (roleMentions.size() == 1) {\n            // eine Rolle wurde erw\u00e4hnt\n            muteRole = roleMentions.get(0);\n        }\n        else {\n            // Keine Rolle angegeben\n            DiscordIO.sendMessage(message.getChannel(), \"Keine g\u00fcltige Rolle angegeben!\");\n            return;\n        }\n\n        final IGuild guild = message.getGuild();\n        final JSONObject guildJSON;\n        if (modstuffJSON.has(guild.getStringID())) {\n            guildJSON = modstuffJSON.getJSONObject(guild.getStringID());\n        }\n        else {\n            guildJSON = new JSONObject();\n            modstuffJSON.put(guild.getStringID(), guildJSON);\n        }\n\n        guildJSON.put(\"muteRole\", muteRole.getLongID());\n        saveJSON();\n\n        message.addReaction(ReactionEmoji.of(\"\u2705\")); // :white_check_mark:\n    }\n\n    @EventSubscriber\n    public void onUserJoin(final UserJoinEvent event) {\n        final IUser user = event.getUser();\n        if (userMuteFutures.containsKey(event.getGuild()) && userMuteFutures.get(event.getGuild()).containsKey(user)) {\n            final IRole muteRole = getMuteRoleForGuild(event.getGuild());\n            if (muteRole == null) {\n                return;\n            }\n\n            user.addRole(muteRole);\n        }\n    }\n\n    @EventSubscriber\n    public void onStartup(final ReadyEvent event) {\n        LOG.info(\"Restoring muted users.\");\n\n        for (final String guildStringID : modstuffJSON.keySet()) {\n            LOG.debug(String.format(\"Processing JSON for guild with ID '%s'.\", guildStringID));\n\n            final long guildLongID = Long.parseLong(guildStringID);\n            final IGuild guild = event.getClient().getGuildByID(guildLongID);\n            LOG.debug(String.format(\"Found guild '%s'.\", guild.getName()));\n\n            restoreGuildUserMutes(guild);\n        }\n\n        LOG.info(\"Restored all mutes.\");\n    }\n\n    private void restoreGuildUserMutes(final IGuild guild) {\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\n        final JSONArray guildUserMutes = getUserMutesJSONForGuild(guild);\n        LOG.debug(String.format(\"Found %s mutes for guild.\", guildUserMutes.length()));\n\n        for (int i = 0; i < guildUserMutes.length(); i++) {\n            final JSONObject currentUserMute = guildUserMutes.getJSONObject(i);\n            if (currentUserMute.has(\"user\") && currentUserMute.has(\"mutedUntil\")) {\n                final long userLongID = currentUserMute.getLong(\"user\");\n                final IUser user = guild.getUserByID(userLongID);\n                final String unmuteTimestampString = currentUserMute.getString(\"mutedUntil\");\n                final LocalDateTime unmuteTimestamp = LocalDateTime.parse(unmuteTimestampString, formatter);\n\n                if (LocalDateTime.now().isBefore(unmuteTimestamp)) {\n                    final int delaySeconds = (int)LocalDateTime.now().until(unmuteTimestamp, ChronoUnit.SECONDS);\n                    muteUserForGuild(user, guild, delaySeconds, ChronoUnit.SECONDS);\n                    LOG.info(String.format(\"Restored mute for user '%s' (ID: %s) for guild '%s' (ID: %s). Muted until %s\",\n                            UserUtils.makeUserString(user, guild), user.getStringID(),\n                            guild.getName(), guild.getStringID(),\n                            unmuteTimestampString));\n                }\n            }\n            else {\n                LOG.warn(String.format(\"userMute at index %s doesn't contain necessary keys! Skipping.\", i));\n            }\n        }\n    }\n\n    private IRole getMuteRoleForGuild(final IGuild guild) {\n        final JSONObject guildJSON = getJSONForGuild(guild);\n        if (guildJSON.has(\"muteRole\")) {\n            final long muteRoleID = guildJSON.getLong(\"muteRole\");\n            final IRole muteRole = guild.getRoleByID(muteRoleID);\n            if (muteRole != null) {\n                return muteRole;\n            }\n            else {\n                LOG.warn(String.format(\"Auf dem Server %s (ID: %s) wurde keine Rolle mit der ID %s gefunden!\", guild.getName(), guild.getStringID(), muteRoleID));\n                return null;\n            }\n        }\n        else {\n            LOG.warn(String.format(\"Keine Mute Rolle f\u00fcr Server %s (ID: %s) angegeben.\",\n                    guild.getName(), guild.getStringID()));\n            return null;\n        }\n    }\n\n    private IChannel getModlogChannelForGuild(final IGuild guild) {\n        final JSONObject guildJSON = getJSONForGuild(guild);\n        if (guildJSON.has(\"modlogChannel\")) {\n            final long modlogChannelID = guildJSON.getLong(\"modlogChannel\");\n            final IChannel modlogChannel = guild.getChannelByID(modlogChannelID);\n            if (modlogChannel != null) {\n                return modlogChannel;\n            }\n            else {\n                LOG.warn(String.format(\"Auf dem Server %s (ID: %s) wurde kein Channel mit der ID %s gefunden!\",\n                        guild.getName(), guild.getStringID(), modlogChannelID));\n                return null;\n            }\n        }\n        else {\n            LOG.warn(String.format(\"Kein Modlog Channel f\u00fcr Server %s (ID: %s) angegeben.\",\n                    guild.getName(), guild.getStringID()));\n            return null;\n        }\n    }\n\n    private List<String> getVoiceLogForGuild(final IGuild guild) {\n        if (voiceLog.containsKey(guild)) {\n            final List<String> log = voiceLog.get(guild);\n            final int maxSize = 100;\n            if (log.size() > maxSize) {\n                final List<String> newLog = log.subList(log.size() - maxSize, log.size());\n                voiceLog.put(guild, newLog);\n                return newLog;\n            }\n            else {\n                return log;\n            }\n        }\n        else {\n            final List<String> guildVoiceLog = new ArrayList<>();\n            voiceLog.put(guild, guildVoiceLog);\n            return guildVoiceLog;\n        }\n    }\n\n    private JSONArray getUserMutesJSONForGuild(final IGuild guild) {\n        final JSONObject guildJSON = getJSONForGuild(guild);\n        if (guildJSON.has(\"userMutes\")) {\n            return guildJSON.getJSONArray(\"userMutes\");\n        }\n        else {\n            final JSONArray jsonArray = new JSONArray();\n            guildJSON.put(\"userMutes\", jsonArray);\n            return jsonArray;\n        }\n    }\n\n    private JSONArray getChannelMutesJSONForGuild(final IGuild guild) {\n        final JSONObject guildJSON = getJSONForGuild(guild);\n        if (guildJSON.has(\"channelMutes\")) {\n            return guildJSON.getJSONArray(\"userMutes\");\n        }\n        else {\n            final JSONArray jsonArray = new JSONArray();\n            guildJSON.put(\"channelMutes\", jsonArray);\n            return jsonArray;\n        }\n    }\n\n    private JSONObject getJSONForGuild(final IGuild guild) {\n        return getJSONForGuild(guild, true);\n    }\n\n    private JSONObject getJSONForGuild(final IGuild guild, final boolean createIfNull) {\n        if (modstuffJSON.has(guild.getStringID())) {\n            // JSON for guild exists\n            return modstuffJSON.getJSONObject(guild.getStringID());\n\n        }\n        else {\n            // JSON for guild doesn't exist\n            if (createIfNull) {\n                final JSONObject guildJSON = new JSONObject();\n                modstuffJSON.put(guild.getStringID(), guildJSON);\n                return guildJSON;\n            }\n            else {\n                LOG.warn(String.format(\"No JSON Entry found for guild '%s' (ID: %s)\",\n                        guild.getName(), guild.getStringID()));\n                return null;\n            }\n        }\n    }\n\n    private static ChronoUnit parseChronoUnit (String chronoUnitString) {\n        switch (chronoUnitString.toLowerCase()) {\n            case \"s\": return ChronoUnit.SECONDS;\n            case \"m\": return ChronoUnit.MINUTES;\n            case \"h\": return ChronoUnit.HOURS;\n            case \"d\": return ChronoUnit.DAYS;\n\n            default: return ChronoUnit.SECONDS;\n        }\n    }\n\n    private TimeUnit chronoUnitToTimeUnit (ChronoUnit chronoUnit) {\n        switch (chronoUnit) {\n            case SECONDS: return TimeUnit.SECONDS;\n            case MINUTES: return TimeUnit.MINUTES;\n            case HOURS: return TimeUnit.HOURS;\n            case DAYS: return TimeUnit.DAYS;\n\n            default: throw new UnsupportedOperationException(\"Unsupported ChronoUnit\");\n        }\n    }\n\n    private void saveMutedUsers() {\n        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\n        for (Entry<IGuild, Map<IUser, ScheduledFuture>> guildEntry : userMuteFutures.entrySet()) {\n            final JSONArray guildUserMutesJSON = getUserMutesJSONForGuild(guildEntry.getKey());\n            // Clear Array\n            for (int i = 0; i < guildUserMutesJSON.length(); i++) {\n                guildUserMutesJSON.remove(i);\n            }\n            final Map<IUser, ScheduledFuture> guildUserMutesMap = guildEntry.getValue();\n\n            for (Entry<IUser, ScheduledFuture> userEntry : guildUserMutesMap.entrySet()) {\n                final JSONObject entryObject = new JSONObject();\n                entryObject.put(\"user\", userEntry.getKey().getLongID());\n\n                final ScheduledFuture unmutefuture = userEntry.getValue();\n                final long delay = unmutefuture.getDelay(TimeUnit.SECONDS);\n                final LocalDateTime unmuteTimestamp = LocalDateTime.now().plusSeconds(delay);\n                entryObject.put(\"mutedUntil\", unmuteTimestamp.format(formatter));\n                guildUserMutesJSON.put(entryObject);\n            }\n        }\n\n        saveJSON();\n    }\n\n    private void saveJSON() {\n        LOG.debug(\"Saving modstuff file.\");\n\n        final String jsonOutput = this.modstuffJSON.toString(4);\n        IOUtil.writeToFile(MODSTUFF_PATH, jsonOutput);\n    }\n}\n"},
{"Line": "=>68", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (isError) { grayOutView.setText(outView.getText()); myGrayScroll.scrollTo(grayOutView.getRight(), 0); outView.setText(\"\"); myScroll.scrollTo(outView.getRight(), 0); isError = false; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/969/buggy-version/MagicCalculator.calculator.src.main.java.com.project.calculator.MainActivity.java", "BodyUseAPI": [], "Fixed commit": "d4c2b41d513cd84868d064656fa03ccfc0e48f5c", "Url": "https://api.github.com/repos/teppoyev/Magic-Calculator", "Date": "2018-11-12T21:40:19Z"},
{"Line": "=>49", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent.getEnvironment()"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (com.alipay.sofa.infra.utils.SOFABootEnvUtils.isSpringCloudBootstrapEnvironment(environment)) { return; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/1059/buggy-version/tracer-sofa-boot-starter.src.main.java.com.alipay.sofa.tracer.boot.listener.SofaTracerConfigurationListener.java", "BodyUseAPI": [], "Fixed commit": "95534fd0f8afaed035c036cb0b52ead78b6aa0e1", "Url": "https://api.github.com/repos/alipay/sofa-tracer", "Date": "2018-11-01T06:29:00Z"},
{"Line": "=>73", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((task.getProjectId()) == null) throw new be.sbs.timekeeper.application.exception.BadRequestException(\"The project id cannot be null\");", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/493/buggy-version/timekeeper.src.main.java.be.sbs.timekeeper.application.controller.TaskController.java", "BodyUseAPI": [], "Fixed commit": "474ade4024181b9ddebe816355e2d0250169be96", "Url": "https://api.github.com/repos/stevenmollie/Timekeeper", "Date": "2018-12-05T23:09:47Z", "Source Code Diff": "@@ -4,6 +4,7 @@\n import be.sbs.timekeeper.application.beans.Task;\r\n import be.sbs.timekeeper.application.enums.Priority;\r\n import be.sbs.timekeeper.application.enums.TaskStatus;\r\n+import be.sbs.timekeeper.application.exception.BadRequestException;\r\n import be.sbs.timekeeper.application.service.ProjectService;\r\n import be.sbs.timekeeper.application.service.TaskService;\r\n import be.sbs.timekeeper.application.valueobjects.PatchOperation;\r\n@@ -69,6 +70,7 @@ public PrioritiesListResponse getListOfPriorities() {\n     @ResponseStatus(HttpStatus.CREATED)\r\n     public void addTAsk(@RequestBody Task task) {\r\n         //TODO this not right, a method result should always be used\r\n+        if (task.getProjectId() == null) throw new BadRequestException(\"The project id cannot be null\");\r\n         projectService.getById(task.getProjectId());\r\n         taskService.addTask(task);\r\n     }\r", "Complete After Code": "package be.sbs.timekeeper.application.controller;\r\n\r\nimport be.sbs.timekeeper.application.beans.Project;\r\nimport be.sbs.timekeeper.application.beans.Task;\r\nimport be.sbs.timekeeper.application.enums.Priority;\r\nimport be.sbs.timekeeper.application.enums.TaskStatus;\r\nimport be.sbs.timekeeper.application.exception.BadRequestException;\r\nimport be.sbs.timekeeper.application.service.ProjectService;\r\nimport be.sbs.timekeeper.application.service.TaskService;\r\nimport be.sbs.timekeeper.application.valueobjects.PatchOperation;\r\nimport be.sbs.timekeeper.application.valueobjects.PrioritiesListResponse;\r\nimport be.sbs.timekeeper.application.valueobjects.TaskStatusListResponse;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n@RestController\r\n@CrossOrigin\r\n@RequestMapping(path = \"/Task\")\r\npublic class TaskController {\r\n\t\r\n\tprivate final TaskService taskService;\r\n\tprivate final ProjectService projectService;\r\n\r\n\tpublic TaskController(TaskService taskService, ProjectService projectService) {\r\n\t\tthis.taskService = taskService;\r\n\t\tthis.projectService = projectService;\r\n\t}\r\n\r\n\r\n    //---- GET ------------------------------------------------------------------------------------\r\n\t@GetMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\r\n\t@ResponseStatus(HttpStatus.OK)\r\n\tpublic List<Task> getAll(){\r\n\t\tList<Task> all = taskService.getAll();\r\n\t\treturn all;\r\n\t}\r\n\t\r\n\t@GetMapping(path = \"/GetTasksFromProject/{projectId}\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\r\n\t@ResponseStatus(HttpStatus.OK)\r\n\tpublic List<Task> getAllTaskFromProject(@PathVariable String projectId){\r\n\t\t//check if project exists\r\n\t\tProject p = projectService.getById(projectId);\r\n\r\n\t\t//if project exists get all the tasks from the project\r\n\t\treturn taskService.getAllTasksFromProject(p);\r\n\t}\r\n\r\n\t@GetMapping(path = \"/{taskId}\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\r\n\t@ResponseStatus(HttpStatus.OK)\r\n\tpublic Task findById(@PathVariable String taskId) {\r\n\t\treturn taskService.findById(taskId);\r\n\t}\r\n\r\n    @GetMapping(path = \"/_statuses\")\r\n    public TaskStatusListResponse getListOfStatuses() {\r\n        return new TaskStatusListResponse(Arrays.asList(TaskStatus.values()));\r\n    }\r\n\r\n    @GetMapping(path = \"/_priorities\")\r\n    public PrioritiesListResponse getListOfPriorities() {\r\n        return new PrioritiesListResponse(Arrays.asList(Priority.values()));\r\n    }\r\n\r\n    //---- POST -----------------------------------------------------------------------------------\r\n    @PostMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\r\n    @ResponseStatus(HttpStatus.CREATED)\r\n    public void addTAsk(@RequestBody Task task) {\r\n        //TODO this not right, a method result should always be used\r\n        if (task.getProjectId() == null) throw new BadRequestException(\"The project id cannot be null\");\r\n        projectService.getById(task.getProjectId());\r\n        taskService.addTask(task);\r\n    }\r\n\r\n    //---- PATCH ----------------------------------------------------------------------------------\r\n    @PatchMapping(path = \"/{taskId}\")\r\n\t@ResponseStatus(HttpStatus.NO_CONTENT)\r\n    public void applyPatch(@PathVariable String taskId, @RequestBody PatchOperation patchOperations) {\r\n        taskService.applyPatch(taskId, patchOperations);\r\n    }\r\n\r\n    //---- PUT ------------------------------------------------------------------------------------\r\n    @PutMapping\r\n    @ResponseStatus(HttpStatus.ACCEPTED)\r\n    public void updateTask(@RequestBody Task task) {\r\n        taskService.updateTask(task);\r\n    }\r\n\r\n    //---- DELETE ---------------------------------------------------------------------------------\r\n    @DeleteMapping(path = \"/{taskId}\")\r\n    @ResponseStatus(HttpStatus.NO_CONTENT)\r\n    public void deleteTask(@PathVariable String taskId) {\r\n        taskService.deleteTask(taskId);\r\n    }\r\n\r\n}\r\n"},
{"Line": "=>771", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((Build.VERSION.SDK_INT) >= (Build.VERSION_CODES.M)) { requestPermissions(new java.lang.String[]{ android.Manifest.permission.CALL_PHONE }, 1); if ((android.support.v4.content.ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.CALL_PHONE)) == (android.content.pm.PackageManager.PERMISSION_GRANTED)) { startActivity(intent); } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/475/buggy-version/app.src.main.java.com.example.kyle.c196_class_tracker.activities.CourseDetails.java", "BodyUseAPI": [], "Fixed commit": "c09884dfa7bd67bbb640dd86481c929cbf520bd3", "Url": "https://api.github.com/repos/kretherford0983/C196_Class_Tracker", "Date": "2018-12-18T04:32:14Z"},
{"Line": "=>688", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((Build.VERSION.SDK_INT) >= (Build.VERSION_CODES.M)) { requestPermissions(new java.lang.String[]{ android.Manifest.permission.CALL_PHONE }, 1); if ((android.support.v4.content.ContextCompat.checkSelfPermission(getApplicationContext(), android.Manifest.permission.CALL_PHONE)) == (android.content.pm.PackageManager.PERMISSION_GRANTED)) { startActivity(intent); } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/475/buggy-version/app.src.main.java.com.example.kyle.c196_class_tracker.activities.CourseDetails.java", "BodyUseAPI": [], "Fixed commit": "c09884dfa7bd67bbb640dd86481c929cbf520bd3", "Url": "https://api.github.com/repos/kretherford0983/C196_Class_Tracker", "Date": "2018-12-18T04:32:14Z"},
{"Line": "=>25", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (userExistsInDatabase(user.getUsername())) { return org.springframework.http.ResponseEntity.status(HttpStatus.I_AM_A_TEAPOT).build(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/301/buggy-version/src.main.java.com.qa.cv_manager.userapi.service.UserServiceImpl.java", "BodyUseAPI": [], "Fixed commit": "7d080bcb351bdc76145abde44ca470aed2cf5bcc", "Url": "https://api.github.com/repos/bentom08/UserCreationAPI", "Date": "2018-12-12T11:45:55Z", "Source Code Diff": "@@ -1,6 +1,7 @@\n package com.qa.cv_manager.userapi.service;\n \n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpStatus;\n import org.springframework.http.ResponseEntity;\n import org.springframework.security.crypto.password.PasswordEncoder;\n import org.springframework.stereotype.Service;\n@@ -21,8 +22,12 @@ public class UserServiceImpl implements UserService {\n \t\n \n \tpublic ResponseEntity<Object> addUser(UserPOJO user) {\n+\t\tif(userExistsInDatabase(user.getUsername())) {\n+\t\t\treturn ResponseEntity.status(HttpStatus.I_AM_A_TEAPOT).build();\n+\t\t}\n+\t\t\n \t\tUser storedUser = createUserEntityFromPOJO(user);\n-\n+\t\t\n \t\trepo.save(storedUser);\n \t\t\n \t\treturn ResponseEntity.ok().build();", "Complete After Code": "package com.qa.cv_manager.userapi.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\nimport com.qa.cv_manager.userapi.persistence.domain.User;\nimport com.qa.cv_manager.userapi.persistence.domain.UserPOJO;\nimport com.qa.cv_manager.userapi.persistence.domain.UserRole;\nimport com.qa.cv_manager.userapi.persistence.repository.UserRepository;\n\n@Service\npublic class UserServiceImpl implements UserService {\n\t\n\t@Autowired\n\tprivate UserRepository repo;\n\t\n\t@Autowired\n\tprivate PasswordEncoder passwordEncoder;\n\t\n\n\tpublic ResponseEntity<Object> addUser(UserPOJO user) {\n\t\tif(userExistsInDatabase(user.getUsername())) {\n\t\t\treturn ResponseEntity.status(HttpStatus.I_AM_A_TEAPOT).build();\n\t\t}\n\t\t\n\t\tUser storedUser = createUserEntityFromPOJO(user);\n\t\t\n\t\trepo.save(storedUser);\n\t\t\n\t\treturn ResponseEntity.ok().build();\n\t}\n\n\tpublic ResponseEntity<Object> updatePassword(UserPOJO user, String username) {\t\n\t\tif (!userExistsInDatabase(username)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\t\n\t\tUser storedUser = createUserEntityFromPOJO(user);\n\t\t\n\t\tstoredUser.setUsername(username);\n\t\trepo.save(storedUser);\n\t\t\n\t\treturn ResponseEntity.ok().build();\n\t}\n\n\tpublic ResponseEntity<Object> deleteUser(String username) {\n\t\tif(!userExistsInDatabase(username)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\t\t\n\t\trepo.deleteById(username);\n\t\t\n\t\treturn ResponseEntity.ok().build();\n\t}\n\t\n\tpublic ResponseEntity<Object> disableAccount(String username) {\n\t\treturn toggleAccount(username, false);\n\t}\n\t\n\tpublic ResponseEntity<Object> enableAccount(String username) {\n\t\treturn toggleAccount(username, true);\n\t}\n\t\n\tprivate ResponseEntity<Object> toggleAccount(String username, boolean isAccountBeingEnabled) {\n\t\tif(!userExistsInDatabase(username)) {\n\t\t\treturn ResponseEntity.notFound().build();\n\t\t}\n\t\t\n\t\tUser disabledUser = repo.findById(username).get();\n\t\tdisabledUser.setEnabled(isAccountBeingEnabled);\n\t\t\n\t\trepo.save(disabledUser);\n\t\t\n\t\treturn ResponseEntity.ok().build();\n\t}\n\t\n\tprivate User createUserEntityFromPOJO(UserPOJO user) {\n\t\tUserRole role = new UserRole(user.getUsername(), user.getRole());\n\t\t\n\t\treturn new User(user.getUsername(),\n\t\t\t\tpasswordEncoder.encode(user.getPassword()),\n\t\t\t\tuser.isEnabled(),\n\t\t\t\trole);\n\t}\n\t\n\tprivate boolean userExistsInDatabase(String username) {\n\t\treturn repo.findById(username).isPresent();\n\t}\n}\n"},
{"Line": "=>50", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["value.toString().split(java.lang.String)"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if (isInteger(singleReview[8])) { if ((java.lang.Integer.parseInt(singleReview[8])) < 3) { while (reviewItr.hasMoreTokens()) { word = reviewItr.nextToken().toLowerCase(); if (!(NegativeReviewWordCount.BusinessReviewMapper.wordsToSkip.contains(word))) { context.write(new org.apache.hadoop.io.Text((((singleReview[4]) + ' ') + word)), NegativeReviewWordCount.BusinessReviewMapper.one); } } } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/515/buggy-version/src.NegativeReviewWordCount.java", "BodyUseAPI": ["java.lang.Integer.parseInt(java.lang.String)", "Context.write(org.apache.hadoop.io.Text,org.apache.hadoop.io.IntWritable)"], "Fixed commit": "fec8fb0e8e919118a9f1fae38012965ef11fb1be", "Url": "https://api.github.com/repos/wpniederer/BigData-YelpDataSet", "Date": "2018-12-11T11:39:53Z", "Source Code Diff": "@@ -27,27 +27,40 @@ public static class BusinessReviewMapper extends Mapper<Object, Text, Text, IntW\n             \"had\", \"it's\", \"it\", \"its\", \"in\", \"would\", \"could\", \"should\", \"for\", \"get\", \"me\", \"he\", \"she\", \"him\", \"her\"};\n     private final static Set<String> wordsToSkip = new HashSet<>(Arrays.asList(words));\n \n+        public boolean isInteger(String input) {\n+            try {\n+                Integer.parseInt(input);\n+                return true;\n+            }\n+            catch(Exception e) {\n+                return false;\n+            }\n+        }\n+\n         public void map(Object key, Text value, Context context ) throws IOException, InterruptedException {\n             String[] singleReview = value.toString().split(\"\\\\|\");\n \n+\n             if(singleReview.length >= 9){\n                 // 3th index is the review\n                 StringTokenizer reviewItr = new StringTokenizer(singleReview[3], \" ,.1234567890!;?-:@[](){}_*/\");\n                 String word = \"\";\n \n                 // 8th index is the star rating\n-                if (Integer.parseInt(singleReview[8]) < 3) {\n-                    while(reviewItr.hasMoreTokens()) {\n-                        word = reviewItr.nextToken().toLowerCase();\n+                if (isInteger(singleReview[8])) {\n+                    if (Integer.parseInt(singleReview[8]) < 3) {\n+                        while(reviewItr.hasMoreTokens()) {\n+                            word = reviewItr.nextToken().toLowerCase();\n \n-                        if (!wordsToSkip.contains(word)) {\n-                            // 4th index is the businessID\n-                            context.write(new Text(singleReview[4] + ' ' + word), one);\n-                        }\n+                            if (!wordsToSkip.contains(word)) {\n+                                // 4th index is the businessID\n+                                context.write(new Text(singleReview[4] + ' ' + word), one);\n+                            }\n \n+                        }\n                     }\n-\n                 }\n+\n             }\n \n         }\n@@ -69,6 +82,7 @@ public void reduce(Text key, Iterable<IntWritable> values, Context context) thro\n \n \n \n+\n     public static void main(String[] args) throws Exception {\n         Configuration conf = new Configuration();\n ", "Complete After Code": "import org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.Job;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n\n@SuppressWarnings(\"deprecation\")\npublic class NegativeReviewWordCount {\n\n    public static class BusinessReviewMapper extends Mapper<Object, Text, Text, IntWritable> {\n\n    private final static IntWritable one = new IntWritable(1);\n    private final static String[] words = new String[] {\"a\", \"and\", \"an\", \"but\", \"is\", \"or\", \"the\", \"to\", \"too\", \".\",\n            \",\", \"!\", \"were\", \"are\", \"then\", \"also\", \"with\", \"while\", \"who\", \"which\", \"besides\", \"since\", \"until\",\n            \"after\", \"before\", \"like\", \"so\", \"they\", \"them\", \"their\", \"there\", \"they're\", \"we\", \"you\", \"i\", \"my\", \"was\",\n            \"had\", \"it's\", \"it\", \"its\", \"in\", \"would\", \"could\", \"should\", \"for\", \"get\", \"me\", \"he\", \"she\", \"him\", \"her\"};\n    private final static Set<String> wordsToSkip = new HashSet<>(Arrays.asList(words));\n\n        public boolean isInteger(String input) {\n            try {\n                Integer.parseInt(input);\n                return true;\n            }\n            catch(Exception e) {\n                return false;\n            }\n        }\n\n        public void map(Object key, Text value, Context context ) throws IOException, InterruptedException {\n            String[] singleReview = value.toString().split(\"\\\\|\");\n\n\n            if(singleReview.length >= 9){\n                // 3th index is the review\n                StringTokenizer reviewItr = new StringTokenizer(singleReview[3], \" ,.1234567890!;?-:@[](){}_*/\");\n                String word = \"\";\n\n                // 8th index is the star rating\n                if (isInteger(singleReview[8])) {\n                    if (Integer.parseInt(singleReview[8]) < 3) {\n                        while(reviewItr.hasMoreTokens()) {\n                            word = reviewItr.nextToken().toLowerCase();\n\n                            if (!wordsToSkip.contains(word)) {\n                                // 4th index is the businessID\n                                context.write(new Text(singleReview[4] + ' ' + word), one);\n                            }\n\n                        }\n                    }\n                }\n\n            }\n\n        }\n\n    }\n\n    public static class BusinessReviewReducer extends Reducer<Text, IntWritable, Text, IntWritable> {\n            private IntWritable result = new IntWritable();\n\n            public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {\n                int sum = 0;\n                for (IntWritable val : values) {\n                    sum += val.get();\n                }\n                result.set(sum);\n                context.write(key, result);\n            }\n        }\n\n\n\n\n    public static void main(String[] args) throws Exception {\n        Configuration conf = new Configuration();\n\n        Job job = new Job(conf, \"yelp negative word count\");\n        job.setJarByClass(NegativeReviewWordCount.class);\n\n        job.setMapperClass(BusinessReviewMapper.class);\n        job.setReducerClass(BusinessReviewReducer.class);\n\n        job.setOutputKeyClass(Text.class);\n        job.setOutputValueClass(IntWritable.class);\n\n        FileInputFormat.addInputPath(job, new Path(args[0]));\n        FileOutputFormat.setOutputPath(job, new Path(args[1]));\n\n        System.exit(job.waitForCompletion(true) ? 0 : 1);\n    }\n\n\n}\n\n"},
{"Line": "=>88", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (!(org.springframework.util.StringUtils.isEmpty(o1.getSituationIds()))) { if (org.springframework.util.StringUtils.isEmpty(o2.getSituationIds())) { return -1; }else { return 0; } }else { if (org.springframework.util.StringUtils.isEmpty(o2.getSituationIds())) { return 0; }else { return 1; } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/736/buggy-version/src.main.java.com.tian.cloud.service.service.impl.CompanyServiceImpl.java", "BodyUseAPI": [], "Fixed commit": "9a702273b2dae33472afd1305cf74d8935f60add", "Url": "https://api.github.com/repos/ImTianGuang/FloodControl", "Date": "2018-11-08T06:04:42Z"},
{"Line": "=>64", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (!(org.springframework.util.StringUtils.isEmpty(o1.getSituationIds()))) { if (org.springframework.util.StringUtils.isEmpty(o2.getSituationIds())) { return -1; }else { return 0; } }else { if (org.springframework.util.StringUtils.isEmpty(o2.getSituationIds())) { return 0; }else { return 1; } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/736/buggy-version/src.main.java.com.tian.cloud.service.service.impl.CompanyServiceImpl.java", "BodyUseAPI": [], "Fixed commit": "9a702273b2dae33472afd1305cf74d8935f60add", "Url": "https://api.github.com/repos/ImTianGuang/FloodControl", "Date": "2018-11-08T06:04:42Z"},
{"Line": "=>201", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["com.japanesetoolboxapp.resources.Utilities.getDifferentAsyncWords(java.util.List<com.japanesetoolboxapp.data.Word>,java.util.List<com.japanesetoolboxapp.data.Word>)"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if ((differentJishoWords.size()) > 0) { updateFirebaseDbWithJishoWords(com.japanesetoolboxapp.resources.Utilities.getCommonWords(differentJishoWords)); updateFirebaseDbWithJishoWords(differentJishoWords.subList(0, 1)); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/996/buggy-version/app.src.main.java.com.japanesetoolboxapp.ui.DictionaryFragment.java", "BodyUseAPI": ["java.util.List<com.japanesetoolboxapp.data.Word>.subList(int,int)", "com.japanesetoolboxapp.ui.DictionaryFragment.updateFirebaseDbWithJishoWords(differentJishoWords.subList(0, 1))", "com.japanesetoolboxapp.ui.DictionaryFragment.updateFirebaseDbWithJishoWords(com.japanesetoolboxapp.resources.Utilities.getCommonWords(differentJishoWords))", "com.japanesetoolboxapp.resources.Utilities.getCommonWords(java.util.List<com.japanesetoolboxapp.data.Word>)"], "Fixed commit": "3d281f57818023e47e5be5d63123b867445ddf37", "Url": "https://api.github.com/repos/blarom/JapaneseToolbox", "Date": "2018-11-18T05:36:58Z", "Source Code Diff": "@@ -198,9 +198,11 @@ else if (loader.getId() == JISHO_WEB_SEARCH_LOADER && !mAlreadyLoadedJishoResult\n                 if (differentJishoWords.size()==0) Toast.makeText(getContext(), R.string.no_new_words_or_meanings_found_online, Toast.LENGTH_SHORT).show();\n                 else Toast.makeText(getContext(), \"Updated list with online results.\", Toast.LENGTH_SHORT).show();\n \n-                updateFirebaseDbWithJishoWords(Utilities.getCommonWords(differentJishoWords));\n-                updateFirebaseDbWithJishoWords(differentJishoWords.subList(0,1)); //If the word was searched for then it is useful even if it's not defined as common\n-                //updateFirebaseDbWithJishoWords(differentJishoWords);\n+                if (differentJishoWords.size()>0) {\n+                    updateFirebaseDbWithJishoWords(Utilities.getCommonWords(differentJishoWords));\n+                    updateFirebaseDbWithJishoWords(differentJishoWords.subList(0, 1)); //If the word was searched for then it is useful even if it's not defined as common\n+                    //updateFirebaseDbWithJishoWords(differentJishoWords);\n+                }\n \n                 displayResults(mMergedMatchingWordsList);\n             }", "Complete After Code": "package com.japanesetoolboxapp.ui;\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.os.Looper;\nimport android.support.annotation.NonNull;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.LoaderManager;\nimport android.support.v4.content.AsyncTaskLoader;\nimport android.support.v4.content.Loader;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.japanesetoolboxapp.R;\nimport com.japanesetoolboxapp.adapters.DictionaryRecyclerViewAdapter;\nimport com.japanesetoolboxapp.data.FirebaseDao;\nimport com.japanesetoolboxapp.data.JapaneseToolboxCentralRoomDatabase;\nimport com.japanesetoolboxapp.data.Word;\nimport com.japanesetoolboxapp.resources.GlobalConstants;\nimport com.japanesetoolboxapp.resources.MainApplication;\nimport com.japanesetoolboxapp.resources.Utilities;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\nimport butterknife.Unbinder;\n\npublic class DictionaryFragment extends Fragment implements\n        LoaderManager.LoaderCallbacks<List<Word>>,\n        FirebaseDao.FirebaseOperationsHandler, DictionaryRecyclerViewAdapter.DictionaryItemClickHandler {\n\n\n    //region Parameters\n    @BindView(R.id.dictionary_recyclerview) RecyclerView mDictionaryRecyclerView;\n    @BindView(R.id.word_hint) TextView mHintTextView;\n    @BindView(R.id.dict_results_loading_indicator) ProgressBar mProgressBarLoadingIndicator;\n    private static final int MAX_NUMBER_RESULTS_SHOWN = 50;\n    private String mInputQuery;\n    private static final int JISHO_WEB_SEARCH_LOADER = 41;\n    private static final int ROOM_DB_SEARCH_LOADER = 42;\n    Toast mShowOnlineResultsToast;\n    private List<Word> mLocalMatchingWordsList;\n    private List<Word> mMergedMatchingWordsList;\n    JapaneseToolboxCentralRoomDatabase mJapaneseToolboxCentralRoomDatabase;\n    private Boolean mShowOnlineResults;\n    private FirebaseDao mFirebaseDao;\n    private Unbinder mBinding;\n    private boolean mAlreadyLoadedRoomResults;\n    private boolean mAlreadyLoadedJishoResults;\n    private List<String[]> mLegendDatabase;\n    private DictionaryRecyclerViewAdapter mDictionaryRecyclerViewAdapter;\n    //endregion\n\n\n    //Fragment Lifecycle methods\n    @Override public void onAttach(Context context) {\n        super.onAttach(context);\n        dictionaryFragmentOperationsHandler = (DictionaryFragmentOperationsHandler) context;\n   }\n    @Override public void onCreate(Bundle savedInstanceState) { //instead of onActivityCreated\n        super.onCreate(savedInstanceState);\n\n        getExtras();\n        initializeParameters();\n\n    }\n    @Override public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\n        //setRetainInstance(true);\n        final View rootView = inflater.inflate(R.layout.fragment_dictionary, container, false);\n\n        initializeViews(rootView);\n\n        getQuerySearchResults();\n\n        return rootView;\n    }\n    @Override public void onPause() {\n        super.onPause();\n    }\n    @Override public void onSaveInstanceState(@NonNull Bundle outState) {\n        super.onSaveInstanceState(outState);\n\n        outState.putParcelableArrayList(getString(R.string.saved_local_results), new ArrayList<>(mLocalMatchingWordsList));\n        outState.putParcelableArrayList(getString(R.string.saved_merged_results), new ArrayList<>(mMergedMatchingWordsList));\n        outState.putString(getString(R.string.saved_input_query), mInputQuery);\n\n        destroyLoaders();\n\n    }\n    @Override public void onResume() {\n        super.onResume();\n    }\n    @Override public void onDetach() {\n        super.onDetach();\n        destroyLoaders();\n        mFirebaseDao.removeListeners();\n        destroyLoaders();\n    }\n    @Override public void onDestroyView() {\n        super.onDestroyView();\n        mBinding.unbind();\n    }\n    @Override public void onDestroy() {\n        super.onDestroy();\n        if (getActivity()!=null && MainApplication.getRefWatcher(getActivity())!=null) MainApplication.getRefWatcher(getActivity()).watch(this);\n    }\n\n\n    //Asynchronous methods\n    @NonNull @Override public Loader<List<Word>> onCreateLoader(int id, final Bundle args) {\n\n        String inputQuery = \"\";\n        if (args!=null && args.getString(getString(R.string.saved_input_query))!=null) {\n            inputQuery = args.getString(getString(R.string.saved_input_query));\n        }\n\n        if (id == JISHO_WEB_SEARCH_LOADER) {\n            JishoResultsAsyncTaskLoader jishoResultsAsyncTaskLoader = new JishoResultsAsyncTaskLoader(getContext(), inputQuery);\n            jishoResultsAsyncTaskLoader.setLoaderState(true);\n            return jishoResultsAsyncTaskLoader;\n        }\n        else if (id == ROOM_DB_SEARCH_LOADER){\n            RoomDbWordSearchAsyncTaskLoader roomDbSearchLoader = new RoomDbWordSearchAsyncTaskLoader(getContext(), inputQuery);\n            return roomDbSearchLoader;\n        }\n        else return new RoomDbWordSearchAsyncTaskLoader(getContext(), \"\");\n    }\n    @Override public void onLoadFinished(@NonNull Loader<List<Word>> loader, List<Word> loaderResultWordsList) {\n\n        if (getContext() == null) return;\n\n        hideLoadingIndicator();\n        if (loader.getId() == ROOM_DB_SEARCH_LOADER && !mAlreadyLoadedRoomResults) {\n            mAlreadyLoadedRoomResults = true;\n            mLocalMatchingWordsList = loaderResultWordsList;\n            mLocalMatchingWordsList = sortWordsAccordingToLengths(mLocalMatchingWordsList);\n\n            //Update the MainActivity with the matching words\n            dictionaryFragmentOperationsHandler.onLocalMatchingWordsFound(mLocalMatchingWordsList);\n\n            //Displaying the local results\n            displayWordsToUser(mLocalMatchingWordsList);\n\n            mShowOnlineResults = Utilities.getShowOnlineResultsPreference(getActivity());\n\n            String text;\n            if (mLocalMatchingWordsList.size() > 1) {\n                if (mLocalMatchingWordsList.size() < GlobalConstants.MAX_SQL_VARIABLES_FOR_QUERY)\n                    text = \"Found \" + mLocalMatchingWordsList.size() + \" local results. \";\n                else text = \"Found more than\" + GlobalConstants.MAX_SQL_VARIABLES_FOR_QUERY + \" local results. \";\n            }\n            else if (mLocalMatchingWordsList.size() == 1) text = \"Found one local result. \";\n            else text = \"No local results. \";\n            if (mShowOnlineResults) {\n                //If wanted, update the results with words from Jisho.org\n                text += \"Searching online, please wait\u2026\";\n                startSearchingForJishoWords();\n            }\n            else if (mLocalMatchingWordsList.size()==0) {\n                //Otherwise (if online results are unwanted), if there are no local results to display then try the reverse verb search\n                performConjSearch();\n            }\n            else {\n                dictionaryFragmentOperationsHandler.onFinalMatchingWordsFound(mLocalMatchingWordsList);\n            }\n            mShowOnlineResultsToast = Toast.makeText(getContext(), text, Toast.LENGTH_SHORT);\n            mShowOnlineResultsToast.show();\n\n            if (getLoaderManager()!=null) getLoaderManager().destroyLoader(ROOM_DB_SEARCH_LOADER);\n        }\n        else if (loader.getId() == JISHO_WEB_SEARCH_LOADER && !mAlreadyLoadedJishoResults) {\n            mAlreadyLoadedJishoResults = true;\n\n            List<Word> jishoWords = Utilities.cleanUpProblematicWordsFromJisho(loaderResultWordsList);\n\n            //If wanted, update the results with words from Jisho.org by merging the lists, otherwise clear the jisho results\n            Boolean showOnlineResults = Utilities.getShowOnlineResultsPreference(getActivity());\n            if (!showOnlineResults) jishoWords = new ArrayList<>();\n\n            if (jishoWords.size() != 0) {\n                mMergedMatchingWordsList = Utilities.getMergedWordsList(mLocalMatchingWordsList, jishoWords);\n                mMergedMatchingWordsList = sortWordsAccordingToLengths(mMergedMatchingWordsList);\n\n                dictionaryFragmentOperationsHandler.onFinalMatchingWordsFound(mMergedMatchingWordsList);\n\n                List<Word> differentJishoWords = Utilities.getDifferentAsyncWords(mLocalMatchingWordsList, jishoWords);\n                if (differentJishoWords.size()==0) Toast.makeText(getContext(), R.string.no_new_words_or_meanings_found_online, Toast.LENGTH_SHORT).show();\n                else Toast.makeText(getContext(), \"Updated list with online results.\", Toast.LENGTH_SHORT).show();\n\n                if (differentJishoWords.size()>0) {\n                    updateFirebaseDbWithJishoWords(Utilities.getCommonWords(differentJishoWords));\n                    updateFirebaseDbWithJishoWords(differentJishoWords.subList(0, 1)); //If the word was searched for then it is useful even if it's not defined as common\n                    //updateFirebaseDbWithJishoWords(differentJishoWords);\n                }\n\n                displayResults(mMergedMatchingWordsList);\n            }\n            else {\n                dictionaryFragmentOperationsHandler.onFinalMatchingWordsFound(mLocalMatchingWordsList);\n                Toast.makeText(getContext(), R.string.no_matching_words_online, Toast.LENGTH_SHORT).show();\n                //if there are no jisho results (for whatever reason) and no local results to display, then try the reverse verb search on the input\n                if (mLocalMatchingWordsList.size()==0) {\n                    performConjSearch();\n                }\n            }\n\n            if (getLoaderManager()!=null) getLoaderManager().destroyLoader(JISHO_WEB_SEARCH_LOADER);\n\n        }\n\n    }\n    @Override public void onLoaderReset(@NonNull Loader<List<Word>> loader) {}\n    private static class JishoResultsAsyncTaskLoader extends AsyncTaskLoader <List<Word>> {\n\n        String mQuery;\n        private boolean internetIsAvailable;\n        private boolean mAllowLoaderStart;\n\n        JishoResultsAsyncTaskLoader(Context context, String query) {\n            super(context);\n            this.mQuery = query;\n            this.internetIsAvailable = internetIsAvailable;\n        }\n\n        @Override\n        protected void onStartLoading() {\n            if (mAllowLoaderStart) forceLoad();\n        }\n\n        @Override\n        public List<Word> loadInBackground() {\n\n            internetIsAvailable = Utilities.internetIsAvailableCheck(getContext());\n\n            List<Word> matchingWordsFromJisho = new ArrayList<>();\n\n            if (internetIsAvailable && !TextUtils.isEmpty(mQuery)) {\n                matchingWordsFromJisho = Utilities.getWordsFromJishoOnWeb(mQuery, getContext());\n            } else {\n                Log.i(\"Diagnosis Time\", \"Failed to access online resources.\");\n                if (Looper.myLooper()==null) Looper.prepare();\n                Toast.makeText(getContext(), R.string.failed_to_connect_to_internet, Toast.LENGTH_SHORT).show();\n                cancelLoadInBackground();\n            }\n            return matchingWordsFromJisho;\n        }\n\n        void setLoaderState(boolean state) {\n            mAllowLoaderStart = state;\n        }\n    }\n    private static class RoomDbWordSearchAsyncTaskLoader extends AsyncTaskLoader <List<Word>> {\n\n        String mSearchWord;\n        private List<Long> mMatchingWordIds;\n\n        RoomDbWordSearchAsyncTaskLoader(Context context, String searchWord) {\n            super(context);\n            mSearchWord = searchWord;\n        }\n\n        @Override\n        protected void onStartLoading() {\n            if (!TextUtils.isEmpty(mSearchWord)) forceLoad();\n        }\n\n        @Override\n        public List<Word> loadInBackground() {\n\n            List<Word> localMatchingWordsList = new ArrayList<>();\n            if (!TextUtils.isEmpty(mSearchWord)) {\n                JapaneseToolboxCentralRoomDatabase japaneseToolboxCentralRoomDatabase = JapaneseToolboxCentralRoomDatabase.getInstance(getContext());\n                mMatchingWordIds = Utilities.getMatchingWordIdsAndDoBasicFiltering(mSearchWord, japaneseToolboxCentralRoomDatabase);\n                localMatchingWordsList = japaneseToolboxCentralRoomDatabase.getWordListByWordIds(mMatchingWordIds);\n            }\n\n            return localMatchingWordsList;\n        }\n    }\n\n\n\t//Functionality methods\n    private void getExtras() {\n        if (getArguments()!=null) {\n            mInputQuery = getArguments().getString(getString(R.string.user_query_word));\n            mLegendDatabase = (List<String[]>) getArguments().getSerializable(getString(R.string.legend_database));\n        }\n    }\n    private void initializeParameters() {\n\n        mFirebaseDao = new FirebaseDao(getContext(), this);\n\n        mLocalMatchingWordsList = new ArrayList<>();\n        mMergedMatchingWordsList = new ArrayList<>();\n\n        mAlreadyLoadedRoomResults = false;\n        mAlreadyLoadedJishoResults = false;\n    }\n    private void initializeViews(View rootView) {\n        mBinding = ButterKnife.bind(this, rootView);\n\n        mDictionaryRecyclerView.setLayoutManager(new LinearLayoutManager(getContext(), LinearLayoutManager.VERTICAL, false));\n        mDictionaryRecyclerView.setNestedScrollingEnabled(true);\n        mDictionaryRecyclerViewAdapter = new DictionaryRecyclerViewAdapter(getContext(), this, null, mLegendDatabase);\n        mDictionaryRecyclerView.setAdapter(mDictionaryRecyclerViewAdapter);\n    }\n    private void getQuerySearchResults() {\n        if (!TextUtils.isEmpty(mInputQuery)) findMatchingWordsInRoomDb();\n        else showEmptySearchResults();\n    }\n    private void findMatchingWordsInRoomDb() {\n        if (getActivity()!=null) {\n            showLoadingIndicator();\n            LoaderManager loaderManager = getActivity().getSupportLoaderManager();\n            Loader<String> roomDbSearchLoader = loaderManager.getLoader(ROOM_DB_SEARCH_LOADER);\n            Bundle bundle = new Bundle();\n            bundle.putString(getString(R.string.saved_input_query), mInputQuery);\n            if (roomDbSearchLoader == null) loaderManager.initLoader(ROOM_DB_SEARCH_LOADER, bundle, this);\n            else loaderManager.restartLoader(ROOM_DB_SEARCH_LOADER, bundle, this);\n        }\n    }\n    private void showEmptySearchResults() {\n        displayResults(new ArrayList<Word>());\n    }\n    private void displayWordsToUser(List<Word> localMatchingWordsList) {\n\n        localMatchingWordsList = sortWordsAccordingToLengths(localMatchingWordsList);\n        displayResults(localMatchingWordsList);\n\n    }\n    private void startSearchingForJishoWords() {\n\n        if (!TextUtils.isEmpty(mInputQuery)) {\n\n            if (getActivity() != null) {\n\n                Bundle queryBundle = new Bundle();\n                queryBundle.putString(getString(R.string.saved_input_query), mInputQuery);\n\n                //Attempting to access jisho.org to complete the results found in the local dictionary\n                LoaderManager loaderManager = getActivity().getSupportLoaderManager();\n                Loader<String> JishoWebSearchLoader = loaderManager.getLoader(JISHO_WEB_SEARCH_LOADER);\n                if (JishoWebSearchLoader == null) loaderManager.initLoader(JISHO_WEB_SEARCH_LOADER, queryBundle, this);\n                else loaderManager.restartLoader(JISHO_WEB_SEARCH_LOADER, queryBundle, this);\n            }\n        }\n\n    }\n    private void performConjSearch() {\n\n        destroyLoaders();\n\n        if (!TextUtils.isEmpty(mInputQuery)) {\n            if (mShowOnlineResultsToast!=null) mShowOnlineResultsToast.cancel();\n            dictionaryFragmentOperationsHandler.onVerbConjugationFromDictRequested(mInputQuery);\n        }\n    }\n    private void displayResults(List<Word> wordsList) {\n\n        if (getActivity()!=null) Utilities.hideSoftKeyboard(getActivity());\n\n        if (wordsList.size()>MAX_NUMBER_RESULTS_SHOWN) {\n            List<Word> displayedWords = wordsList.subList(0,MAX_NUMBER_RESULTS_SHOWN);\n            mDictionaryRecyclerViewAdapter.setContents(displayedWords);\n        }\n        else mDictionaryRecyclerViewAdapter.setContents(wordsList);\n\n        if (wordsList.size()>0) {\n            mHintTextView.setVisibility(View.GONE);\n            mDictionaryRecyclerView.setVisibility(View.VISIBLE);\n        }\n        else {\n            if (mInputQuery.equals(\"\")) mHintTextView.setText(Utilities.fromHtml(getResources().getString(R.string.please_enter_word)));\n            else mHintTextView.setText(Utilities.fromHtml(getResources().getString(R.string.no_match_found)));\n            mHintTextView.setVisibility(View.VISIBLE);\n            mDictionaryRecyclerView.setVisibility(View.GONE);\n        }\n\n        // Populate the list of choices for the SearchResultsChooserSpinner. Each text element of inside the individual spinner choices corresponds to a sub-element of the choicelist\n        //createExpandableListViewContentsFromWordsList(wordsList);\n        //showExpandableListViewWithContents();\n    }\n    private List<Word> sortWordsAccordingToLengths(List<Word> wordsList) {\n\n        if (wordsList == null || wordsList.size()==0) return new ArrayList<>();\n\n        List<long[]> matchingWordIndexesAndLengths = new ArrayList<>();\n\n        //region Registering if the input query is a \"to \" verb\n        boolean queryIsVerbWithTo = false;\n        String queryWordWithoutTo = \"\";\n        if (mInputQuery.length()>3 && mInputQuery.substring(0,3).equals(\"to \")) {\n            queryIsVerbWithTo = true;\n            queryWordWithoutTo = mInputQuery.substring(3, mInputQuery.length());\n        }\n        //endregion\n\n        //region Replacing the Kana input word by its romaji equivalent\n        String inputQuery = mInputQuery;\n        int inputTextType = ConvertFragment.getTextType(inputQuery);\n        if (inputTextType == GlobalConstants.TYPE_HIRAGANA || inputTextType == GlobalConstants.TYPE_KATAKANA) {\n            List<String> translationList = ConvertFragment.getLatinHiraganaKatakana(inputQuery.replace(\" \", \"\"));\n            inputQuery = translationList.get(0);\n        }\n        //endregion\n\n        for (int i = 0; i < wordsList.size(); i++) {\n\n            Word currentWord = wordsList.get(i);\n            if (currentWord==null) continue;\n\n            int length = Utilities.getLengthFromWordAttributes(currentWord, inputQuery, queryWordWithoutTo, queryIsVerbWithTo);\n\n            long[] currentMatchingWordIndexAndLength = new long[3];\n            currentMatchingWordIndexAndLength[0] = i;\n            currentMatchingWordIndexAndLength[1] = length;\n            currentMatchingWordIndexAndLength[2] = 0;\n\n            matchingWordIndexesAndLengths.add(currentMatchingWordIndexAndLength);\n        }\n\n        //Sort the results according to total length\n        if (matchingWordIndexesAndLengths.size() != 0) {\n            matchingWordIndexesAndLengths = Utilities.bubbleSortForThreeIntegerList(matchingWordIndexesAndLengths);\n        }\n\n        //Return the sorted list\n        List<Word> sortedWordsList = new ArrayList<>();\n        for (int i = 0; i < matchingWordIndexesAndLengths.size(); i++) {\n            long sortedIndex = matchingWordIndexesAndLengths.get(i)[0];\n            sortedWordsList.add(wordsList.get((int) sortedIndex));\n        }\n\n        return sortedWordsList;\n    }\n    private void updateFirebaseDbWithJishoWords(List<Word> wordsList) {\n        mFirebaseDao.updateObjectsOrCreateThemInFirebaseDb(wordsList);\n    }\n    private void destroyLoaders() {\n        LoaderManager loaderManager = getLoaderManager();\n        if (loaderManager!=null) {\n            loaderManager.destroyLoader(ROOM_DB_SEARCH_LOADER);\n            loaderManager.destroyLoader(JISHO_WEB_SEARCH_LOADER);\n        }\n    }\n    private void showLoadingIndicator() {\n        if (mProgressBarLoadingIndicator!=null) mProgressBarLoadingIndicator.setVisibility(View.VISIBLE);\n        if (mHintTextView!=null) mHintTextView.setVisibility(View.GONE);\n    }\n    private void hideLoadingIndicator() {\n        if (mProgressBarLoadingIndicator!=null) mProgressBarLoadingIndicator.setVisibility(View.INVISIBLE);\n    }\n\n\n    //Communication with other classes\n\n    //Communication with DictionaryRecyclerViewAdapter\n    @Override public void onWordLinkClicked(String text) {\n        dictionaryFragmentOperationsHandler.onQueryTextUpdateFromDictRequested(text);\n    }\n    @Override public void onVerbLinkClicked(String text) {\n        dictionaryFragmentOperationsHandler.onQueryTextUpdateFromDictRequested(text);\n        dictionaryFragmentOperationsHandler.onVerbConjugationFromDictRequested(text);\n    }\n\n    //Communication with parent activity\n    private DictionaryFragmentOperationsHandler dictionaryFragmentOperationsHandler;\n    interface DictionaryFragmentOperationsHandler {\n        void onQueryTextUpdateFromDictRequested(String selectedWordString);\n        void onVerbConjugationFromDictRequested(String selectedVerbString);\n        void onLocalMatchingWordsFound(List<Word> matchingWords);\n        void onFinalMatchingWordsFound(List<Word> matchingWords);\n    }\n    public void setQuery(String query) {\n        mInputQuery = query;\n        mAlreadyLoadedRoomResults = false;\n        mAlreadyLoadedJishoResults = false;\n        getQuerySearchResults();\n    }\n\n    //Communication with Firebase DAO\n    @Override public void onWordsListFound(List<Word> wordsList) {\n\n    }\n}"},
{"Line": "=>88", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["java.util.Map<java.lang.String, java.lang.Long>.get(count.getStatus())"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfNull]", "Content": "=>if (c == null) c = 0L;", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/469/buggy-version/src.main.java.com.feiliks.dashboard.spring.ConsolidationTask.java", "BodyUseAPI": [], "Fixed commit": "7721ea0dc1d538cdab5f459352e800f729a986c4", "Url": "https://api.github.com/repos/guzhiji/feili-dashboard", "Date": "2018-11-21T02:22:53Z", "Source Code Diff": "@@ -76,15 +76,22 @@ public void run() {\n \n         table = dao.getTable();\n \n-        Set<String> statusList = new HashSet<>(currentStats.keySet());\n+        Map<String, Long> cStats = new HashMap<>();\n+        // zero all status\n+        for (String status : currentStats.keySet())\n+            cStats.put(status, 0L);\n         for (ConsolidationDao.Status status : ConsolidationDao.Status.values())\n-            statusList.add(status.name());\n+            cStats.put(status.name(), 0L);\n+        // aggregate status counts\n         for (ConsolidationDao.StatusCount count : dao.getPie()) {\n-            statusList.remove(count.getStatus());\n-            currentStats.put(count.getStatus(), count.getCount());\n+            Long c = cStats.get(count.getStatus());\n+            if (c == null) c = 0L;\n+            c += count.getCount();\n+            cStats.put(count.getStatus(), c);\n         }\n-        for (String status : statusList)\n-            currentStats.put(status, 0L);\n+        // copy to currentStats\n+        for (Map.Entry<String, Long> entry : cStats.entrySet())\n+            currentStats.put(entry.getKey(), entry.getValue());\n \n         Map<Long, HourlyStats> groupByHour = new HashMap<>();\n         for (ConsolidationDao.TimelyStatusCount count : dao.getLine()) {", "Complete After Code": "package com.feiliks.dashboard.spring;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\n@Component\npublic class ConsolidationTask {\n\n    @Autowired\n    private WebSocketHandler webSocketHandler;\n\n    @Autowired\n    private ConsolidationDao dao;\n\n    public static class HourlyStats {\n        private long hour;\n        private Map<String, Long> data;\n\n        public HourlyStats() {\n        }\n\n        public HourlyStats(long hour, Map<String, Long> data) {\n            this.hour = hour;\n            this.data = data;\n        }\n\n        public long getHour() {\n            return hour;\n        }\n\n        public void setHour(long hour) {\n            this.hour = hour;\n        }\n\n        public Map<String, Long> getData() {\n            return data;\n        }\n\n        public void setData(Map<String, Long> data) {\n            this.data = data;\n        }\n    }\n\n    private List<HourlyStats> historicalStats = null;\n    private final Map<String, Long> currentStats = new HashMap<>();\n    private List<ConsolidationDao.OrderTrolley> table = null;\n\n    private static String stringifyStats(Map<String, Integer> stats) {\n        StringBuilder out = new StringBuilder();\n        for (Map.Entry<String, Integer> item : stats.entrySet())\n            out.append(item.getKey())\n                .append('=')\n                .append(item.getValue())\n                .append(';');\n        return out.toString();\n    }\n\n    public List<ConsolidationDao.OrderTrolley> getTable() {\n        return table;\n    }\n\n    public Map<String, Long> getCurrentStats() {\n        return currentStats;\n    }\n\n    public List<HourlyStats> getHistoricalStats() {\n        return historicalStats;\n    }\n\n    @Scheduled(fixedDelay = 5000)\n    public void run() {\n\n        table = dao.getTable();\n\n        Map<String, Long> cStats = new HashMap<>();\n        // zero all status\n        for (String status : currentStats.keySet())\n            cStats.put(status, 0L);\n        for (ConsolidationDao.Status status : ConsolidationDao.Status.values())\n            cStats.put(status.name(), 0L);\n        // aggregate status counts\n        for (ConsolidationDao.StatusCount count : dao.getPie()) {\n            Long c = cStats.get(count.getStatus());\n            if (c == null) c = 0L;\n            c += count.getCount();\n            cStats.put(count.getStatus(), c);\n        }\n        // copy to currentStats\n        for (Map.Entry<String, Long> entry : cStats.entrySet())\n            currentStats.put(entry.getKey(), entry.getValue());\n\n        Map<Long, HourlyStats> groupByHour = new HashMap<>();\n        for (ConsolidationDao.TimelyStatusCount count : dao.getLine()) {\n            HourlyStats stats = groupByHour.get(count.getTime());\n            if (stats == null) {\n                Map<String, Long> counts = new HashMap<>();\n                counts.put(count.getStatus(), count.getCount());\n                stats = new HourlyStats(count.getTime(), counts);\n                groupByHour.put(count.getTime(), stats);\n            } else {\n                stats.getData().put(count.getStatus(), count.getCount());\n            }\n        }\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        for (int h = cal.get(Calendar.HOUR_OF_DAY); h >= 0; h--) {\n            cal.set(Calendar.HOUR_OF_DAY, h);\n            long t = cal.getTimeInMillis();\n            HourlyStats stats = groupByHour.get(t);\n            if (stats == null) {\n                Map<String, Long> counts = new HashMap<>();\n                for (ConsolidationDao.Status status : ConsolidationDao.Status.values()) {\n                    if (status == ConsolidationDao.Status.OTHER) continue;\n                    counts.put(status.name(), 0L);\n                }\n                stats = new HourlyStats(t, counts);\n                groupByHour.put(t, stats);\n            } else {\n                for (ConsolidationDao.Status status : ConsolidationDao.Status.values()) {\n                    if (status == ConsolidationDao.Status.OTHER) continue;\n                    Map<String, Long> counts = stats.getData();\n                    if (!counts.containsKey(status.name()))\n                        counts.put(status.name(), 0L);\n                }\n            }\n        }\n        List<HourlyStats> sortedStats = new ArrayList<>(groupByHour.values());\n        Collections.sort(sortedStats, new Comparator<HourlyStats>() {\n            @Override\n            public int compare(HourlyStats a, HourlyStats b) {\n                return Long.compare(a.getHour(), b.getHour());\n            }\n        });\n        historicalStats = sortedStats;\n\n    }\n\n}\n\n"},
{"Line": "=>694", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["com.openexchange.groupware.calendar.CalendarDataObject.clone()"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if (c.containsLastModified()) { cdao.setLastModified(c.getLastModified()); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/396/buggy-version/com.openexchange.calendar.src.com.openexchange.calendar.CalendarSql.java", "BodyUseAPI": ["com.openexchange.groupware.calendar.CalendarDataObject.setLastModified(c.getLastModified())", "com.openexchange.groupware.calendar.CalendarDataObject.getLastModified()"], "Fixed commit": "d24eb39f115d63a8db1f3aa3724ec50f3c30f4d4", "Url": "https://api.github.com/repos/open-xchange/appsuite-middleware", "Date": "2012-11-05T15:14:14Z", "Source Code Diff": "@@ -691,6 +691,9 @@ public void deleteAppointmentObject(final CalendarDataObject cdao, final int inF\n                     DBUtils.startTransaction(writecon);\n                     final CalendarDataObject c = cdao.clone();\n                     cimp.deleteAppointment(session.getUserId(), c, writecon, session, ctx, inFolder, clientLastModified);\n+                    if (c.containsLastModified()) {\n+                        cdao.setLastModified(c.getLastModified());\n+                    }\n                     if (c.containsRecurrenceID()) {\n                         cdao.setRecurrenceID(c.getRecurrenceID());\n                     }", "Complete After Code": "/*\n *\n *    OPEN-XCHANGE legal information\n *\n *    All intellectual property rights in the Software are protected by\n *    international copyright laws.\n *\n *\n *    In some countries OX, OX Open-Xchange, open xchange and OXtender\n *    as well as the corresponding Logos OX Open-Xchange and OX are registered\n *    trademarks of the Open-Xchange, Inc. group of companies.\n *    The use of the Logos is not covered by the GNU General Public License.\n *    Instead, you are allowed to use these Logos according to the terms and\n *    conditions of the Creative Commons License, Version 2.5, Attribution,\n *    Non-commercial, ShareAlike, and the interpretation of the term\n *    Non-commercial applicable to the aforementioned license is published\n *    on the web site http://www.open-xchange.com/EN/legal/index.html.\n *\n *    Please make sure that third-party modules and libraries are used\n *    according to their respective licenses.\n *\n *    Any modifications to this package must retain all copyright notices\n *    of the original copyright holder(s) for the original code used.\n *\n *    After any such modifications, the original and derivative code shall remain\n *    under the copyright of the copyright holder(s) and/or original author(s)per\n *    the Attribution and Assignment Agreement that can be located at\n *    http://www.open-xchange.com/EN/developer/. The contributing author shall be\n *    given Attribution for the derivative code and a license granting use.\n *\n *     Copyright (C) 2004-2012 Open-Xchange, Inc.\n *     Mail: info@open-xchange.com\n *\n *\n *     This program is free software; you can redistribute it and/or modify it\n *     under the terms of the GNU General Public License, Version 2 as published\n *     by the Free Software Foundation.\n *\n *     This program is distributed in the hope that it will be useful, but\n *     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n *     or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n *     for more details.\n *\n *     You should have received a copy of the GNU General Public License along\n *     with this program; if not, write to the Free Software Foundation, Inc., 59\n *     Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n */\n\npackage com.openexchange.calendar;\n\nimport static com.openexchange.java.Autoboxing.I;\nimport static com.openexchange.java.Autoboxing.I2i;\nimport java.sql.BatchUpdateException;\nimport java.sql.Connection;\nimport java.sql.DataTruncation;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport org.apache.commons.logging.Log;\nimport com.openexchange.log.LogFactory;\nimport com.openexchange.api2.AppointmentSQLInterface;\nimport com.openexchange.calendar.api.CalendarCollection;\nimport com.openexchange.configuration.ConfigurationException;\nimport com.openexchange.exception.OXException;\nimport com.openexchange.groupware.calendar.CalendarConfig;\nimport com.openexchange.groupware.calendar.CalendarDataObject;\nimport com.openexchange.groupware.calendar.CalendarFolderObject;\nimport com.openexchange.groupware.calendar.Constants;\nimport com.openexchange.groupware.calendar.OXCalendarExceptionCodes;\nimport com.openexchange.groupware.container.Appointment;\nimport com.openexchange.groupware.container.CalendarObject;\nimport com.openexchange.groupware.container.FolderObject;\nimport com.openexchange.groupware.container.Participant;\nimport com.openexchange.groupware.container.UserParticipant;\nimport com.openexchange.groupware.contexts.Context;\nimport com.openexchange.groupware.data.Check;\nimport com.openexchange.groupware.ldap.User;\nimport com.openexchange.groupware.ldap.UserStorage;\nimport com.openexchange.groupware.search.AppointmentSearchObject;\nimport com.openexchange.groupware.search.Order;\nimport com.openexchange.groupware.userconfiguration.UserConfiguration;\nimport com.openexchange.groupware.userconfiguration.UserConfigurationStorage;\nimport com.openexchange.java.Charsets;\nimport com.openexchange.server.impl.DBPool;\nimport com.openexchange.server.impl.EffectivePermission;\nimport com.openexchange.session.Session;\nimport com.openexchange.tools.StringCollection;\nimport com.openexchange.tools.exceptions.SimpleTruncatedAttribute;\nimport com.openexchange.tools.iterator.SearchIterator;\nimport com.openexchange.tools.iterator.SearchIteratorAdapter;\nimport com.openexchange.tools.iterator.SearchIteratorException;\nimport com.openexchange.tools.oxfolder.OXFolderAccess;\nimport com.openexchange.tools.sql.DBUtils;\n\n/**\n * {@link CalendarSql} - The implementation of {@link AppointmentSQLInterface}.\n *\n * @author <a href=\"mailto:martin.kauss@open-xchange.org\">Martin Kauss</a>\n * @author <a href=\"mailto:tobias.prinz@open-xchange.com\">Tobias Prinz</a> (some refactoring)\n */\npublic class CalendarSql implements AppointmentSQLInterface {\n\n    public static final String default_class = \"com.openexchange.calendar.CalendarMySQL\";\n\n    public static final String ERROR_PUSHING_DATABASE = \"error pushing readable connection\";\n\n    public static final String ERROR_PUSHING_WRITEABLE_CONNECTION = \"error pushing writeable connection\";\n\n    public static final String DATES_TABLE_NAME = \"prg_dates\";\n\n    public static final String VIEW_TABLE_NAME = \"prg_date_rights\";\n\n    public static final String PARTICIPANT_TABLE_NAME = \"prg_dates_members\";\n\n    private static volatile CalendarSqlImp cimp;\n\n    private final Session session;\n\n    private final CalendarCollection recColl;\n\n    private boolean includePrivateAppointments;\n\n    private static final Log LOG = com.openexchange.log.Log.valueOf(LogFactory.getLog(CalendarSql.class));\n\n    /**\n     * Initializes a new {@link CalendarSql}.\n     *\n     * @param session The session providing needed user data\n     */\n    public CalendarSql(final Session session) {\n        this.session = session;\n        this.recColl = new CalendarCollection();\n    }\n\n    @Override\n    public boolean[] hasAppointmentsBetween(final Date d1, final Date d2) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfiguration = Tools.getUserConfiguration(ctx, session.getUserId());\n        Connection readcon = null;\n        try {\n            readcon = DBPool.pickup(ctx);\n            return cimp.getUserActiveAppointmentsRangeSQL(ctx, session.getUserId(), user.getGroups(), userConfiguration, d1, d2, readcon);\n        } catch (final OXException e) {\n            // Don't mask OX exceptions in a SQL exception.\n            throw e;\n        } catch(final SQLException e) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e);\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e);\n        } finally {\n            if (readcon != null) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public SearchIterator<Appointment> getAppointmentsBetweenInFolder(final int fid, final int[] cols, final Date start, final Date end, final int orderBy, final Order orderDir) throws OXException, SQLException {\n        return getAppointmentsBetweenInFolder(fid, cols, start, end, 0, 0, orderBy, orderDir);\n    }\n\n\n    @Override\n    public SearchIterator<Appointment> getAppointmentsBetweenInFolder(final int fid, int[] cols, final Date start, final Date end, final int from, final int to, final int orderBy, final Order orderDir) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final OXFolderAccess ofa = new OXFolderAccess(readcon, ctx);\n            final int folderType = ofa.getFolderType(fid, session.getUserId());\n            final CalendarOperation co = new CalendarOperation();\n            final EffectivePermission oclp = ofa.getFolderPermission(fid, session.getUserId(), userConfig);\n\n            mayRead(oclp);\n\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            if (folderType == FolderObject.PRIVATE) {\n                prep = cimp.getPrivateFolderRangeSQL(ctx, session.getUserId(), user.getGroups(), fid, start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, orderBy, orderDir);\n            } else if (folderType == FolderObject.PUBLIC) {\n                prep = cimp.getPublicFolderRangeSQL(ctx, session.getUserId(), user.getGroups(), fid, start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, orderBy, orderDir);\n            } else {\n                final int shared_folder_owner = ofa.getFolderOwner(fid);\n                prep = cimp.getSharedFolderRangeSQL(ctx, session.getUserId(), shared_folder_owner, user.getGroups(), fid, start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, orderBy, orderDir, doesIncludePrivateAppointments());\n            }\n\n            rs = cimp.getResultSet(prep);\n            co.setRequestedFolder(fid);\n            co.setResultSet(rs, prep, cols, cimp, readcon, from, to, session, ctx);\n            close_connection = false;\n            return new AppointmentIteratorAdapter(new AnonymizingIterator(co, ctx, session.getUserId()));\n\n        } catch (final IndexOutOfBoundsException ioobe) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(ioobe, Integer.valueOf(19));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(20));\n        } finally  {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    /**\n     * @return\n     */\n    private boolean doesIncludePrivateAppointments() {\n        return includePrivateAppointments;\n    }\n\n    @Override\n    public SearchIterator<Appointment> getModifiedAppointmentsInFolder(final int fid, final Date start, final Date end, int[] cols, final Date since) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final OXFolderAccess ofa = new OXFolderAccess(readcon, ctx);\n            final int folderType = ofa.getFolderType(fid, session.getUserId());\n            final CalendarOperation co = new CalendarOperation();\n            final EffectivePermission oclp = ofa.getFolderPermission(fid, session.getUserId(), userConfig);\n            final int shared_folder_owner = ofa.getFolderOwner(fid);\n            mayRead(oclp);\n\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            if (folderType == FolderObject.PRIVATE) {\n                prep = cimp.getPrivateFolderModifiedSinceSQL(ctx, session.getUserId(), user.getGroups(), fid, since, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, start, end);\n            } else if (folderType == FolderObject.PUBLIC) {\n                prep = cimp.getPublicFolderModifiedSinceSQL(ctx, session.getUserId(), user.getGroups(), fid, since, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, start, end);\n            } else {\n                prep = cimp.getSharedFolderModifiedSinceSQL(ctx, session.getUserId(), shared_folder_owner, user.getGroups(), fid, since, StringCollection.getSelect(cols, DATES_TABLE_NAME), oclp.canReadAllObjects(), readcon, start, end, !this.includePrivateAppointments);\n            }\n            rs = cimp.getResultSet(prep);\n            co.setRequestedFolder(fid);\n            co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n            close_connection = false;\n            if(includePrivateAppointments) {\n                return new AppointmentIteratorAdapter(new AnonymizingIterator(co, ctx, session.getUserId()));\n            }\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n        } catch (final IndexOutOfBoundsException ioobe) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(ioobe, I(21));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(22));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    private void mayRead(final EffectivePermission oclp) throws OXException {\n        if (!oclp.canReadAllObjects() && !oclp.canReadOwnObjects()) {\n            throw OXCalendarExceptionCodes.NO_PERMISSION.create(I(oclp.getFuid()));\n        }\n    }\n\n    @Override\n    public SearchIterator<Appointment> getModifiedAppointmentsInFolder(final int fid, final int cols[], final Date since) throws OXException {\n        return getModifiedAppointmentsInFolder(fid, null, null, cols, since);\n    }\n\n    @Override\n    public SearchIterator<Appointment> getDeletedAppointmentsInFolder(final int fid, int cols[], final Date since) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final OXFolderAccess ofa = new OXFolderAccess(readcon, ctx);\n            final EffectivePermission oclp = ofa.getFolderPermission(fid, session.getUserId(), userConfig);\n            mayRead(oclp);\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                final CalendarOperation co = new CalendarOperation();\n                prep = cimp.getPrivateFolderDeletedSinceSQL(ctx, session.getUserId(), fid, since, StringCollection.getSelect(cols, \"del_dates\"), readcon);\n                rs = cimp.getResultSet(prep);\n                co.setRequestedFolder(fid);\n                co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n                close_connection = false;\n                return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n            } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                final CalendarOperation co = new CalendarOperation();\n                prep = cimp.getPublicFolderDeletedSinceSQL(ctx, session.getUserId(), fid, since, StringCollection.getSelect(cols, \"del_dates\"), readcon);\n                rs = cimp.getResultSet(prep);\n                co.setRequestedFolder(fid);\n                co.setResultSet(rs, prep,cols, cimp, readcon, 0, 0, session, ctx);\n                close_connection = false;\n                return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n            } else {\n                final CalendarOperation co = new CalendarOperation();\n                final int shared_folder_owner = ofa.getFolderOwner(fid);\n                prep = cimp.getSharedFolderDeletedSinceSQL(ctx, session.getUserId(), shared_folder_owner, fid, since, StringCollection.getSelect(cols, \"del_dates\"), readcon);\n                rs = cimp.getResultSet(prep);\n                co.setRequestedFolder(fid);\n                co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n                close_connection = false;\n                return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n            }\n        } catch (final IndexOutOfBoundsException ioobe) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(ioobe, Integer.valueOf(23));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(24));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public CalendarDataObject getObjectById(final int oid) throws OXException, SQLException {\n        return getObjectById(oid, 0, null, false);\n    }\n\n    @Override\n    public CalendarDataObject getObjectById(final int oid, final int inFolder) throws OXException, SQLException {\n        return getObjectById(oid, inFolder, null, true);\n    }\n\n    /**\n     * Gets the appointment denoted by specified object ID in given folder\n     *\n     * @param oid The object ID\n     * @param inFolder The folder ID\n     * @param readcon A connection with read capability (leave to <code>null</code> to fetch from pool)\n     * @return The appointment object\n     * @throws OXException\n     * @throws OXObjectNotFoundException\n     * @throws OXPermissionException\n     */\n    private CalendarDataObject getObjectById(final int oid, final int inFolder, final Connection readcon, final boolean checkPermissions) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection rcon = readcon;\n        boolean closeRead = false;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        final Context ctx = Tools.getContext(session);\n        try {\n            if (rcon == null) {\n                rcon = DBPool.pickup(ctx);\n                closeRead = true;\n            }\n            final CalendarOperation co = new CalendarOperation();\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            prep = cimp.getPreparedStatement(rcon, cimp.loadAppointment(oid, ctx));\n            rs = cimp.getResultSet(prep);\n            final CalendarDataObject cdao = co.loadAppointment(rs, oid, inFolder, cimp, rcon, session, ctx, CalendarOperation.READ, inFolder, checkPermissions);\n            recColl.safelySetStartAndEndDateForRecurringAppointment(cdao);\n            return cdao;\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } finally {\n            recColl.closeResultSet(rs);\n            recColl.closePreparedStatement(prep);\n            if (closeRead && rcon != null) {\n                DBPool.push(ctx, rcon);\n            }\n        }\n    }\n\n    @Override\n    public CalendarDataObject[] insertAppointmentObject(final CalendarDataObject cdao) throws OXException {\n        RecurrenceChecker.check(cdao);\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection writecon = null;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            final CalendarOperation co = new CalendarOperation();\n            if (cdao.containsRecurrenceType()) {\n                recColl.checkRecurring(cdao);\n            }\n            if (co.prepareUpdateAction(cdao, null, session.getUserId(), cdao.getParentFolderID(), user.getTimeZone())) {\n                try {\n                    final OXFolderAccess ofa = new OXFolderAccess(ctx);\n                    final EffectivePermission oclp = ofa.getFolderPermission(cdao.getEffectiveFolderId(), session.getUserId(), userConfig);\n                    if (oclp.canCreateObjects()) {\n                        recColl.checkForInvalidCharacters(cdao);\n                        cdao.setActionFolder(cdao.getParentFolderID());\n                        writecon = DBPool.pickupWriteable(ctx);\n                        writecon.setAutoCommit(false);\n                        final ConflictHandler ch = new ConflictHandler(cdao, null, session, true);\n                        final CalendarDataObject conflicts[] = ch.getConflicts();\n                        if (conflicts.length == 0) {\n                            return cimp.insertAppointment(cdao, writecon, session);\n                        }\n                        return conflicts;\n                    }\n                    throw OXCalendarExceptionCodes.LOAD_PERMISSION_EXCEPTION_6.create();\n                } catch(final DataTruncation dt) {\n                    final String fields[] = DBUtils.parseTruncatedFields(dt);\n                    final int fid[] = new int[fields.length];\n                    final OXException oxe = OXCalendarExceptionCodes.TRUNCATED_SQL_ERROR.create();\n                    int id = -1;\n                    for (int a = 0; a < fid.length; a++) {\n                        id = recColl.getFieldId(fields[a]);\n                        final String value = recColl.getString(cdao, id);\n                        if(value == null) {\n                            oxe.addTruncatedId(id);\n                        } else {\n                            final int valueLength = Charsets.getBytes(value, Charsets.UTF_8).length;\n                            final int maxLength = DBUtils.getColumnSize(writecon, \"prg_dates\", fields[a]);\n                            oxe.addProblematic(new SimpleTruncatedAttribute(id, maxLength, valueLength, value));\n                        }\n                    }\n                    throw oxe;\n                } catch(final SQLException sqle) {\n                    try {\n                        if (!writecon.getAutoCommit()) {\n                            writecon.rollback();\n                        }\n                    } catch(final SQLException rb) {\n                        LOG.error(\"Rollback failed: \" + rb.getMessage(), rb);\n                    }\n                    throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n                } finally {\n                    if (writecon != null) {\n                        writecon.setAutoCommit(true);\n                    }\n                }\n            }\n            throw OXCalendarExceptionCodes.INSERT_WITH_OBJECT_ID.create();\n        } catch(final DataTruncation dt) {\n            final String fields[] = DBUtils.parseTruncatedFields(dt);\n            final int fid[] = new int[fields.length];\n            final OXException oxe = OXCalendarExceptionCodes.TRUNCATED_SQL_ERROR.create(dt, new Object[0]);\n            int id = -1;\n            for (int a = 0; a < fid.length; a++) {\n                id = recColl.getFieldId(fields[a]);\n                final String value = recColl.getString(cdao, id);\n                if(value == null) {\n                    oxe.addTruncatedId(id);\n                } else {\n                    final int valueLength = Charsets.getBytes(value, Charsets.UTF_8).length;\n                    int maxLength = 0;\n                    try {\n                        maxLength = DBUtils.getColumnSize(writecon, \"prg_dates\", fields[a]);\n                        oxe.addProblematic(new SimpleTruncatedAttribute(id, maxLength, valueLength));\n                    } catch (final SQLException e) {\n                        LOG.error(e.getMessage(), e);\n                        oxe.addTruncatedId(id);\n                    }\n                }\n            }\n            throw oxe;\n        } catch (final SQLException sqle) {\n            final OXException exception = OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n            LOG.error(\"Additioal info for: \"+exception.getExceptionId()+\": \"+sqle.getMessage(), sqle);\n            throw exception;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(25));\n        } finally {\n            if (writecon != null) {\n                DBPool.pushWrite(ctx, writecon);\n            }\n        }\n    }\n\n    @Override\n    public CalendarDataObject[] updateAppointmentObject(final CalendarDataObject cdao, final int inFolder, final Date clientLastModified) throws OXException {\n        return updateAppointmentObject(cdao, inFolder, clientLastModified, true);\n    }\n\n    @Override\n    public CalendarDataObject[] updateAppointmentObject(final CalendarDataObject cdao, final int inFolder, final Date clientLastModified, final boolean checkPermissions) throws OXException {\n        RecurrenceChecker.check(cdao);\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection writecon = null;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        try {\n            writecon = DBPool.pickupWriteable(ctx);\n\n            final CalendarOperation co = new CalendarOperation();\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            final CalendarDataObject edao = cimp.loadObjectForUpdate(cdao, session, ctx, inFolder, writecon, checkPermissions);\n            \n            if (cdao.isIgnoreOutdatedSequence() && cdao.getSequence() < edao.getSequence()) {\n                // Silently ignore updates on Appointments with an outdated Sequence. OLOX2-Requirement.\n                cdao.setLastModified(edao.getLastModified());\n                LOG.info(\"Ignored update on Appointment due to outdated sequence: \" + edao.getContextID() + \"-\" + edao.getObjectID() + \" (cid-objectId)\");\n                return null;\n            }\n            \n            if (co.prepareUpdateAction(cdao, edao, session.getUserId(), inFolder, user.getTimeZone())) {\n                // Insert-through-update detected\n                throw OXCalendarExceptionCodes.UPDATE_WITHOUT_OBJECT_ID.create();\n            }\n            recColl.checkForInvalidCharacters(cdao);\n            final CalendarDataObject[] conflicts;\n            {\n                final CalendarDataObject conflict_dao = recColl.fillFieldsForConflictQuery(cdao, edao, false);\n                final ConflictHandler ch = new ConflictHandler(conflict_dao, edao, session, false);\n                conflicts = ch.getConflicts();\n            }\n            if (conflicts.length == 0) {\n                // Check user participants completeness\n                if (cdao.containsUserParticipants()) {\n                    final UserParticipant[] edaoUsers = edao.getUsers();\n                    final List<UserParticipant> origUsers = Arrays.asList(edaoUsers);\n\n                    for (final UserParticipant cur : cdao.getUsers()) {\n                        if (cur.containsAlarm() && cur.containsConfirm()) {\n                            continue;\n                        }\n\n                        // Get corresponding user from edao\n                        final int index = origUsers.indexOf(cur);\n                        if (index != -1) {\n                            final UserParticipant origUser = origUsers.get(index);\n                            if (!cur.containsConfirm()) {\n                                cur.setConfirm(origUser.getConfirm());\n                            }\n                            if (!cur.containsAlarm()) {\n                                cur.setAlarmMinutes(origUser.getAlarmMinutes());\n                            }\n                        }\n                    }\n                }\n\n                try {\n                    writecon.setAutoCommit(false);\n                    if (cdao.containsParentFolderID()) {\n                        cdao.setActionFolder(cdao.getParentFolderID());\n                    } else {\n                        cdao.setActionFolder(inFolder);\n                    }\n                    return cimp.updateAppointment(cdao, edao, writecon, session, ctx, inFolder, clientLastModified);\n                } catch(final DataTruncation dt) {\n                    throwTruncationError(cdao, writecon, dt);\n                } catch(final BatchUpdateException bue) {\n                    if (bue.getCause() instanceof DataTruncation) {\n                        throwTruncationError(cdao, writecon, (DataTruncation) bue.getCause());\n                    } else {\n                        throw bue;\n                    }\n                } catch(final SQLException sqle) {\n                    try {\n                        if (writecon != null) {\n                            writecon.rollback();\n                        }\n                    } catch(final SQLException rb) {\n                        LOG.error(\"Rollback failed: \" + rb.getMessage(), rb);\n                    }\n                    throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n                } finally {\n                    if (writecon != null) {\n                        writecon.setAutoCommit(true);\n                    }\n                }\n            }\n            return conflicts;\n        } catch(final DataTruncation dt) {\n            final String fields[] = DBUtils.parseTruncatedFields(dt);\n            final int fid[] = new int[fields.length];\n            final OXException oxe = OXCalendarExceptionCodes.TRUNCATED_SQL_ERROR.create(dt, new Object[0]);\n            int id = -1;\n            for (int a = 0; a < fid.length; a++) {\n                id = recColl.getFieldId(fields[a]);\n                final String value = recColl.getString(cdao, id);\n                if(value == null) {\n                    oxe.addTruncatedId(id);\n                } else {\n                    final int valueLength = Charsets.getBytes(value, Charsets.UTF_8).length;\n                    int maxLength = 0;\n                    try {\n                        maxLength = DBUtils.getColumnSize(writecon, \"prg_dates\", fields[a]);\n                        oxe.addProblematic(new SimpleTruncatedAttribute(id, maxLength, valueLength));\n                    } catch (final SQLException e) {\n                        LOG.error(e.getMessage(), e);\n                        oxe.addTruncatedId(id);\n                    }\n\n                }\n            }\n            throw oxe;\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxe) {\n            throw oxe;\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(26));\n        } finally {\n            if (writecon != null) {\n                DBPool.pushWrite(ctx, writecon);\n            }\n        }\n    }\n\n    /**\n     * @param cdao\n     * @param writecon\n     * @param dt\n     * @throws SQLException\n     * @throws OXException\n     */\n    private void throwTruncationError(final CalendarDataObject cdao, final Connection writecon, final DataTruncation dt) throws SQLException, OXException {\n        final String fields[] = DBUtils.parseTruncatedFields(dt);\n        final int fid[] = new int[fields.length];\n        final OXException oxe = OXCalendarExceptionCodes.TRUNCATED_SQL_ERROR.create(dt, new Object[0]);\n        int id = -1;\n        for (int a = 0; a < fid.length; a++) {\n            id = recColl.getFieldId(fields[a]);\n            final String value = recColl.getString(cdao, id);\n            if(value == null) {\n                oxe.addTruncatedId(id);\n            } else {\n                final int valueLength = Charsets.getBytes(value, Charsets.UTF_8).length;\n                final int maxLength = DBUtils.getColumnSize(writecon, \"prg_dates\", fields[a]);\n                oxe.addProblematic(new SimpleTruncatedAttribute(id, maxLength, valueLength));\n            }\n        }\n        throw oxe;\n    }\n\n    @Override\n    public void deleteAppointmentObject(final CalendarDataObject cdao, final int inFolder, final Date clientLastModified) throws OXException {\n        deleteAppointmentObject(cdao, inFolder, clientLastModified, true);\n    }\n\n    @Override\n    public void deleteAppointmentObject(final CalendarDataObject cdao, final int inFolder, final Date clientLastModified, final boolean checkPermissions) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        try {\n            final DBUtils.TransactionRollbackCondition condition = new DBUtils.TransactionRollbackCondition(3);\n            do {\n                final Context ctx = Tools.getContext(session);\n                final Connection writecon = DBPool.pickupWriteable(ctx);\n                condition.resetTransactionRollbackException();\n                try  {\n                    DBUtils.startTransaction(writecon);\n                    final CalendarDataObject c = cdao.clone();\n                    cimp.deleteAppointment(session.getUserId(), c, writecon, session, ctx, inFolder, clientLastModified);\n                    if (c.containsLastModified()) {\n                        cdao.setLastModified(c.getLastModified());\n                    }\n                    if (c.containsRecurrenceID()) {\n                        cdao.setRecurrenceID(c.getRecurrenceID());\n                    }\n                    writecon.commit();\n                } catch(final OXException oxc) {\n                    DBUtils.rollback(writecon);\n                    if (!condition.isFailedTransactionRollback(oxc)) {\n                        throw oxc;\n                    }\n                } catch(final SQLException e) {\n                    DBUtils.rollback(writecon);\n                    if (!condition.isFailedTransactionRollback(e)) {\n                        throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e, Integer.valueOf(28));\n                    }\n                } catch(final RuntimeException e) {\n                    DBUtils.rollback(writecon);\n                    if (!condition.isFailedTransactionRollback(e)) {\n                        throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(1337));\n                    }\n                } finally {\n                    DBUtils.autocommit(writecon);\n                    DBPool.pushWrite(ctx, writecon);\n                }\n            } while (condition.checkRetry());\n        } catch (final SQLException e) {\n            if (DBUtils.isTransactionRollbackException(e)) {\n                throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR_RETRY.create(e, Integer.valueOf(28));\n            }\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e, Integer.valueOf(28));\n        }\n    }\n\n    @Override\n    public void deleteAppointmentsInFolder(final int fid) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        Connection writecon = null;\n        try {\n            writecon = DBPool.pickupWriteable(ctx);\n            deleteAppointmentsInFolder(fid, writecon);\n        } finally {\n            if (writecon != null) {\n                DBPool.pushWrite(ctx, writecon);\n            }\n        }\n    }\n\n    @Override\n    public void deleteAppointmentsInFolder(final int fid, final Connection writeCon) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        final Context ctx = Tools.getContext(session);\n        try  {\n            try {\n                final OXFolderAccess ofa = new OXFolderAccess(writeCon, ctx);\n                final CalendarSqlImp cimp = CalendarSql.cimp;\n                if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                    prep = cimp.getPrivateFolderObjects(fid, ctx, writeCon);\n                    rs = cimp.getResultSet(prep);\n                    cimp.deleteAppointmentsInFolder(session, ctx, rs, writeCon, writeCon, FolderObject.PRIVATE, fid);\n                } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                    prep = cimp.getPublicFolderObjects(fid, ctx, writeCon);\n                    rs = cimp.getResultSet(prep);\n                    cimp.deleteAppointmentsInFolder(session, ctx, rs, writeCon, writeCon, FolderObject.PUBLIC, fid);\n                } else {\n                    throw OXCalendarExceptionCodes.FOLDER_DELETE_INVALID_REQUEST.create();\n                }\n            } catch(final SQLException sqle) {\n                throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n            }\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(29));\n        } finally {\n            recColl.closeResultSet(rs);\n            recColl.closePreparedStatement(prep);\n        }\n    }\n\n    @Override\n    public boolean checkIfFolderContainsForeignObjects(final int uid, final int fid) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        final Context ctx = Tools.getContext(session);\n        try {\n            readcon = DBPool.pickup(ctx);\n            final OXFolderAccess ofa = new OXFolderAccess(readcon, ctx);\n            if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                return cimp.checkIfFolderContainsForeignObjects(uid, fid, ctx, readcon, FolderObject.PRIVATE);\n            } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                return cimp.checkIfFolderContainsForeignObjects(uid, fid, ctx, readcon, FolderObject.PUBLIC);\n            } else {\n                throw OXCalendarExceptionCodes.FOLDER_FOREIGN_INVALID_REQUEST.create();\n            }\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(30));\n        } finally {\n            if (readcon != null) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public boolean checkIfFolderContainsForeignObjects(final int uid, final int fid, final Connection readCon) throws OXException,\n            SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        try {\n            final OXFolderAccess ofa = new OXFolderAccess(readCon, ctx);\n            if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                return cimp.checkIfFolderContainsForeignObjects(uid, fid, ctx, readCon, FolderObject.PRIVATE);\n            } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                return cimp.checkIfFolderContainsForeignObjects(uid, fid, ctx, readCon, FolderObject.PUBLIC);\n            } else {\n                throw OXCalendarExceptionCodes.FOLDER_FOREIGN_INVALID_REQUEST.create();\n            }\n        } catch (final OXException oxc) {\n            throw oxc;\n        } catch (final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(30));\n        }\n    }\n\n    @Override\n    public boolean isFolderEmpty(final int uid, final int fid) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        final Context ctx = Tools.getContext(session);\n        try {\n            readcon = DBPool.pickup(ctx);\n            final OXFolderAccess ofa = new OXFolderAccess(readcon, ctx);\n            if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                return cimp.checkIfFolderIsEmpty(uid, fid, ctx, readcon, FolderObject.PRIVATE);\n            } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                return cimp.checkIfFolderIsEmpty(uid, fid, ctx, readcon, FolderObject.PUBLIC);\n            } else {\n                throw OXCalendarExceptionCodes.FOLDER_IS_EMPTY_INVALID_REQUEST.create();\n            }\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(31));\n        } finally {\n            if (readcon != null) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public boolean isFolderEmpty(final int uid, final int fid, final Connection readCon) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        try {\n            final OXFolderAccess ofa = new OXFolderAccess(readCon, ctx);\n            if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PRIVATE) {\n                return cimp.checkIfFolderIsEmpty(uid, fid, ctx, readCon, FolderObject.PRIVATE);\n            } else if (ofa.getFolderType(fid, session.getUserId()) == FolderObject.PUBLIC) {\n                return cimp.checkIfFolderIsEmpty(uid, fid, ctx, readCon, FolderObject.PUBLIC);\n            } else {\n                throw OXCalendarExceptionCodes.FOLDER_IS_EMPTY_INVALID_REQUEST.create();\n            }\n        } catch (final OXException oxc) {\n            throw oxc;\n        } catch (final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch (final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(31));\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see com.openexchange.api2.AppointmentSQLInterface#setUserConfirmation(int, int, int, java.lang.String)\n     */\n    @Override\n    public Date setUserConfirmation(final int oid, final int folderId, final int uid, final int confirm, final String confirm_message) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        if (confirm_message != null) {\n            String error = null;\n            error = Check.containsInvalidChars(confirm_message);\n            if (error != null) {\n                throw OXCalendarExceptionCodes.INVALID_CHARACTER.create(\"Confirm Message\", error);\n            }\n        }\n        return cimp.setUserConfirmation(oid, folderId, uid, confirm, confirm_message, session, ctx);\n    }\n\n    @Override\n    public Date setExternalConfirmation(final int oid, final int folderId, final String mail, final int confirm, final String message) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        if (message != null) {\n            String error = null;\n            error = Check.containsInvalidChars(message);\n            if (error != null) {\n                throw OXCalendarExceptionCodes.INVALID_CHARACTER.create(\"Confirm Message\", error);\n            }\n        }\n        return cimp.setExternalConfirmation(oid, folderId, mail, confirm, message, session, ctx);\n    }\n\n    @Override\n    public SearchIterator<Appointment> getObjectsById(final int[][] oids, int[] cols) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        if (oids.length > 0) {\n            Connection readcon = null;\n            PreparedStatement prep = null;\n            ResultSet rs = null;\n            boolean close_connection = true;\n            final Context ctx = Tools.getContext(session);\n            try {\n                readcon = DBPool.pickup(ctx);\n                cols = recColl.checkAndAlterCols(cols);\n                final CalendarOperation co = new CalendarOperation();\n                final CalendarSqlImp cimp = CalendarSql.cimp;\n                prep = cimp.getPreparedStatement(readcon, cimp.getObjectsByidSQL(oids, session.getContextId(), StringCollection.getSelect(cols, DATES_TABLE_NAME)));\n                rs = cimp.getResultSet(prep);\n                co.setOIDS(true, oids);\n                co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n                close_connection = false;\n                return new AppointmentIteratorAdapter(new AnonymizingIterator(co, ctx, session.getUserId(), oids));\n            } catch(final SQLException sqle) {\n                throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n            } catch(final OXException oxc) {\n                throw oxc;\n            } catch(final RuntimeException e) {\n                throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(32));\n            } finally {\n                if (readcon != null && close_connection) {\n                    recColl.closeResultSet(rs);\n                    recColl.closePreparedStatement(prep);\n                    DBPool.push(ctx, readcon);\n                }\n            }\n        }\n        return SearchIteratorAdapter.emptyIterator();\n    }\n\n    @Override\n    public SearchIterator<Appointment> getAppointmentsByExtendedSearch(final AppointmentSearchObject searchobject, final int orderBy, final Order orderDir, final int cols[]) throws OXException, SQLException {\n        return getAppointmentsByExtendedSearch(searchobject, orderBy, orderDir, cols, 0, 0);\n    }\n\n    @Override\n    public SearchIterator<Appointment> searchAppointments(final AppointmentSearchObject searchObj, final int orderBy, final Order orderDir, int[] cols) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        cols = recColl.checkAndAlterCols(cols);\n\n        final Connection readcon = DBPool.pickup(ctx);\n\n        boolean closeCon = true;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            final OXFolderAccess folderAccess = new OXFolderAccess(readcon, ctx);\n            final CalendarOperation co = new CalendarOperation();\n\n            CalendarFolderObject cfo = null;\n            if (searchObj.hasFolders()) {\n                final int folderId = searchObj.getFolders()[0];\n                final EffectivePermission folderPermission = folderAccess.getFolderPermission(folderId, user.getId(), userConfig);\n\n                if (folderPermission.isFolderVisible() && (folderPermission.canReadAllObjects() || folderPermission.canReadOwnObjects())) {\n                    co.setRequestedFolder(folderId);\n                } else {\n                    throw OXCalendarExceptionCodes.NO_PERMISSIONS_TO_READ.create();\n                }\n            } else {\n                // Missing folder attribute indicates a search over all calendar folders the user can see,\n                // so create a list with all folders in which the user is allowed to see appointments\n                try {\n                    cfo = recColl.getAllVisibleAndReadableFolderObject(user.getId(), user.getGroups(), ctx, userConfig, readcon);\n                } catch (final SQLException e) {\n                    throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e);\n                }\n\n//                final int ara[] = new int[1];\n//                ara[0] = Appointment.PARTICIPANTS;\n//                cols = recColl.enhanceCols(cols, ara, 1);\n            }\n\n            final StringBuilder columnBuilder = new StringBuilder();\n            boolean first = true;\n            for (int i = 0; i < cols.length; i++) {\n                final String temp = recColl.getFieldName(cols[i]);\n\n                if (temp != null) {\n                    if (first) {\n                        columnBuilder.append(temp);\n                        first = false;\n                    } else {\n                        columnBuilder.append(',');\n                        columnBuilder.append(temp);\n                    }\n                }\n            }\n\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            stmt = cimp.getSearchStatement(user.getId(), searchObj, cfo, folderAccess, columnBuilder.toString(), orderBy, orderDir, ctx, readcon);\n            rs = cimp.getResultSet(stmt);\n            co.setResultSet(rs, stmt, cols, cimp, readcon, 0, 0, session, ctx);\n\n            // Don't close connection, it's used within the SearchIterator\n            closeCon = false;\n\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(cfo, co, ctx, session.getUserId()));\n        } catch (final SQLException e) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e);\n        } finally {\n            if (stmt != null) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(stmt);\n            }\n\n            if (closeCon && readcon != null) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    private SearchIterator<Appointment> getAppointmentsByExtendedSearch(final AppointmentSearchObject searchobject, final int orderBy, final Order orderDir, int cols[], final int from, final int to) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Search.checkPatternLength(searchobject);\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            final CalendarOperation co = new CalendarOperation();\n            if (searchobject.getFolder() > 0) {\n                co.setRequestedFolder(searchobject.getFolder());\n            } else {\n                final int ara[] = new int[1];\n                ara[0] = CalendarObject.PARTICIPANTS;\n                cols = recColl.enhanceCols(cols, ara, 1);\n            }\n            cols = recColl.checkAndAlterCols(cols);\n            CalendarFolderObject cfo = null;\n            try {\n                cfo = recColl.getAllVisibleAndReadableFolderObject(session.getUserId(), user.getGroups(), ctx, userConfig);\n            } catch (final SearchIteratorException sie) {\n                throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(sie, Integer.valueOf(1));\n            }\n            readcon = DBPool.pickup(ctx);\n            final int userId;\n            final int[] groups;\n            final UserConfiguration uc;\n            final OXFolderAccess folderAccess = new OXFolderAccess(readcon, ctx);\n            boolean isShared = false;\n            if (isShared = (searchobject.getFolder() > 0 && folderAccess.isFolderShared(searchobject.getFolder(), session.getUserId()))) {\n                userId = folderAccess.getFolderOwner(searchobject.getFolder());\n                groups = UserStorage.getStorageUser(userId, ctx).getGroups();\n                uc = UserConfigurationStorage.getInstance().getUserConfiguration(userId, groups, ctx);\n            } else {\n                userId = session.getUserId();\n                groups = user.getGroups();\n                uc = userConfig;\n            }\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            prep = cimp.getSearchQuery(StringCollection.getSelect(cols, DATES_TABLE_NAME), userId, groups, uc, orderBy, orderDir, searchobject, ctx, readcon, cfo, isShared);\n            rs = cimp.getResultSet(prep);\n            co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n            close_connection = false;\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            LOG.error(e.getMessage(), e); // Unfortunately the nested exception looses its stack trace.\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, I(33));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n\n    @Override\n    public final long attachmentAction(final int folderId, final int oid, final int uid, final Session session, final Context c, final int numberOfAttachments) throws OXException {\n        return cimp.attachmentAction(folderId, oid, uid, session, c, numberOfAttachments);\n    }\n\n    @Override\n    public SearchIterator<Appointment> getFreeBusyInformation(final int uid, final int type, final Date start, final Date end) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        final CalendarSqlImp calendarsqlimp = CalendarSql.getCalendarSqlImplementation();\n        SearchIterator<List<Integer>> private_folder_information = null;\n        try {\n            if (!userConfig.hasFreeBusy()) {\n                return SearchIteratorAdapter.emptyIterator();\n            }\n            readcon = DBPool.pickup(ctx);\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            switch(type) {\n                case Participant.USER:\n                    private_folder_information = calendarsqlimp.getAllPrivateAppointmentAndFolderIdsForUser(ctx, user.getId(), readcon);\n                    prep = cimp.getFreeBusy(uid, ctx, start, end, readcon);\n                    break;\n                case Participant.RESOURCE:\n                    final long whole_day_start = recColl.getUserTimeUTCDate(start, user.getTimeZone());\n                    long whole_day_end = recColl.getUserTimeUTCDate(end, user.getTimeZone());\n                    if (whole_day_end <= whole_day_start) {\n                        whole_day_end = whole_day_start+Constants.MILLI_DAY;\n                    }\n                    private_folder_information = calendarsqlimp.getResourceConflictsPrivateFolderInformation(ctx, start, end, new Date(whole_day_start), new Date(whole_day_end), readcon, wrapParenthesis(uid));\n                    prep = cimp.getResourceFreeBusy(uid, ctx, start, end, readcon);\n                    break;\n                default:\n                    throw OXCalendarExceptionCodes.FREE_BUSY_UNSUPPOTED_TYPE.create(Integer.valueOf(type));\n            }\n            rs = cimp.getResultSet(prep);\n            //final SearchIterator si = new FreeBusyResults(rs, prep, ctx, readcon, start.getTime(), end.getTime());\n            final SearchIterator si = new FreeBusyResults(rs, prep, ctx, session.getUserId(), user.getGroups(), userConfig, readcon, true, new Participant[0], private_folder_information, calendarsqlimp, start.getTime(), end.getTime());\n            close_connection = false;\n            return si;\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(34));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public SearchIterator<Appointment> getActiveAppointments(final int user_uid, final Date start, final Date end, int cols[]) throws OXException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final CalendarOperation co = new CalendarOperation();\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            prep = cimp.getActiveAppointments(ctx, session.getUserId(), start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), readcon);\n            final ResultSet rs = cimp.getResultSet(prep);\n            co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n            close_connection = false;\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(35));\n        } finally {\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public SearchIterator<Appointment> getModifiedAppointmentsBetween(final int userId, final Date start, final Date end, int[] cols, final Date since, final int orderBy, final Order orderDir) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        final User user = Tools.getUser(session, ctx);\n        final UserConfiguration userConfig = Tools.getUserConfiguration(ctx, session.getUserId());\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final CalendarOperation co = new CalendarOperation();\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            prep = cimp.getAllAppointmentsForUser(ctx, session.getUserId(), user.getGroups(), userConfig, start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), readcon, since, orderBy, orderDir);\n            rs = cimp.getResultSet(prep);\n            co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n            close_connection = false;\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(36));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    @Override\n    public SearchIterator<Appointment> getAppointmentsBetween(final int user_uid, final Date start, final Date end, final int cols[], final int orderBy, final Order orderDir) throws OXException, SQLException {\n        return getModifiedAppointmentsBetween(user_uid, start, end, cols, null, orderBy, orderDir);\n    }\n    \n    @Override\n    public SearchIterator<Appointment> getAppointmentsBetween(final Date start, final Date end, int cols[], final int orderBy, final Order order) throws OXException, SQLException {\n        if (session == null) {\n            throw OXCalendarExceptionCodes.ERROR_SESSIONOBJECT_IS_NULL.create();\n        }\n        Connection readcon = null;\n        PreparedStatement prep = null;\n        ResultSet rs = null;\n        boolean close_connection = true;\n        final Context ctx = Tools.getContext(session);\n        try {\n            readcon = DBPool.pickup(ctx);\n            cols = recColl.checkAndAlterCols(cols);\n            final CalendarOperation co = new CalendarOperation();\n            final CalendarSqlImp cimp = CalendarSql.cimp;\n            prep = cimp.getAllAppointments(ctx, start, end, StringCollection.getSelect(cols, DATES_TABLE_NAME), readcon, orderBy, order);\n            rs = cimp.getResultSet(prep);\n            co.setResultSet(rs, prep, cols, cimp, readcon, 0, 0, session, ctx);\n            close_connection = false;\n            return new AppointmentIteratorAdapter(new CachedCalendarIterator(co, ctx, session.getUserId()));\n        } catch(final SQLException sqle) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(sqle);\n        } catch(final OXException oxc) {\n            throw oxc;\n        } catch(final RuntimeException e) {\n            throw OXCalendarExceptionCodes.UNEXPECTED_EXCEPTION.create(e, Integer.valueOf(36));\n        } finally {\n            if (close_connection) {\n                recColl.closeResultSet(rs);\n                recColl.closePreparedStatement(prep);\n            }\n            if (readcon != null && close_connection) {\n                DBPool.push(ctx, readcon);\n            }\n        }\n    }\n\n    public static final CalendarSqlImp getCalendarSqlImplementation() {\n        CalendarSqlImp cimp = CalendarSql.cimp;\n        if (cimp != null){\n            return cimp;\n        }\n        LOG.error(\"No CalendarSqlImp Class found !\");\n        try {\n            cimp = (CalendarSqlImp) Class.forName(default_class).newInstance();\n            CalendarSql.cimp = cimp;\n            return cimp;\n        } catch(final ClassNotFoundException cnfe) {\n            LOG.error(cnfe.getMessage(), cnfe);\n        } catch (final IllegalAccessException iae) {\n            LOG.error(iae.getMessage(), iae);\n        } catch (final InstantiationException ie) {\n            LOG.error(ie.getMessage(), ie);\n        }\n        return null;\n    }\n\n    static {\n        try {\n            if (cimp == null) {\n                CalendarConfig.init();\n                String classname = CalendarConfig.getProperty(\"CalendarSQL\");\n                if (classname == null) {\n                    classname = default_class;\n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Using \"+classname+\" in CalendarSql\");\n                }\n                cimp = (CalendarSqlImp) Class.forName(classname).newInstance();\n            }\n        } catch(final ConfigurationException ce) {\n            LOG.error(ce.getMessage(), ce);\n        } catch(final ClassNotFoundException cnfe) {\n            LOG.error(cnfe.getMessage(), cnfe);\n        } catch (final IllegalAccessException iae) {\n            LOG.error(iae.getMessage(), iae);\n        } catch (final InstantiationException ie) {\n            LOG.error(ie.getMessage(), ie);\n        } catch (final OXException e) {\n            LOG.error(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Wraps specified <code>int</code> with parenthesis\n     *\n     * @param i\n     *            The <code>int</code> value to wrap\n     * @return The wrapped <code>int</code> value\n     */\n    private static final String wrapParenthesis(final int i) {\n        final String str = String.valueOf(i);\n        return new StringBuilder(str.length() + 2).append('(').append(str).append(')').toString();\n    }\n\n    @Override\n    public int resolveUid(final String uid) throws OXException {\n        return cimp.resolveUid(session, uid);\n    }\n\n    @Override\n    public int getFolder(final int objectId) throws OXException {\n        return cimp.getFolder(session, objectId);\n    }\n\n    @Override\n    public void setIncludePrivateAppointments(final boolean include) {\n        this.includePrivateAppointments = include;\n    }\n\n    @Override\n    public boolean getIncludePrivateAppointments() {\n        return this.includePrivateAppointments;\n    }\n\n    @Override\n    public List<Appointment> getAppointmentsWithExternalParticipantBetween(final String email, int[] cols, final Date start, final Date end, final int orderBy, final Order order) throws OXException {\n        final List<Appointment> appointments = new ArrayList<Appointment>();\n        cols = addColumnIfNecessary(cols, CalendarObject.PARTICIPANTS);\n        SearchIterator<Appointment> searchIterator;\n        try {\n            searchIterator = getModifiedAppointmentsBetween(session.getUserId(), start, end, cols, null, orderBy, order);\n        } catch (final SQLException e) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e);\n        }\n        while (searchIterator.hasNext()) {\n            final Appointment app = searchIterator.next();\n            final Participant[] participants = app.getParticipants();\n            for (final Participant participant : participants) {\n                if (participant.getType() == Participant.EXTERNAL_USER && participant.getEmailAddress().equals(email)) {\n                    appointments.add(app);\n                    break;\n                }\n            }\n        }\n\n        return appointments;\n    }\n\n    @Override\n    public List<Appointment> getAppointmentsWithUserBetween(final User user, int[] cols, final Date start, final Date end, final int orderBy, final Order order) throws OXException {\n        final List<Appointment> appointments = new ArrayList<Appointment>();\n        cols = addColumnIfNecessary(cols, CalendarObject.USERS);\n        SearchIterator<Appointment> searchIterator;\n        try {\n            searchIterator = getModifiedAppointmentsBetween(session.getUserId(), start, end, cols, null, orderBy, order);\n        } catch (final SQLException e) {\n            throw OXCalendarExceptionCodes.CALENDAR_SQL_ERROR.create(e);\n        }\n        while (searchIterator.hasNext()) {\n            final Appointment app = searchIterator.next();\n            final UserParticipant[] users = app.getUsers();\n            for (final UserParticipant userParticipant : users) {\n                if (userParticipant.getIdentifier() == user.getId()) {\n                    appointments.add(app);\n                    break;\n                }\n            }\n        }\n\n        return appointments;\n    }\n\n    private int[] addColumnIfNecessary(final int[] cols, final int participants) {\n\n        final ArrayList<Integer> columns = new ArrayList<Integer>();\n        for (final int c : cols) {\n            columns.add(c);\n        }\n        if (!columns.contains(participants)) {\n            columns.add(participants);\n        }\n\n        return I2i(columns);\n    }\n}\n"},
{"Line": "=>48", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["java.lang.String.indexOf(java.lang.String)"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfDep]", "Content": "=>if (commandEndIndex > (-1)) { command = pMessage.substring(0, commandEndIndex); parameter = pMessage.substring((commandEndIndex + 1)); }else { command = pMessage; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/170/buggy-version/src.ConnectFour.server.GameServer.java", "BodyUseAPI": ["java.lang.String.substring(int)", "java.lang.String.substring(int,int)"], "Fixed commit": "52517499484994fb464f1fe945daa9acb858d592", "Url": "https://api.github.com/repos/timstruthoff/ConnectFour", "Date": "2018-11-15T12:01:43Z", "Source Code Diff": "@@ -25,7 +25,7 @@ public GameServer() {\n     }\n \n     public void processNewConnection(String pClientIP, int pClientPort) {\n-\n+        System.out.println(\"New connection from \" + pClientIP + \":\" + pClientPort);\n     }\n \n     public void processClosingConnection(String pClientIP, int pClientPort) {\n@@ -40,12 +40,23 @@ public void processMessage(String pClientIP, int pClientPort, String pMessage) {\n         \n         // Get the position where the string ends\n         int commandEndIndex = pMessage.indexOf(\" \");\n+        \n+        String command = \"\";\n+        String parameter = \"\";\n+        \n+        // Check if there are paramters in the message.\n+        if (commandEndIndex > -1) {\n+            // Get command from message\n+            command = pMessage.substring(0, commandEndIndex);\n+            \n+            // Get parameter from message after space\n+            parameter = pMessage.substring(commandEndIndex + 1);\n+        } else {\n+            command = pMessage;\n+        }\n+        \n \n-        // Get command from message\n-        String command = pMessage.substring(0, commandEndIndex);\n-\n-        // Get parameter from message after space\n-        String parameter = pMessage.substring(commandEndIndex + 1);\n+        \n \n         switch (command) {\n             case \"START\":", "Complete After Code": "package ConnectFour.server;\n\nimport EgJavaLib2.netzwerk.*;\n\n/**\n * Write a description of class GameServer here.\n *\n * @author (your name)\n * @version (a version number or a date)\n */\npublic class GameServer extends Server {\n    \n    // NOTE: circular reference not used yet.\n    ServerGameLogic servergamelogic = new ServerGameLogic(this);\n    \n    String newline = System.getProperty(\"line.separator\");\n\n    /**\n     * Constructor for objects of class SpielServer\n     */\n    public GameServer() {\n        super(1234);\n        \n        System.out.println(\"Server: Started.\");\n    }\n\n    public void processNewConnection(String pClientIP, int pClientPort) {\n        System.out.println(\"New connection from \" + pClientIP + \":\" + pClientPort);\n    }\n\n    public void processClosingConnection(String pClientIP, int pClientPort) {\n\n    }\n\n    @Override\n    public void processMessage(String pClientIP, int pClientPort, String pMessage) {\n        \n        System.out.println(\"Client message from \" + pClientIP + \":\" + pClientPort + newline + pMessage);\n        \n        \n        // Get the position where the string ends\n        int commandEndIndex = pMessage.indexOf(\" \");\n        \n        String command = \"\";\n        String parameter = \"\";\n        \n        // Check if there are paramters in the message.\n        if (commandEndIndex > -1) {\n            // Get command from message\n            command = pMessage.substring(0, commandEndIndex);\n            \n            // Get parameter from message after space\n            parameter = pMessage.substring(commandEndIndex + 1);\n        } else {\n            command = pMessage;\n        }\n        \n\n        \n\n        switch (command) {\n            case \"START\":\n                this.onStartMessage(pClientIP, pClientPort);\n                break;\n            case \"LOGIN\":\n                this.onLoginMessage(pClientIP, pClientPort, parameter);\n                break;\n            case \"DROP\":\n                this.onDropMessage(pClientIP, pClientPort, parameter);\n                break;\n            default:\n                this.send(pClientIP, pClientPort, \"ERR Invalid command!\");\n                break;\n        }\n    }\n\n    /**\n     * Process start messages from the client.\n     *\n     * @param pClientIP\n     * @param pClientPort\n     */\n    public void onStartMessage(String pClientIP, int pClientPort) {\n        \n        int playerNumber = servergamelogic.getNumberOfPlayers();\n\n        // Check how many players are already on the server.\n        if (playerNumber > 2) {\n            this.send(pClientIP, pClientPort, \"ERR Game full\");\n        } else if (playerNumber == 0) {\n            this.send(pClientIP, pClientPort, \"OK Waiting for players\");\n        } else if (playerNumber == 1) {\n            this.send(pClientIP, pClientPort, \"OK Game start\");\n        }\n    }\n\n    /**\n     * Process login messages from the client.\n     *\n     * @param pClientIP\n     * @param pClientPort\n     * @param pName\n     */\n    public void onLoginMessage(String pClientIP, int pClientPort, String pName) {\n        if (servergamelogic.isNameAlreadyTaken(pName)) {\n            this.send(pClientIP, pClientPort, \"ERR Name already taken\");\n        } else {\n            servergamelogic.addPlayer(pName, pClientIP);\n            this.send(pClientIP, pClientPort, \"OK Login was successful\");\n            \n            // Notifying all players that a new enemy has joined.\n            this.sendToAll(\"NEWENEMY \" + pName);\n        }\n\n    }\n\n    /**\n     * Drops a chip in the column.\n     *\n     * @param pClientIP\n     * @param pClientPort\n     * @param pColumn The column where the chip should be dropped.\n     */\n    public void onDropMessage(String pClientIP, int pClientPort, String pColumn) {\n        int column = Integer.parseInt(pColumn);\n\n        if (servergamelogic.isValidColumnNumber(column)) {\n            if (servergamelogic.isColumnFull(column)) {\n                this.send(pClientIP, pClientPort, \"ERR column full\");\n            } else {\n                Player p = servergamelogic.getPlayerByIpAddress(pClientIP);\n                int playerNumber = servergamelogic.getNumberOfPlayer(p);\n                \n                // Reflect drop in game server model and then notify game server of new drop.\n                servergamelogic.drop(playerNumber, column);\n                \n                \n                if(servergamelogic.hasGameEnded()) {\n                    this.sendGameEnded();\n                } else {\n                    \n                    servergamelogic.switchPlayers();\n                }\n            }\n        } else {\n            this.send(pClientIP, pClientPort, \"ERR invalid column selected\");\n        }\n    }\n    \n    /**\n     * Send a message notifying the players that the game has ended and whether they have won or not.\n     */\n    public void sendGameEnded() {\n        \n        // Notify the player that the game has ended and whether they won or not.\n        Player winner = servergamelogic.getCurrentPlayer();\n        this.send(winner.getIpAddress(), winner.getPort(), \"END true\");\n        \n        Player looser = servergamelogic.getOtherPlayer();\n        this.send(looser.getIpAddress(), looser.getPort(), \"END false\");\n    }\n    \n    /**\n     * Handle a player's move in which they drop a chip in a specific column.\n     * @param pPlayerNumber The number of the player who dropped a chip.\n     * @param pColumn\n     * @param pRow \n     */\n    public void handlePlayerDrop (int pPlayerNumber, int pColumn, int pRow) {\n        System.out.println(\"DROP Player: \" + pPlayerNumber + \" Column: \" + pColumn + \" Row: \" + pRow);\n        \n        // Send message to other player\n        this.sendToAll(\"DROPPED \" + pPlayerNumber + \" \" + pColumn + \" \" + pRow);\n    }\n\n}\n"},
{"Line": "=>149", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (mIMainActivity.getMyPreferenceManager().getLastPlayedArtist().equals(mSelectArtist.getArtist_id())) { getSelectedMediaItem(mIMainActivity.getMyPreferenceManager().getLastPlayedMedia()); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/890/buggy-version/app.src.main.java.com.codingwithmitch.audiostreamer.ui.PlaylistFragment.java", "BodyUseAPI": ["mIMainActivity.getMyPreferenceManager().getLastPlayedMedia()", "com.codingwithmitch.audiostreamer.ui.PlaylistFragment.getSelectedMediaItem(mIMainActivity.getMyPreferenceManager().getLastPlayedMedia())", "com.codingwithmitch.audiostreamer.ui.IMainActivity.getMyPreferenceManager()"], "Fixed commit": "4f480a11d0d6c0e29cefd3ff495723b480be8701", "Url": "https://api.github.com/repos/mitchtabian/Spotify-Clone", "Date": "2018-12-20T17:12:12Z", "Source Code Diff": "@@ -86,6 +86,17 @@ public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceStat\n         if(savedInstanceState != null){\n             mAdapter.setSelectedIndex(savedInstanceState.getInt(\"selected_index\"));\n         }\n+\n+    }\n+\n+    private void getSelectedMediaItem(String mediaId){\n+        for(MediaMetadataCompat mediaItem: mMediaList){\n+            if(mediaItem.getDescription().getMediaId().equals(mediaId)){\n+                mSelectedMedia = mediaItem;\n+                mAdapter.setSelectedIndex(mAdapter.getIndexOfItem(mSelectedMedia));\n+                break;\n+            }\n+        }\n     }\n \n     private void retrieveMedia(){\n@@ -135,6 +146,9 @@ private void addToMediaList(QueryDocumentSnapshot document) {\n     private void updateDataSet(){\n         mIMainActivity.hideProgressBar();\n         mAdapter.notifyDataSetChanged();\n+        if(mIMainActivity.getMyPreferenceManager().getLastPlayedArtist().equals(mSelectArtist.getArtist_id())){\n+            getSelectedMediaItem(mIMainActivity.getMyPreferenceManager().getLastPlayedMedia());\n+        }\n     }\n \n     private void initRecyclerView(View view){", "Complete After Code": "package com.codingwithmitch.audiostreamer.ui;\n\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.media.MediaMetadataCompat;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport com.codingwithmitch.audiostreamer.R;\nimport com.codingwithmitch.audiostreamer.adapters.CategoryRecyclerAdapter;\nimport com.codingwithmitch.audiostreamer.adapters.PlaylistRecyclerAdapter;\nimport com.codingwithmitch.audiostreamer.models.Artist;\nimport com.google.android.gms.tasks.OnCompleteListener;\nimport com.google.android.gms.tasks.Task;\nimport com.google.firebase.firestore.FirebaseFirestore;\nimport com.google.firebase.firestore.Query;\nimport com.google.firebase.firestore.QueryDocumentSnapshot;\nimport com.google.firebase.firestore.QuerySnapshot;\n\nimport java.util.ArrayList;\n\n\npublic class PlaylistFragment extends Fragment implements\n        PlaylistRecyclerAdapter.IMediaSelector\n{\n\n    private static final String TAG = \"PlaylistFragment\";\n\n    // UI Components\n    private RecyclerView mRecyclerView;\n\n\n    // Vars\n    private PlaylistRecyclerAdapter mAdapter;\n    private ArrayList<MediaMetadataCompat> mMediaList = new ArrayList<>();\n    private IMainActivity mIMainActivity;\n    private String mSelectedCategory;\n    private Artist mSelectArtist;\n    private MediaMetadataCompat mSelectedMedia;\n\n    public static PlaylistFragment newInstance(String category, Artist artist){\n        PlaylistFragment playlistFragment = new PlaylistFragment();\n        Bundle args = new Bundle();\n        args.putString(\"category\", category);\n        args.putParcelable(\"artist\", artist);\n        playlistFragment.setArguments(args);\n        return playlistFragment;\n    }\n\n    @Override\n    public void onHiddenChanged(boolean hidden) {\n        if(!hidden){\n            mIMainActivity.setActionBarTitle(mSelectArtist.getTitle());\n        }\n    }\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if(getArguments() != null){\n            mSelectedCategory = getArguments().getString(\"category\");\n            mSelectArtist = getArguments().getParcelable(\"artist\");\n        }\n        setRetainInstance(true);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_home, container, false);\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        initRecyclerView(view);\n        mIMainActivity.setActionBarTitle(mSelectArtist.getTitle());\n\n        if(savedInstanceState != null){\n            mAdapter.setSelectedIndex(savedInstanceState.getInt(\"selected_index\"));\n        }\n\n    }\n\n    private void getSelectedMediaItem(String mediaId){\n        for(MediaMetadataCompat mediaItem: mMediaList){\n            if(mediaItem.getDescription().getMediaId().equals(mediaId)){\n                mSelectedMedia = mediaItem;\n                mAdapter.setSelectedIndex(mAdapter.getIndexOfItem(mSelectedMedia));\n                break;\n            }\n        }\n    }\n\n    private void retrieveMedia(){\n        mIMainActivity.showPrgressBar();\n\n        FirebaseFirestore firestore = FirebaseFirestore.getInstance();\n\n        Query query = firestore\n                .collection(getString(R.string.collection_audio))\n                .document(getString(R.string.document_categories))\n                .collection(mSelectedCategory)\n                .document(mSelectArtist.getArtist_id())\n                .collection(getString(R.string.collection_content))\n                .orderBy(getString(R.string.field_date_added), Query.Direction.ASCENDING);\n\n        query.get().addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {\n            @Override\n            public void onComplete(@NonNull Task<QuerySnapshot> task) {\n                if(task.isSuccessful()){\n                    for(QueryDocumentSnapshot document: task.getResult()){\n                       addToMediaList(document);\n                    }\n                }\n                else{\n                    Log.d(TAG, \"onComplete: error getting documents: \" + task.getException());\n                }\n                updateDataSet();\n            }\n        });\n    }\n\n    private void addToMediaList(QueryDocumentSnapshot document) {\n        MediaMetadataCompat media = new MediaMetadataCompat.Builder()\n                .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, document.getString(getString(R.string.field_media_id)))\n                .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, document.getString(getString(R.string.field_artist)))\n                .putString(MediaMetadataCompat.METADATA_KEY_TITLE, document.getString(getString(R.string.field_title)))\n                .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, document.getString(getString(R.string.field_media_url)))\n                .putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_DESCRIPTION, document.getString(getString(R.string.field_description)))\n                .putString(MediaMetadataCompat.METADATA_KEY_DATE, document.getDate(getString(R.string.field_date_added)).toString())\n                .putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON_URI, mSelectArtist.getImage())\n                .build();\n\n\n        mMediaList.add(media);\n    }\n\n    private void updateDataSet(){\n        mIMainActivity.hideProgressBar();\n        mAdapter.notifyDataSetChanged();\n        if(mIMainActivity.getMyPreferenceManager().getLastPlayedArtist().equals(mSelectArtist.getArtist_id())){\n            getSelectedMediaItem(mIMainActivity.getMyPreferenceManager().getLastPlayedMedia());\n        }\n    }\n\n    private void initRecyclerView(View view){\n        mRecyclerView = view.findViewById(R.id.recycler_view);\n        mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));\n        mAdapter = new PlaylistRecyclerAdapter(getActivity(), mMediaList, this);\n        mRecyclerView.setAdapter(mAdapter);\n\n        if(mMediaList.size() == 0){\n            retrieveMedia();\n        }\n    }\n\n    @Override\n    public void onAttach(Context context) {\n        super.onAttach(context);\n        mIMainActivity = (IMainActivity) getActivity();\n    }\n\n    @Override\n    public void onMediaSelected(int position) {\n        mIMainActivity.getMyApplicationInstance().setMediaItems(mMediaList);\n        mSelectedMedia = mMediaList.get(position);\n        mAdapter.setSelectedIndex(position);\n        mIMainActivity.onMediaSelected(\n                mSelectArtist.getArtist_id(), // playlist_id = artist_id\n                mMediaList.get(position),\n                position);\n        saveLastPlayedSongProperties();\n    }\n\n    public void updateUI(MediaMetadataCompat mediaItem){\n        mAdapter.setSelectedIndex(mAdapter.getIndexOfItem(mediaItem));\n        mSelectedMedia = mediaItem;\n        saveLastPlayedSongProperties();\n    }\n\n    private void saveLastPlayedSongProperties(){\n        // Save some properties for next time the app opens\n        // NOTE: Normally you'd do this with a cache\n        mIMainActivity.getMyPreferenceManager().savePlaylistId(mSelectArtist.getArtist_id()); // playlist id is same as artist id\n        mIMainActivity.getMyPreferenceManager().saveLastPlayedArtist(mSelectArtist.getArtist_id());\n        mIMainActivity.getMyPreferenceManager().saveLastPlayedCategory(mSelectedCategory);\n        mIMainActivity.getMyPreferenceManager().saveLastPlayedArtistImage(mSelectArtist.getImage());\n        mIMainActivity.getMyPreferenceManager().saveLastPlayedMedia(mSelectedMedia.getDescription().getMediaId());\n    }\n\n    @Override\n    public void onSaveInstanceState(@NonNull Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(\"selected_index\", mAdapter.getSelectedIndex());\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},
{"Line": "=>119", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfNull]", "Content": "=>if ((list == null) || (list.isEmpty())) { return listSecure; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/486/buggy-version/src.main.java.com.simpto.web.rest.AlgorithmSimptoResource.java", "BodyUseAPI": [], "Fixed commit": "93efba2dedd5ada457776e0bb96e1eb10c75fc2c", "Url": "https://api.github.com/repos/skibek/simpto6", "Date": "2018-11-05T21:59:45Z"},
{"Line": "=>169", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (playerTurn == (PLAYER_A)) { for (int i = 0; i < 5; i++) { ids[i] = dealCard(playerTurn); } return ids; }else { for (int i = 0; i < 5; i++) { ids[i] = dealCard(playerTurn); } return ids; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/5/buggy-version/src.main.java.server.Server.java", "BodyUseAPI": ["server.Server.dealCard(int)", "server.Server.dealCard(int)"], "Fixed commit": "d745be71db9b9e0f2256a9812d5c62deafbff13f", "Url": "https://api.github.com/repos/Folly4k/DigitalTradingCardGame", "Date": "2018-11-02T08:53:27Z"},
{"Line": "=>275", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["Graph.executeBacktracking(int)"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (colored) { break; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/583/buggy-version/src.Backtracking.java", "BodyUseAPI": [], "Fixed commit": "c35a30e29d04c0d5b3d2c7bfbc541fa96921b96c", "Url": "https://api.github.com/repos/dke-group-23/DKE-Project", "Date": "2018-12-11T21:21:33Z", "Source Code Diff": "@@ -260,19 +260,22 @@ public int getChromaticNumber() {\n \n                 while (i <= numberOfVertices) {\n \n-                    boolean colored =executeBacktracking(i);\n+                    boolean colored = executeBacktracking(i);\n \n                     if(DEBUG) {\n                         if (colored) {\n                             System.out.println(\"Solution\");\n                             for (Node n : nodes)\n                                 System.out.println(\"Node \" + n.getLabel() + \" Color \" + colors[n.getLabel()]);\n-                            break;\n                         } else {\n                             System.out.println(\"No solution for \" + i);\n                         }\n                     }\n \n+                    if(colored) {\n+                        break;\n+                    }\n+\n                     i++;\n                 }\n ", "Complete After Code": "import java.io.*;\nimport java.util.*;\n\npublic class Backtracking {\n\n    static boolean DEBUG = false;\n\n\tpublic static int getChromaticNumber(int numberOfVertices, int numberOfEdges, Edge[] edges) {\n\n        class Node {\n\n            int color;\n\n            public Node(int color) {\n                this.color = color;\n            }\n\n            public int getLabel() {\n                return color;\n            }\n\n            public int getDegree() {\n                return color;\n            }\n\n        }\n\n        class Graph {\n\n            int numberOfVertices; //number of vertices\n            int numberOfEdges; //number of edges\n            int[][] adj; //adjacency matrix\n            ArrayList<Node> nodes = new ArrayList<Node>();\n            ArrayList<Set<Node>> maxCliqueList = new ArrayList<Set<Node>>();\n            int colors[];\n\n\n            /**\n             * Constructor\n             */\n            Graph(int numberOfVertices, int numberOfEdges, Edge[] e) {\n\n                this.numberOfVertices = numberOfVertices;\n                this.numberOfEdges = numberOfEdges;\n\n                adj = new int[numberOfVertices + 1][numberOfVertices + 1];\n\n                for (int i = 0; i <= numberOfVertices; i++)\n                    for (int j = 0; j <= numberOfVertices; j++)\n                        adj[i][j] = 0;\n\n                for (int k = 0; k < numberOfEdges; k++) {\n\n                    adj[e[k].to][e[k].from] = 1;\n                    adj[e[k].from][e[k].to] = 1;\n                }\n\n                for (int i = 0; i <= numberOfVertices; i++)\n                    nodes.add(new Node(i));\n\n                colors = new int[numberOfVertices + 1];\n                for (int c = 0; c <= numberOfVertices; c++)\n                    colors[c] = 0;\n            }\n\n            /**\n             * Check whether there's an edge between two nodes\n             */\n            public boolean isAdjacent(Node a, Node b) {\n\n                if (adj[a.getLabel()][b.getLabel()] == 1)\n                    return true;\n\n                return false;\n            }\n\n            /**\n             * Returns neighbours of node x\n             */\n            public ArrayList<Node> getNeighbours(Node x) {\n\n                ArrayList<Node> neighbours = new ArrayList<Node>();\n\n                for (Node n : nodes)\n                    if (isAdjacent(n, x))\n                        neighbours.add(n);\n\n                return neighbours;\n            }\n\n\n            /**\n             * Check if we can color vertex x with a specific color\n             */\n            public boolean isAvailable(Node x, int color) {\n\n                for (Node n : nodes)\n                    if (isAdjacent(n, x) && (colors[n.getLabel()] == color))\n                        return false;\n\n                return true;\n            }\n\n            /**\n             * Checks if a graph is complete\n             */\n            public boolean isComplete() {\n\n                boolean check = true;\n\n                for (Node n : nodes)\n                    if (n.getDegree() != (numberOfVertices - 1))\n                        check = false;\n\n                return check;\n            }\n\n            /**\n             * Check if graph is a star\n             */\n\n            public boolean isStar() {\n\n                int counter1 = 0, counter2 = 0;\n\n                for (Node n : nodes) {\n\n                    if (n.getDegree() == 1)\n                        counter1++;\n                    else if (n.getDegree() == (numberOfVertices - 1))\n                        counter2++;\n                }\n\n                if ((counter1 == (numberOfVertices - 1)) && (counter2 == 1))\n                    return true;\n\n                return false;\n            }\n\n            /**\n             * Intersection of two sets\n             */\n            public ArrayList<Node> Intersection(ArrayList<Node> S1, ArrayList<Node> S2) {\n\n                ArrayList<Node> S3 = new ArrayList<Node>(S1);\n                S3.retainAll(S2);\n                return S3;\n            }\n\n            /**\n             * Bron Kerbosch algorithm - version without a pivot\n             */\n            public void BronKerbosch(ArrayList<Node> R, ArrayList<Node> P, ArrayList<Node> X) {\n\n                if ((P.size() == 0) && (X.size() == 0)) {\n\n                    processMaxClique(R);\n                    return;\n                }\n\n                ArrayList<Node> P1 = new ArrayList<Node>(P);\n\n                for (Node n : P) {\n\n                    R.add(n);\n                    BronKerbosch(R, Intersection(P1, getNeighbours(n)), Intersection(X, getNeighbours(n)));\n                    R.remove(n);\n                    P1.remove(n);\n                    X.add(n);\n                }\n            }\n\n            /**\n             * Proccess a maximal clique and add it to the list of all maximal cliques\n             */\n            public void processMaxClique(ArrayList<Node> R) {\n\n                Set<Node> maxClique = new HashSet<Node>();\n\n                for (Node n : R)\n                    maxClique.add(n);\n\n                maxCliqueList.add(maxClique);\n            }\n\n            public void executeBronKerbosch() {\n\n                ArrayList<Node> X = new ArrayList<Node>();\n                ArrayList<Node> R = new ArrayList<Node>();\n                ArrayList<Node> P = new ArrayList<Node>(nodes);\n\n                BronKerbosch(R, P, X);\n            }\n\n            public int getLowerBound() {\n\n                int lowerBound = 1;\n\n                for (Set<Node> maxClique : maxCliqueList)\n                    if (maxClique.size() > lowerBound)\n                        lowerBound = maxClique.size();\n\n                return lowerBound;\n            }\n\n            /**\n             * Backtracking algorithm\n             */\n            public boolean Backtracking(int m, Node x) {\n\n                if (x.getLabel() == numberOfVertices)\n                    return true;\n\n                for (int col = 1; col <= m; col++) {\n\n                    if (isAvailable(x, col)) {\n\n                        colors[x.getLabel()] = col;\n                        if (Backtracking(m, nodes.get(nodes.indexOf(x) + 1)))\n                            return true;\n                    }\n\n                    colors[x.getLabel()] = 0;\n                }\n\n                return false;\n            }\n\n            /**\n             * Execute backtracking\n             */\n            public boolean executeBacktracking(int m) {\n\n                boolean found = false;\n\n                if (Backtracking(m, new Node(1)) == false) {\n\n                    System.out.println(\"The solution doesn't exist\");\n\n                } else {\n\n                    found = true;\n                }\n\n                return found;\n            }\n\n            /**\n             * Get chromatic number\n             */\n            public int getChromaticNumber() {\n\n                if (isComplete())\n                    return numberOfVertices;\n                if (isStar())\n                    return 2;\n\n                executeBronKerbosch();\n                int i = getLowerBound();\n\n                while (i <= numberOfVertices) {\n\n                    boolean colored = executeBacktracking(i);\n\n                    if(DEBUG) {\n                        if (colored) {\n                            System.out.println(\"Solution\");\n                            for (Node n : nodes)\n                                System.out.println(\"Node \" + n.getLabel() + \" Color \" + colors[n.getLabel()]);\n                        } else {\n                            System.out.println(\"No solution for \" + i);\n                        }\n                    }\n\n                    if(colored) {\n                        break;\n                    }\n\n                    i++;\n                }\n\n                return i;\n            }\n\n        }\n\n        //! At this point e[0] will be the first edge, with e[0].to referring to one endpoint and e[0].from to the other\n        //! e[1] will be the second edge...\n        //! (and so on)\n        //! e[m-1] will be the last edge\n        //!\n        //! there will be n vertices in the graph, numbered 1 to n\n\n        //! INSERT YOUR CODE HERE!\n        Graph G = new Graph(numberOfVertices, numberOfEdges, edges);\n\n        int x = G.getChromaticNumber();\n        System.out.println(\"The chromatic number is: \" + x);\n\n        return x;\n\n    }\n}"},
{"Line": "=>59", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (accountDAO.userExists(change.getText())) { throw new io.joshatron.tak.server.exceptions.GameServerException(io.joshatron.tak.server.exceptions.ErrorCode.USERNAME_TAKEN); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/65/buggy-version/src.main.java.io.joshatron.tak.server.utils.AccountUtils.java", "BodyUseAPI": [], "Fixed commit": "162de59573efc7cdce58465040106208429e1bf5", "Url": "https://api.github.com/repos/joshatron/Tak-Server", "Date": "2018-12-16T19:30:42Z", "Source Code Diff": "@@ -56,6 +56,9 @@ public void updateUsername(Auth auth, Text change) throws GameServerException {\n         if(auth.getUsername().equals(change.getText())) {\n             throw new GameServerException(ErrorCode.SAME_USERNAME);\n         }\n+        if(accountDAO.userExists(change.getText())) {\n+            throw new GameServerException(ErrorCode.USERNAME_TAKEN);\n+        }\n \n         accountDAO.updateUsername(auth.getUsername(), change.getText());\n     }", "Complete After Code": "package io.joshatron.tak.server.utils;\n\nimport io.joshatron.tak.server.database.AccountDAO;\nimport io.joshatron.tak.server.exceptions.ErrorCode;\nimport io.joshatron.tak.server.exceptions.GameServerException;\nimport io.joshatron.tak.server.request.Auth;\nimport io.joshatron.tak.server.request.Text;\nimport io.joshatron.tak.server.response.User;\n\npublic class AccountUtils {\n\n    public static final int USER_ID_LENGTH = 15;\n\n    private AccountDAO accountDAO;\n\n    public AccountUtils(AccountDAO accountDAO) {\n        this.accountDAO = accountDAO;\n    }\n\n    public boolean isAuthenticated(Auth auth) throws GameServerException {\n        Validator.validateAuth(auth);\n\n        return accountDAO.isAuthenticated(auth);\n    }\n\n    public void registerUser(Auth auth) throws GameServerException {\n        Validator.validateAuth(auth);\n        if(accountDAO.userExists(auth.getUsername())) {\n            throw new GameServerException(ErrorCode.USERNAME_TAKEN);\n        }\n\n        accountDAO.addUser(auth, USER_ID_LENGTH);\n    }\n\n    public void updatePassword(Auth auth, Text change) throws GameServerException {\n        Validator.validateAuth(auth);\n        Validator.validateText(change);\n        Validator.validatePassword(change.getText());\n        if(!accountDAO.isAuthenticated(auth)) {\n            throw new GameServerException(ErrorCode.INCORRECT_AUTH);\n        }\n        if(auth.getPassword().equals(change.getText())) {\n            throw new GameServerException(ErrorCode.SAME_PASSWORD);\n        }\n\n        accountDAO.updatePassword(auth.getUsername(), change.getText());\n    }\n\n    public void updateUsername(Auth auth, Text change) throws GameServerException {\n        Validator.validateAuth(auth);\n        Validator.validateText(change);\n        Validator.validateUsername(change.getText());\n        if(!accountDAO.isAuthenticated(auth)) {\n            throw new GameServerException(ErrorCode.INCORRECT_AUTH);\n        }\n        if(auth.getUsername().equals(change.getText())) {\n            throw new GameServerException(ErrorCode.SAME_USERNAME);\n        }\n        if(accountDAO.userExists(change.getText())) {\n            throw new GameServerException(ErrorCode.USERNAME_TAKEN);\n        }\n\n        accountDAO.updateUsername(auth.getUsername(), change.getText());\n    }\n\n    public User getUserFromId(String id) throws GameServerException {\n        Validator.validateId(id, USER_ID_LENGTH);\n\n        return accountDAO.getUserFromId(id);\n    }\n\n    public User getUserFromUsername(String username) throws GameServerException {\n        Validator.validateUsername(username);\n\n        return accountDAO.getUserFromUsername(username);\n    }\n}\n"},
{"Line": "=>266", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if ((tab.getTag()) == null) tab.setTag(com.example.robmillaci.go4lunch.activities.RestaurantActivity.MARKER_UNSELECTED);", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/13/buggy-version/app.src.main.java.com.example.robmillaci.go4lunch.activities.RestaurantActivity.java", "BodyUseAPI": ["TabLayout.Tab.setTag(java.lang.String)"], "Fixed commit": "3d90ad7c5fdc58ab76f9a9a0e56b490b18395ed4", "Url": "https://api.github.com/repos/robmillaci88/Go4Lunch", "Date": "2018-11-24T16:02:38Z", "Source Code Diff": "@@ -7,7 +7,6 @@\n import android.os.Bundle;\n import android.support.design.widget.FloatingActionButton;\n import android.support.design.widget.TabLayout;\n-import android.support.v7.app.AppCompatActivity;\n import android.support.v7.widget.LinearLayoutManager;\n import android.support.v7.widget.RecyclerView;\n import android.view.View;\n@@ -34,8 +33,6 @@\n import com.google.android.gms.maps.model.Marker;\n import com.google.android.gms.maps.model.MarkerOptions;\n \n-import org.jsoup.Connection;\n-\n import java.util.ArrayList;\n \n import static com.example.robmillaci.go4lunch.data_objects.PojoPlace.PLACE_SERIALIZABLE_KEY;\n@@ -266,9 +263,9 @@ private void web() {\n      * @param tab the tab clicked\n      */\n     private void like(TabLayout.Tab tab) {\n-        if (tab.getTag() == null) {\n-            tab.setTag(MARKER_UNSELECTED);\n-        } else {\n+        if (tab.getTag() == null) tab.setTag(MARKER_UNSELECTED);\n+        \n+        if (tab.getTag() != null) {\n             switch (tab.getTag().toString()) {\n                 case MARKER_UNSELECTED:\n                     tab.setIcon(R.drawable.start_selected);\n@@ -286,6 +283,8 @@ private void like(TabLayout.Tab tab) {\n     }\n \n \n+\n+\n     /**\n      * Starts an ACTION_DIAL intent to allow the user to call the relevant place\n      */", "Complete After Code": "package com.example.robmillaci.go4lunch.activities;\n\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.graphics.Bitmap;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.design.widget.TabLayout;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.RatingBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.example.robmillaci.go4lunch.R;\nimport com.example.robmillaci.go4lunch.adapters.AddedUsersAdapter;\nimport com.example.robmillaci.go4lunch.adapters.RestaurantActivityAdapter;\nimport com.example.robmillaci.go4lunch.adapters.UsersListAdapter;\nimport com.example.robmillaci.go4lunch.data_objects.PojoPlace;\nimport com.example.robmillaci.go4lunch.data_objects.Users;\nimport com.example.robmillaci.go4lunch.firebase.FirebaseHelper;\nimport com.example.robmillaci.go4lunch.fragments.GoogleMapsFragment;\nimport com.example.robmillaci.go4lunch.utils.IphotoDownloadedCallback;\nimport com.example.robmillaci.go4lunch.utils.PhotoDownloader;\nimport com.example.robmillaci.go4lunch.web_service.HtmlParser;\nimport com.example.robmillaci.go4lunch.web_service.IhtmlParser;\nimport com.google.android.gms.location.places.Places;\nimport com.google.android.gms.maps.model.BitmapDescriptorFactory;\nimport com.google.android.gms.maps.model.LatLng;\nimport com.google.android.gms.maps.model.Marker;\nimport com.google.android.gms.maps.model.MarkerOptions;\n\nimport java.util.ArrayList;\n\nimport static com.example.robmillaci.go4lunch.data_objects.PojoPlace.PLACE_SERIALIZABLE_KEY;\nimport static com.example.robmillaci.go4lunch.firebase.FirebaseHelper.DATABASE_SELECTED_RESTAURANT_FIELD;\nimport static com.example.robmillaci.go4lunch.firebase.FirebaseHelper.DATABASE_SELECTED_RESTAURANT_ID_FIELD;\n\n/**\n * This activity is responsible for displaying the details of a specific place\n */\npublic class RestaurantActivity extends BaseActivity implements IphotoDownloadedCallback, IhtmlParser {\n\n    public static final String MARKER_UNSELECTED = \"notSelected\"; //Tag for marker when the marker is 'unselected' as place the user is eating\n    public static final String MARKER_SELECTED = \"selected\"; //Tag for marker when the marker is 'selected' as place the user is eating\n\n    private String phoneNumber; //The phone number of the place\n    private String webaddress; //the web url of the place\n    private String placeID; //the ID of the place\n    private boolean isItSelected = false; //is this place selected by the user\n    private boolean isItSelectedByOthers = false; //this place is selected by other users\n\n    private ImageView image; //The image of the place\n    private FloatingActionButton selectedFab; //The action button to 'select' this place\n    private TabLayout.Tab starLikeTab; //The tab to 'like' this place\n    private RecyclerView peopleEatingRecyclerView; //Recycler view displaying the list of all friends 'eating' here\n\n    private PojoPlace mPojoPlace; //The place this activity is displaying data for\n    private Marker mMarker; //The marker that relates to this place\n    private LatLng location; //The location (LatLng) of this place\n\n    private FirebaseHelper firebaseHelper; //instance of firebase helper used in this class to retrieve the data\n    private PhotoDownloader photoDownloader; //instance of PhotoDownloader in order to download the photo for this place\n\n\n    /**\n     * Instantiates {@link FirebaseHelper} and {@link PhotoDownloader}<br>\n     * Create the recyclerview as well as all relevant views for this Activity<br>\n     * Retrieves the specific googleMaps marker and stores a reference so we can 'select' or 'unselect' the marker {@link GoogleMapsFragment#getSpecificMarker(String)}<br>\n     * Some data is unavailable with the GooglePlaces SDK. {@link #getAdditionalPlaceData()} retrieves this extra required data.<br>\n     * Also handle the events of clicking on {@link #selectedFab} and the events of clicking the tabs<br>\n     *\n     * @param savedInstanceState saveInstance data\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_restaurant);\n\n        firebaseHelper = new FirebaseHelper(this);\n        photoDownloader = new PhotoDownloader(this, null);\n\n        peopleEatingRecyclerView = findViewById(R.id.peopleEatingRecyclerView); //RecyclerView displaying the users eating at this place\n        ImageView backbtn = findViewById(R.id.backbtn);\n        TextView name = findViewById(R.id.restaurant_name); //The place name\n\n        image = findViewById(R.id.restaurant_image); //The place image\n        RatingBar rating = findViewById(R.id.ratingBar); //The place rating bar\n        TabLayout tabs = findViewById(R.id.action_tabs); //The tabs for this activity\n        selectedFab = findViewById(R.id.restaurant_selected); //The tab to selected this restaurant as the 'eating at' place\n        starLikeTab = tabs.getTabAt(1); //The tab to 'like' this place\n\n        Bundle data = getIntent().getExtras();\n        if (data != null)\n            mPojoPlace = (PojoPlace) data.getSerializable(PLACE_SERIALIZABLE_KEY); //Restore the place passed to this activity in the calling intent\n\n        if (mPojoPlace != null) {\n            mMarker = GoogleMapsFragment.getSpecificMarker(mPojoPlace.getName()); //Retrieve the specific marker for this place\n\n            // if the marker is null, create a new marker for this place\n            if (mMarker == null) {\n                MarkerOptions mOptions = new MarkerOptions()\n                        .position(mPojoPlace.getLocation())\n                        .title(mPojoPlace.getName())\n                        .icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_orange));\n\n                Marker marker = GoogleMapsFragment.getmGoogleMap().addMarker(mOptions);\n\n                GoogleMapsFragment.getAllMarkers().put(mOptions.getTitle(), marker);\n                marker.setTag(MARKER_UNSELECTED);\n                mMarker = marker;\n            }\n\n            // Set the name, rating, web url, placeId, phonenumber and location\n            name.setText(mPojoPlace.getName());\n            rating.setRating(mPojoPlace.getRating());\n            webaddress = mPojoPlace.getWebsite();\n            placeID = mPojoPlace.getId();\n            phoneNumber = mPojoPlace.getPhoneNumber();\n            location = mPojoPlace.getLocation();\n        }\n\n        getAdditionalPlaceData(); //see method comments\n\n        firebaseHelper.getAddedUsers(); //get this users added friends so we can check if any of them have selected this place. Callsback to 'finishedGettingUsers'\n\n        selectedFab.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!isItSelected) {\n                    /*\n                    if the place is unselected, set the marker tag to 'selected'\n                    Change the marker drawable to green (to display it is selected)\n                    Update the database with the new selected place by calling firebasehelper.getSelectedPlace()\n                     */\n                    selectedFab.setImageResource(R.drawable.checked);\n                    mMarker.setIcon(BitmapDescriptorFactory.fromResource(R.drawable.marker_green));\n                    mMarker.setTag(MARKER_SELECTED);\n                    isItSelected = true;\n                    firebaseHelper.getSelectedPlace(FirebaseHelper.getmCurrentUserId(), null); //method calls back to 'finishedGettingPlace'\n\n                } else {\n                    /*\n                    if the place is selected, set the marker tag to 'unselected'\n                    Change the marker drawable to orange (to display it is not selected) as long as this place is NOT selected by other friends\n                    Update the database, removing the selected place by calling firebasehelper.deleteField\n                     */\n                    selectedFab.setImageResource(R.drawable.add_restaurant);\n                    FirebaseHelper.deleteField(DATABASE_SELECTED_RESTAURANT_FIELD);\n                    FirebaseHelper.deleteField(DATABASE_SELECTED_RESTAURANT_ID_FIELD);\n\n                    firebaseHelper.getUsersEatingHere(mPojoPlace.getId(), null); //now we have unselected this place, refresh the list of users 'eating here'\n\n                    if (!isItSelectedByOthers) { //we only want to change the markers tag and icon is no other friends have selected this place\n                        mMarker.setIcon(BitmapDescriptorFactory.fromResource(R.drawable.marker_orange));\n                        mMarker.setTag(MARKER_UNSELECTED);\n                    }\n                    isItSelected = false;\n                }\n            }\n        });\n\n        backbtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                onBackPressed();\n            }\n        });\n\n\n        tabs.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {\n            @Override\n            public void onTabSelected(TabLayout.Tab tab) {\n                switch (tab.getPosition()) {\n                    case 0:\n                        call(); //start a call intent\n                        break;\n\n                    case 1:\n                        like(tab); //like the restaurant\n                        break;\n\n                    case 2:\n                        web(); //start a browser intent navigating to the places website\n                        break;\n\n                    case 3:\n                        navigate(); //start a google maps navigation activity\n                        break;\n                }\n            }\n\n            @Override\n            public void onTabUnselected(TabLayout.Tab tab) {\n            }\n\n            @Override\n            public void onTabReselected(TabLayout.Tab tab) {\n                onTabSelected(tab);\n            }\n        });\n    }\n\n\n    /**\n     * Retrieves additional place data that is not available with GooglePlacesAPI SDK <br>\n     * {@link com.example.robmillaci.go4lunch.web_service.HtmlParser} extracts the place detailed 'type' from  https://www.google.com/maps/search/ <br>\n     * {@link com.example.robmillaci.go4lunch.utils.PhotoDownloader} downloads and returns the place image bitmap <br>\n     * {@link com.example.robmillaci.go4lunch.firebase.FirebaseHelper#getUsersEatingHere(String, RecyclerView.ViewHolder)} returns the users eating at this place <br>\n     * {@link com.example.robmillaci.go4lunch.firebase.FirebaseHelper#isItLiked(String)} returns wether this place is 'liked' by the user <br>\n     */\n    private void getAdditionalPlaceData() {\n        String[] placeId = new String[]{placeID};\n        new HtmlParser(this).execute(placeId[0]);\n\n        photoDownloader.getPhotos(placeID, Places.getGeoDataClient(this));\n\n        firebaseHelper.getUsersEatingHere(mPojoPlace.getId(), null);\n        firebaseHelper.isItLiked(mPojoPlace.getId());\n    }\n\n\n    /**\n     * Builds a URI for google maps navigation passing the destination as the lat and long of this place<br>\n     * Then start the googleMaps navigation activity\n     */\n    private void navigate() {\n        Uri.Builder directionsBuilder = new Uri.Builder()\n                .scheme(\"https\")\n                .authority(\"www.google.com\")\n                .appendPath(\"maps\")\n                .appendPath(\"dir\")\n                .appendPath(\"\")\n                .appendQueryParameter(\"api\", \"1\")\n                .appendQueryParameter(\"destination\", location.latitude + \",\" + location.longitude);\n        try {\n            startActivity(new Intent(Intent.ACTION_VIEW, directionsBuilder.build()));\n        } catch (ActivityNotFoundException ex) {\n\n            Toast.makeText(this, R.string.install_google_maps, Toast.LENGTH_LONG).show();\n        }\n    }\n\n\n    /**\n     * Create a intent passing the webaddress - starting this intent opens the browser and navigates the user to the places website\n     */\n    private void web() {\n        if (webaddress != null && !webaddress.equals(\"\")) {\n            Intent webIntent = new Intent(Intent.ACTION_VIEW);\n            webIntent.setData(Uri.parse(webaddress));\n            startActivity(webIntent);\n        } else Toast.makeText(this, R.string.no_website_found, Toast.LENGTH_SHORT).show();\n    }\n\n\n    /**\n     * Performs UI changes related to liking a restaurant, then updates the database either adding or removing a liked place\n     *\n     * @param tab the tab clicked\n     */\n    private void like(TabLayout.Tab tab) {\n        if (tab.getTag() == null) tab.setTag(MARKER_UNSELECTED);\n        \n        if (tab.getTag() != null) {\n            switch (tab.getTag().toString()) {\n                case MARKER_UNSELECTED:\n                    tab.setIcon(R.drawable.start_selected);\n                    FirebaseHelper.likeRestaurant(mPojoPlace.getId());\n                    tab.setTag(MARKER_SELECTED);\n                    break;\n\n                case MARKER_SELECTED:\n                    tab.setIcon(R.drawable.star);\n                    FirebaseHelper.removeLikeRestaurant(mPojoPlace.getId());\n                    tab.setTag(MARKER_UNSELECTED);\n                    break;\n            }\n        }\n    }\n\n\n\n\n    /**\n     * Starts an ACTION_DIAL intent to allow the user to call the relevant place\n     */\n    private void call() {\n        if (phoneNumber != null && !phoneNumber.equals(\"\")) {\n            Intent intent = new Intent(Intent.ACTION_DIAL);\n            intent.setData(Uri.parse(\"tel:\" + phoneNumber));\n            startActivity(intent);\n        } else Toast.makeText(this, R.string.no_phone_number, Toast.LENGTH_SHORT).show();\n    }\n\n\n    /**\n     * Displays the users of the App that are eating at this place\n     *\n     * @param users the users eating at this place\n     * @param v     used when this callback is called in a recyclerview class so that holder changes can be performed based on the results. Null is returned otherwise\n     */\n    @Override\n    public void finishedGettingEaters(ArrayList<Users> users, RecyclerView.ViewHolder v) {\n        RestaurantActivityAdapter mAdaptor = new RestaurantActivityAdapter(users, this);\n        peopleEatingRecyclerView.setLayoutManager(new LinearLayoutManager(RestaurantActivity.this));\n        peopleEatingRecyclerView.setAdapter(mAdaptor);\n    }\n\n\n    /**\n     * Updates the database with the newly selected place and refresh the users 'eating here'\n     *\n     * @param myviewHolder the viewholder returned for updating if this method calls back to a RecyclerView class\n     * @param s            the returned place name\n     * @param placeId      the returned placeId\n     */\n    @Override\n    public void finishedGettingPlace(AddedUsersAdapter.MyviewHolder myviewHolder, String s, String placeId) {\n        FirebaseHelper firebasehelper = new FirebaseHelper(RestaurantActivity.this);\n\n        firebasehelper.addSelectedMarker(mMarker.getTitle(), placeID, s);\n        //now the field is deleted we can refresh the 'users eating here'\n        firebaseHelper.getUsersEatingHere(mPojoPlace.getId(), null); //now we have unselected this place, refresh the list of users 'eating here'\n    }\n\n\n    /**\n     * callback from {@link PhotoDownloader} setting the downloaded image of this place\n     *\n     * @param photo  the places photo to be displayed\n     * @param holder the RecyclerView.ViewHolder to be updated if this callback is in a RecyclerView class. Null is returned otherwise\n     */\n    @Override\n    public void photoReady(Bitmap photo, RecyclerView.ViewHolder holder) {\n        if (photo != null) {\n            image.setImageBitmap(photo);\n        } else {\n            image.setImageResource(R.drawable.emptyplate);\n        }\n    }\n\n\n    /**\n     * Callback from {@link FirebaseHelper#isItLiked(String)} to determine if this place is liked by the user or not\n     * Updates the UI based on the response\n     *\n     * @param response true if this place is liked, otherwise false\n     */\n    @Override\n    public void isItLikedCallback(boolean response) {\n        if (response) {\n            starLikeTab.setTag(MARKER_SELECTED);\n            starLikeTab.setIcon(R.drawable.start_selected);\n        } else {\n            starLikeTab.setTag(MARKER_UNSELECTED);\n            starLikeTab.setIcon(R.drawable.star);\n        }\n    }\n\n    /**\n     * callback from {@link FirebaseHelper#isPlaceSelected(String, String[])} to determine if any friends or the current user has selected this place\n     *\n     * @param currentUserSelectedPlace true if the current logged in user has selected this place\n     * @param otherUsersSelectedPlace  true if any of the current logged in users friends have selected this place\n     */\n    @Override\n    public void isPlaceSelected(boolean currentUserSelectedPlace, boolean otherUsersSelectedPlace) {\n        if (currentUserSelectedPlace) {\n            selectedFab.setImageResource(R.drawable.checked);\n            isItSelected = true;\n        } else {\n            selectedFab.setImageResource(R.drawable.add_restaurant);\n            isItSelected = false;\n        }\n        isItSelectedByOthers = otherUsersSelectedPlace;\n    }\n\n\n    /**\n     * callback from {@link com.example.robmillaci.go4lunch.web_service.HtmlParser} to update the UI with the place detaild type\n     *\n     * @param value the returned objects from this method\n     */\n    @Override\n    public void parseComplete(Object... value) {\n        TextView address = findViewById(R.id.restaurant_address);\n        address.setText(String.format(\"%s - %s\", value[0], mPojoPlace.getAddress()));\n    }\n\n    @Override\n    public void finishedGettingUsers(String[] users, UsersListAdapter.MyviewHolder viewHolder) {\n        //now we have the added friends ID's we can check if any of them have selected this place\n        firebaseHelper.isPlaceSelected(placeID, users);\n    }\n}\n\n\n\n"},
{"Line": "=>61", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if (savedInstanceState == null) { mFragmentManager.beginTransaction().replace(R.id.fragment_container, tech.joeyck.livefootball.ui.competition_detail.matches.MatchesFragment.newInstance(mViewModel.getCompetitionId(), mViewModel.getCompetitionName(), mViewModel.getMatchDay()), MatchesFragment.FRAGMENT_TAG).commit(); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/162/buggy-version/app.src.main.java.tech.joeyck.livefootball.ui.competition_detail.CompetitionActivity.java", "BodyUseAPI": [], "Fixed commit": "c67c603366dce00c1253042e043b29f3747afb40", "Url": "https://api.github.com/repos/s6joui/football-data-android-java", "Date": "2018-12-01T11:07:15Z", "Source Code Diff": "@@ -10,7 +10,6 @@\n import tech.joeyck.livefootball.R;\n import tech.joeyck.livefootball.ui.competition_detail.matches.MatchesFragment;\n import tech.joeyck.livefootball.ui.competition_detail.standings.StandingsFragment;\n-import tech.joeyck.livefootball.ui.competitions.MainViewModelFactory;\n import tech.joeyck.livefootball.utilities.InjectorUtils;\n \n public class CompetitionActivity extends AppCompatActivity {\n@@ -29,6 +28,7 @@ public class CompetitionActivity extends AppCompatActivity {\n \n         @Override\n         public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n+            mViewModel.setActiveTab(item.getItemId());\n             switch (item.getItemId()) {\n                 case R.id.navigation_matches:\n                     mFragmentManager.beginTransaction().replace(R.id.fragment_container,MatchesFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),MatchesFragment.FRAGMENT_TAG).commit();\n@@ -58,7 +58,9 @@ protected void onCreate(Bundle savedInstanceState) {\n         mViewModel = factory.create(CompetitionViewModel.class);\n \n         mFragmentManager = getSupportFragmentManager();\n-        mFragmentManager.beginTransaction().replace(R.id.fragment_container,MatchesFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),MatchesFragment.FRAGMENT_TAG).commit();\n+        if (savedInstanceState == null) {\n+            mFragmentManager.beginTransaction().replace(R.id.fragment_container,MatchesFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),MatchesFragment.FRAGMENT_TAG).commit();\n+        }\n     }\n \n }", "Complete After Code": "package tech.joeyck.livefootball.ui.competition_detail;\n\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.design.widget.BottomNavigationView;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.MenuItem;\n\nimport tech.joeyck.livefootball.R;\nimport tech.joeyck.livefootball.ui.competition_detail.matches.MatchesFragment;\nimport tech.joeyck.livefootball.ui.competition_detail.standings.StandingsFragment;\nimport tech.joeyck.livefootball.utilities.InjectorUtils;\n\npublic class CompetitionActivity extends AppCompatActivity {\n\n    private static final String LOG_TAG = CompetitionActivity.class.getSimpleName();\n\n    public static final String COMPETITION_ID_EXTRA = \"COMPETITION_ID_EXTRA\";\n    public static final String COMPETITION_NAME_EXTRA = \"COMPETITION_NAME_EXTRA\";\n    public static final String COMPETITION_MATCHDAY_EXTRA = \"COMPETITION_MATCHDAY_EXTRA\";\n\n    FragmentManager mFragmentManager;\n    CompetitionViewModel mViewModel;\n\n    private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener\n            = new BottomNavigationView.OnNavigationItemSelectedListener() {\n\n        @Override\n        public boolean onNavigationItemSelected(@NonNull MenuItem item) {\n            mViewModel.setActiveTab(item.getItemId());\n            switch (item.getItemId()) {\n                case R.id.navigation_matches:\n                    mFragmentManager.beginTransaction().replace(R.id.fragment_container,MatchesFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),MatchesFragment.FRAGMENT_TAG).commit();\n                    return true;\n                case R.id.navigation_standings:\n                    mFragmentManager.beginTransaction().replace(R.id.fragment_container,StandingsFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),StandingsFragment.FRAGMENT_TAG).commit();\n                    return true;\n            }\n            return false;\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_competition);\n        BottomNavigationView navigation = findViewById(R.id.navigation);\n        navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener);\n\n        int competitionId = getIntent().getIntExtra(COMPETITION_ID_EXTRA, -1);\n        int matchday = getIntent().getIntExtra(COMPETITION_MATCHDAY_EXTRA, -1);\n        String competitionName = getIntent().getStringExtra(COMPETITION_NAME_EXTRA);\n\n        setTitle(competitionName);\n\n        CompetitionViewModelFactory factory = InjectorUtils.provideCompetitionViewModelFactory(this.getApplicationContext(),competitionId,competitionName,matchday);\n        mViewModel = factory.create(CompetitionViewModel.class);\n\n        mFragmentManager = getSupportFragmentManager();\n        if (savedInstanceState == null) {\n            mFragmentManager.beginTransaction().replace(R.id.fragment_container,MatchesFragment.newInstance(mViewModel.getCompetitionId(),mViewModel.getCompetitionName(),mViewModel.getMatchDay()),MatchesFragment.FRAGMENT_TAG).commit();\n        }\n    }\n\n}\n"},
{"Line": "=>36", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((assigner) == null) { assigner = new edu.iu.dsc.tws.data.api.assigner.LocatableInputSplitAssigner(inputSplits); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/442/buggy-version/twister2.data.src.main.java.edu.iu.dsc.tws.data.api.formatters.SharedTextInputPartitioner.java", "BodyUseAPI": [], "Fixed commit": "ad9b2d4ecfc6a70763220f076820f1dff1a7c3d0", "Url": "https://api.github.com/repos/DSC-SPIDAL/twister2", "Date": "2018-11-19T15:04:43Z", "Source Code Diff": "@@ -19,6 +19,8 @@\n public class SharedTextInputPartitioner extends FileInputPartitioner<String> {\n   private static final long serialVersionUID = 1L;\n \n+  private LocatableInputSplitAssigner assigner;\n+\n   public SharedTextInputPartitioner(Path filePath) {\n     super(filePath);\n   }\n@@ -31,6 +33,9 @@ protected FileInputSplit createSplit(int num, Path file, long start,\n \n   @Override\n   public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit<String>[] inputSplits) {\n-    return new LocatableInputSplitAssigner(inputSplits);\n+    if (assigner == null) {\n+      assigner = new LocatableInputSplitAssigner(inputSplits);\n+    }\n+    return assigner;\n   }\n }", "Complete After Code": "//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\npackage edu.iu.dsc.tws.data.api.formatters;\n\nimport edu.iu.dsc.tws.data.api.assigner.LocatableInputSplitAssigner;\nimport edu.iu.dsc.tws.data.api.splits.FileInputSplit;\nimport edu.iu.dsc.tws.data.api.splits.TextInputSplit;\nimport edu.iu.dsc.tws.data.fs.Path;\n\npublic class SharedTextInputPartitioner extends FileInputPartitioner<String> {\n  private static final long serialVersionUID = 1L;\n\n  private LocatableInputSplitAssigner assigner;\n\n  public SharedTextInputPartitioner(Path filePath) {\n    super(filePath);\n  }\n\n  @Override\n  protected FileInputSplit createSplit(int num, Path file, long start,\n                                       long length, String[] hosts) {\n    return new TextInputSplit(num, file, start, length, hosts);\n  }\n\n  @Override\n  public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit<String>[] inputSplits) {\n    if (assigner == null) {\n      assigner = new LocatableInputSplitAssigner(inputSplits);\n    }\n    return assigner;\n  }\n}\n"},
{"Line": "=>68", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["edu.iu.dsc.tws.common.config.Config.getBooleanValue(Constants.ARGS_SHARED_FILE_SYSTEM)"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (!shared) { this.source = runtime.createInput(cfg, context, new edu.iu.dsc.tws.data.api.formatters.LocalTextInputPartitioner(new edu.iu.dsc.tws.data.fs.Path(directory), context.getParallelism())); }else { this.source = runtime.createInput(cfg, context, new edu.iu.dsc.tws.data.api.formatters.SharedTextInputPartitioner(new edu.iu.dsc.tws.data.fs.Path(directory))); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/442/buggy-version/twister2.examples.src.java.edu.iu.dsc.tws.examples.task.dataparallel.DataParallelTask.java", "BodyUseAPI": [], "Fixed commit": "ad9b2d4ecfc6a70763220f076820f1dff1a7c3d0", "Url": "https://api.github.com/repos/DSC-SPIDAL/twister2", "Date": "2018-11-19T15:04:43Z", "Source Code Diff": "@@ -17,6 +17,7 @@\n \n import edu.iu.dsc.tws.common.config.Config;\n import edu.iu.dsc.tws.data.api.formatters.LocalTextInputPartitioner;\n+import edu.iu.dsc.tws.data.api.formatters.SharedTextInputPartitioner;\n import edu.iu.dsc.tws.data.fs.Path;\n import edu.iu.dsc.tws.data.fs.io.InputSplit;\n import edu.iu.dsc.tws.dataset.DataSource;\n@@ -63,7 +64,13 @@ public void prepare(Config cfg, TaskContext context) {\n     ExecutionRuntime runtime = (ExecutionRuntime) config.get(\n         ExecutorContext.TWISTER2_RUNTIME_OBJECT);\n \n-    this.source = runtime.createInput(cfg, context,\n-        new LocalTextInputPartitioner(new Path(directory), context.getParallelism()));\n+    boolean shared = cfg.getBooleanValue(Constants.ARGS_SHARED_FILE_SYSTEM);\n+    if (!shared) {\n+      this.source = runtime.createInput(cfg, context,\n+          new LocalTextInputPartitioner(new Path(directory), context.getParallelism()));\n+    } else {\n+      this.source = runtime.createInput(cfg, context,\n+          new SharedTextInputPartitioner(new Path(directory)));\n+    }\n   }\n }", "Complete After Code": "//  Licensed under the Apache License, Version 2.0 (the \"License\");\n//  you may not use this file except in compliance with the License.\n//  You may obtain a copy of the License at\n//\n//  http://www.apache.org/licenses/LICENSE-2.0\n//\n//  Unless required by applicable law or agreed to in writing, software\n//  distributed under the License is distributed on an \"AS IS\" BASIS,\n//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//  See the License for the specific language governing permissions and\n//  limitations under the License.\npackage edu.iu.dsc.tws.examples.task.dataparallel;\n\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport edu.iu.dsc.tws.common.config.Config;\nimport edu.iu.dsc.tws.data.api.formatters.LocalTextInputPartitioner;\nimport edu.iu.dsc.tws.data.api.formatters.SharedTextInputPartitioner;\nimport edu.iu.dsc.tws.data.fs.Path;\nimport edu.iu.dsc.tws.data.fs.io.InputSplit;\nimport edu.iu.dsc.tws.dataset.DataSource;\nimport edu.iu.dsc.tws.examples.comms.Constants;\nimport edu.iu.dsc.tws.executor.core.ExecutionRuntime;\nimport edu.iu.dsc.tws.executor.core.ExecutorContext;\nimport edu.iu.dsc.tws.task.api.TaskContext;\nimport edu.iu.dsc.tws.task.batch.BaseBatchSource;\n\npublic class DataParallelTask extends BaseBatchSource {\n  private static final Logger LOG = Logger.getLogger(DataParallelTask.class.getName());\n\n  private static final long serialVersionUID = -1L;\n\n  private DataSource<String, ?> source;\n\n  @Override\n  public void execute() {\n    InputSplit<String> inputSplit = source.getNextSplit(context.taskIndex());\n    int splitCount = 0;\n    while (inputSplit != null) {\n      try {\n        int count = 0;\n        while (!inputSplit.reachedEnd()) {\n          String value = inputSplit.nextRecord(null);\n          LOG.info(\"We read value: \" + value);\n          count += 1;\n        }\n        splitCount += 1;\n        inputSplit = source.getNextSplit(context.taskIndex());\n        LOG.info(\"Finished: \" + context.taskIndex() + \" count: \" + count\n            + \" split: \" + splitCount);\n      } catch (IOException e) {\n        LOG.log(Level.SEVERE, \"Failed to read the input\", e);\n      }\n    }\n  }\n\n  @Override\n  public void prepare(Config cfg, TaskContext context) {\n    super.prepare(cfg, context);\n\n    String directory = cfg.getStringValue(Constants.ARGS_INPUT_DIRECTORY);\n    ExecutionRuntime runtime = (ExecutionRuntime) config.get(\n        ExecutorContext.TWISTER2_RUNTIME_OBJECT);\n\n    boolean shared = cfg.getBooleanValue(Constants.ARGS_SHARED_FILE_SYSTEM);\n    if (!shared) {\n      this.source = runtime.createInput(cfg, context,\n          new LocalTextInputPartitioner(new Path(directory), context.getParallelism()));\n    } else {\n      this.source = runtime.createInput(cfg, context,\n          new SharedTextInputPartitioner(new Path(directory)));\n    }\n  }\n}\n"},
{"Line": "=>138", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfOther]", "Content": "=>if ((Build.VERSION.SDK_INT) >= 28) { versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).getLongVersionCode(); }else { versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode; }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/100/buggy-version/app.src.main.java.com.learnera.app.activities.WelcomeActivity.java", "BodyUseAPI": [], "Fixed commit": "9eb78e04a3fec8e033769bab240ea10dcef4e923", "Url": "https://api.github.com/repos/Kuttipishaash/LearnERA", "Date": "2018-11-18T13:30:30Z", "Source Code Diff": "@@ -7,6 +7,7 @@\n import android.content.pm.PackageManager;\n import android.graphics.Typeface;\n import android.net.Uri;\n+import android.os.Build;\n import android.os.Bundle;\n import android.os.Handler;\n import android.preference.PreferenceManager;\n@@ -134,7 +135,11 @@ private void checkLogin() {\n     void runUpdatesIfNecessary() {\n         long versionCode = 0;\n         try {\n-            versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).getLongVersionCode();\n+            if (Build.VERSION.SDK_INT >= 28) {\n+                versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).getLongVersionCode();\n+            } else {\n+                versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n+            }\n         } catch (PackageManager.NameNotFoundException e) {\n             e.printStackTrace();\n         }", "Complete After Code": "package com.learnera.app.activities;\n\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.graphics.Typeface;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.view.ContextThemeWrapper;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.widget.CheckBox;\nimport android.widget.EditText;\nimport android.widget.FrameLayout;\nimport android.widget.LinearLayout;\nimport android.widget.RelativeLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.learnera.app.R;\nimport com.learnera.app.models.Constants;\nimport com.learnera.app.models.User;\nimport com.learnera.app.utils.Utils;\nimport com.yalantis.guillotine.animation.GuillotineAnimation;\nimport com.yalantis.guillotine.interfaces.GuillotineListener;\n\nimport java.util.Objects;\n\nimport androidx.appcompat.app.AlertDialog;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.appcompat.widget.Toolbar;\nimport androidx.browser.customtabs.CustomTabsIntent;\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\n\npublic class WelcomeActivity extends AppCompatActivity implements View.OnClickListener {\n\n    private static final long RIPPLE_DURATION = 250;\n    private LinearLayout mAnnouncement;\n    private LinearLayout mAttendance;\n    private LinearLayout mLogout;\n    private LinearLayout mSyllabus;\n    private LinearLayout mMarks;\n    private LinearLayout mSeating;\n    private GuillotineAnimation gmenu;\n    private TextView mLoginStatus;\n    private TextView mGuilLoginStatus;\n    private boolean aboutUsOpen = false;\n    private boolean doubleBackToExitPressedOnce = false;\n    private TextView mAppName;\n    private AlertDialog.Builder mSeatingDialogAlert;\n    private SharedPreferences sharedPreferences;\n    private SharedPreferences preferences;\n    @BindView(R.id.toolbar)\n    private Toolbar toolbar;\n\n    //TODO: implement bindview\n    //@BindView(R.id.welcomeRoot)\n    private FrameLayout welcomeRoot;\n\n    //TODO: implement bindview\n    //@BindView(R.id.content_hamburger)\n    private View contentHamburger;\n    private boolean isGmenuOpened = false;\n\n    private String user;\n\n    private User userInfo;\n\n    private String retID;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        runUpdatesIfNecessary();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        //Set login status\n        checkLogin();\n    }\n\n    @Override\n    public void onBackPressed() {\n\n        if (!aboutUsOpen) {\n            if (doubleBackToExitPressedOnce) {\n                super.onBackPressed();\n                finishAffinity();\n                return;\n            }\n            if (isGmenuOpened) {\n                gmenu.close();\n            } else {\n                this.doubleBackToExitPressedOnce = true;\n\n                Toast.makeText(this, \"Please click BACK again to exit\", Toast.LENGTH_SHORT).show();\n\n                new Handler().postDelayed(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        doubleBackToExitPressedOnce = false;\n                    }\n                }, 2000);\n            }\n        } else {\n            super.onBackPressed();\n            finishAffinity();\n\n        }\n    }\n\n    private void checkLogin() {\n        sharedPreferences = getSharedPreferences(Constants.PREFERENCE_FILE, Context.MODE_PRIVATE);\n\n        preferences = PreferenceManager.getDefaultSharedPreferences(getBaseContext());\n\n        if (!User.isLoggedIn(this)) {\n\n            startActivity(new Intent(WelcomeActivity.this, LoginActivity.class));\n            finish();\n        } else {\n            doWhenLoggedIn();\n        }\n    }\n\n    void runUpdatesIfNecessary() {\n        long versionCode = 0;\n        try {\n            if (Build.VERSION.SDK_INT >= 28) {\n                versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).getLongVersionCode();\n            } else {\n                versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;\n            }\n        } catch (PackageManager.NameNotFoundException e) {\n            e.printStackTrace();\n        }\n        if (preferences == null)\n            preferences = PreferenceManager.getDefaultSharedPreferences(getBaseContext());\n        else {\n            if (preferences.getInt(getString(R.string.pref_update_version), 0) != versionCode) {\n                try {\n                    //TODO: Preferences updates for this version here\n                    SharedPreferences.Editor editor = preferences.edit();\n                    editor.clear();\n                    editor.putLong(getString(R.string.pref_update_version), versionCode);\n                    editor.apply();\n                } catch (Throwable t) {\n                    // update failed, or cancelled\n                    t.printStackTrace();\n                }\n            }\n        }\n    }\n\n\n    private void doWhenLoggedIn() {\n        setContentView(R.layout.activity_welcome);\n        initViews();\n        setFonts();\n\n        ButterKnife.bind(this);\n\n        if (toolbar != null) {\n            setSupportActionBar(toolbar);\n            Objects.requireNonNull(getSupportActionBar()).setTitle(null);\n\n        }\n        setupGuillotineMenu();\n\n\n    }\n\n    private void setupGuillotineMenu() {\n        View guillotineMenu = getLayoutInflater().inflate(R.layout.guillotine, null);\n        gmenu = new GuillotineAnimation.GuillotineBuilder(guillotineMenu, guillotineMenu.findViewById(R.id.guillotine_hamburger), contentHamburger)\n                .setStartDelay(RIPPLE_DURATION)\n                .setActionBarViewForAnimation(toolbar)\n                .setClosedOnStart(true)\n                .setGuillotineListener(new GuillotineListener() {\n                    @Override\n                    public void onGuillotineOpened() {\n                        isGmenuOpened = true;\n\n                    }\n\n                    @Override\n                    public void onGuillotineClosed() {\n                        isGmenuOpened = false;\n                    }\n                })\n                .build();\n        welcomeRoot.addView(guillotineMenu);\n        mGuilLoginStatus = findViewById(R.id.guil_logged_user);\n        RelativeLayout groot = findViewById(R.id.guil_root);\n        groot.setOnClickListener(this);\n        LinearLayout glogout = findViewById(R.id.guil_logout);\n        glogout.setOnClickListener(this);\n        LinearLayout gabout_us = findViewById(R.id.guil_about_us);\n        gabout_us.setOnClickListener(this);\n        LinearLayout gshare_app = findViewById(R.id.guil_share_app);\n        gshare_app.setOnClickListener(this);\n        LinearLayout gcontribute = findViewById(R.id.guil_contribute);\n        gcontribute.setOnClickListener(this);\n        LinearLayout gcont_us = findViewById(R.id.guil_contact_us);\n        gcont_us.setOnClickListener(this);\n\n\n        setUserStatus();\n    }\n\n\n    public void setFonts() {\n        //Set font\n        Typeface appName = Typeface.createFromAsset(getAssets(), \"fonts/Pasajero.otf\");\n        Typeface loginName = Typeface.createFromAsset(getAssets(), \"fonts/SourceSansPro-ExtraLight.ttf\");\n//        mLoginStatus.setTypeface(loginName);\n        mAppName.setTypeface(appName);\n    }\n\n    public void setUserStatus() {\n\n        user = sharedPreferences.getString(getString(R.string.pref_user), null);\n\n        String longText;\n        if (user != null) {\n            longText = \"Logged in as : \" + user;\n            mLoginStatus.setText(longText);\n            String[] fname = user.split(\" \", 2);\n            String guillotineStatus = \"Hey, \" + fname[0] + \"!\";\n            mGuilLoginStatus.setText(guillotineStatus);\n\n        } else {\n            longText = getString(R.string.status_not_logged_in);\n            mLoginStatus.setText(longText);\n        }\n    }\n\n    public void initViews() {\n\n        welcomeRoot = findViewById(R.id.welcome_root);\n        contentHamburger = findViewById(R.id.content_hamburger);\n        mLoginStatus = findViewById(R.id.login_status);\n        mAppName = findViewById(R.id.app_name);\n\n        mAnnouncement = findViewById(R.id.drawable_announcement);\n        mAnnouncement.setOnClickListener(this);\n\n        mAttendance = findViewById(R.id.drawable_attendance);\n        mAttendance.setOnClickListener(this);\n\n        mLogout = findViewById(R.id.drawable_logout);\n        mLogout.setOnClickListener(this);\n\n        mSyllabus = findViewById(R.id.drawable_syllabus);\n        mSyllabus.setOnClickListener(this);\n\n        mMarks = findViewById(R.id.drawable_marks);\n        mMarks.setOnClickListener(this);\n\n        mSeating = findViewById(R.id.drawable_seating_plan);\n        mSeating.setOnClickListener(this);\n\n\n        mSeatingDialogAlert = new AlertDialog.Builder(new ContextThemeWrapper(this, R.style.AlertDialogCustom));\n        mSeatingDialogAlert.setTitle(getString(R.string.dialog_warn_seating_title));\n        mSeatingDialogAlert.setMessage(getString(R.string.dialog_warn_seating_description));\n        mSeatingDialogAlert.setPositiveButton(getString(R.string.btn_ok), new DialogInterface.OnClickListener() {\n            @Override\n            public void onClick(DialogInterface dialog, int which) {\n                dialog.dismiss();\n                openSeatingPdf();\n            }\n        });\n    }\n\n    public void openSeatingPdf() {\n        userInfo = User.getLoginInfo(WelcomeActivity.this);\n\n\n        retID = \"RET\" + userInfo.getUserName().substring(1, 3) + userInfo.getDept().toUpperCase() +\n                userInfo.getUserName().substring(5);\n\n        LayoutInflater inflater = getLayoutInflater();\n        View dialoglayout = inflater.inflate(R.layout.dialog_ktu_id, null);\n        AlertDialog.Builder ktuIdDialog = new AlertDialog.Builder(new ContextThemeWrapper(this, R.style.AlertDialogCustom));\n        ktuIdDialog.setView(dialoglayout);\n        final EditText input = dialoglayout.findViewById(R.id.et_ktu_id_dki);\n        final CheckBox checkBox = dialoglayout.findViewById(R.id.cb_remember_ktu_id_dki);\n        ktuIdDialog.setTitle(getString(R.string.dialog_seating_ktu_id_confirm));\n        setIDField(input);\n        ktuIdDialog.setPositiveButton(getString(R.string.btn_confirm),\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int which) {\n                        retID = input.getText().toString().toUpperCase();\n                        if (checkBox.isChecked()) {\n                            SharedPreferences.Editor editor = sharedPreferences.edit();\n                            editor.putString(getString(R.string.pref_ktu_id), retID);\n                            editor.apply();\n                        }\n                        launchChromeCustomTab();\n                    }\n                });\n\n        ktuIdDialog.setNegativeButton(getString(R.string.btn_cancel),\n                new DialogInterface.OnClickListener() {\n                    public void onClick(DialogInterface dialog, int which) {\n                        dialog.cancel();\n                    }\n                });\n\n        ktuIdDialog.show();\n    }\n\n    private void setIDField(EditText input) {\n        String rememberedKTUId = sharedPreferences.getString(getString(R.string.pref_ktu_id), \"\");\n        if (rememberedKTUId.equals(\"\")) {\n            input.setText(retID);\n        } else {\n            input.setText(rememberedKTUId);\n        }\n    }\n\n    private void launchChromeCustomTab() {\n\n        String completeUrl = Constants.seatPlanURL + retID + \".pdf\";\n        //Launch chrome custom tab\n        CustomTabsIntent.Builder builder = new CustomTabsIntent.Builder();\n        CustomTabsIntent intent = builder.build();\n        builder.setToolbarColor(getResources().getColor(R.color.md_red_700));\n        builder.setStartAnimations(WelcomeActivity.this, R.anim.slide_in_right, R.anim.slide_out_left);\n        builder.setExitAnimations(WelcomeActivity.this, R.anim.slide_in_left, R.anim.slide_out_right);\n        intent.launchUrl(WelcomeActivity.this, Uri.parse(completeUrl));\n    }\n\n    @Override\n    public void onClick(View v) {\n\n        switch (v.getId()) {\n\n            case R.id.drawable_seating_plan:\n                launchSeatingPlan();\n                break;\n            case R.id.drawable_marks:\n                startActivity(new Intent(WelcomeActivity.this, MarksActivity.class));\n                break;\n            case R.id.drawable_syllabus:\n                startActivity(new Intent(WelcomeActivity.this, SyllabusActivity.class));\n                break;\n            case R.id.drawable_logout:\n                User.logout(WelcomeActivity.this);\n                break;\n            case R.id.drawable_attendance:\n                startActivity(new Intent(WelcomeActivity.this, AttendanceActivity.class));\n                break;\n            case R.id.drawable_announcement:\n                startActivity(new Intent(WelcomeActivity.this, AnnouncementsActivity.class));\n                break;\n            case R.id.guil_root:\n                gmenu.close();\n                break;\n            case R.id.guil_contact_us:\n                gmenu.close();\n                launchContactUs();\n                break;\n            case R.id.guil_share_app:\n                gmenu.close();\n                shareApp();\n                break;\n            case R.id.guil_contribute:\n                gmenu.close();\n                Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://github.com/Kuttipishaash/LearnERA\"));\n                WelcomeActivity.this.startActivity(browserIntent);\n                break;\n            case R.id.guil_about_us:\n                gmenu.close();\n                aboutUsOpen = true;\n                Utils.showAbout(this);\n                break;\n            case R.id.guil_logout:\n                gmenu.close();\n                User.logout(WelcomeActivity.this);\n                break;\n\n\n        }\n    }\n\n    private void shareApp() {\n        String shareText = \"Download LearnERA from Google Play and stay updated : \" + getString(R.string.app_link);\n        Intent sharingIntent = new Intent(Intent.ACTION_SEND);\n        sharingIntent.setType(\"text/plain\");\n        sharingIntent.putExtra(Intent.EXTRA_TEXT, shareText);\n        WelcomeActivity.this.startActivity(sharingIntent);\n    }\n\n    private void launchContactUs() {\n        Intent sendIntent = new Intent(Intent.ACTION_SENDTO);\n        sendIntent.setData(Uri.parse(\"mailto:\"));\n        sendIntent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.feedback_mail_title));\n        sendIntent.putExtra(Intent.EXTRA_EMAIL, new String[]{getString(R.string.feedback_mail_address)});\n        sendIntent.putExtra(Intent.EXTRA_TEXT, \"\");\n        startActivity(sendIntent);\n    }\n\n    private void launchSeatingPlan() {\n        boolean alertFlag = preferences.getBoolean(getString(R.string.pref_seating_dialog_enabled), true);\n\n        if (alertFlag) {\n            SharedPreferences.Editor editor = preferences.edit();\n            editor.putBoolean(getString(R.string.pref_seating_dialog_enabled), false);\n            editor.apply();\n            mSeatingDialogAlert.show();\n        } else {\n            openSeatingPdf();\n        }\n    }\n}"},
{"Line": "=>877", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": [], "Type": "Insert", "BugDetectionTag": "[IfDep]", "Content": "=>if (((textviewNoAction.getVisibility()) == (android.view.View.VISIBLE)) && ((tmpStatuses.size()) > 0)) { textviewNoAction.setVisibility(View.GONE); lv_status.setVisibility(View.VISIBLE); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/641/buggy-version/app.src.main.java.fr.gouv.etalab.mastodon.fragments.DisplayStatusFragment.java", "BodyUseAPI": ["android.widget.RelativeLayout.setVisibility(View.GONE)"], "Fixed commit": "8a361516f18fda48892bfe63cc7ee462a5499fe7", "Url": "https://api.github.com/repos/stom79/mastalab", "Date": "2018-12-26T15:18:13Z"},
{"Line": "=>179", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["javax.swing.JList<engine.Service>.getSelectedValue()"], "Type": "Insert", "BugDetectionTag": "[IfRet, IfNull]", "Content": "=>if (s != null) { if (s instanceof engine.TwitterService) { new ui.TwitterEditionWindow(((engine.TwitterService) (s))); }else if (s instanceof engine.FacebookService) { }else { new ui.ServiceEditionWindow(s); } }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/386/buggy-version/ES_BomDiaAcademia.src.ui.ServicePanel.java", "BodyUseAPI": [], "Fixed commit": "75dcb80cad4b0d9ffbc624db320ccc355eee5b98", "Url": "https://api.github.com/repos/radds-iscteiul/ES1-2018-METI-PL-85", "Date": "2018-11-03T18:12:07Z", "Source Code Diff": "@@ -176,12 +176,14 @@ public void actionPerformed(ActionEvent e) {\n \t\t\t@Override\r\n \t\t\tpublic void actionPerformed(ActionEvent e) {\r\n \t\t\t\tService s = (Service)lista.getSelectedValue();\r\n-\t\t\t\tif(s instanceof TwitterService) {\r\n-\t\t\t\t\tnew TwitterEditionWindow((TwitterService)s);\r\n-\t\t\t\t} else if(s instanceof FacebookService) {\r\n-\t\t\t\t\t\r\n-\t\t\t\t} else { //Email\r\n-\t\t\t\t\tnew ServiceEditionWindow(s);\r\n+\t\t\t\tif(s != null) {\r\n+\t\t\t\t\tif(s instanceof TwitterService) {\r\n+\t\t\t\t\t\tnew TwitterEditionWindow((TwitterService)s);\r\n+\t\t\t\t\t} else if(s instanceof FacebookService) {\r\n+\t\t\t\t\t\t\r\n+\t\t\t\t\t} else { //Email\r\n+\t\t\t\t\t\tnew ServiceEditionWindow(s);\r\n+\t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t});\r", "Complete After Code": "package ui;\r\n\r\nimport java.awt.BorderLayout;\r\nimport java.awt.Dimension;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.event.MouseListener;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.swing.JButton;\r\nimport javax.swing.JList;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JScrollPane;\r\nimport javax.swing.event.ListSelectionEvent;\r\nimport javax.swing.event.ListSelectionListener;\r\n\r\nimport engine.Controller;\r\nimport engine.FacebookService;\r\nimport engine.MyMessage;\r\nimport engine.Service;\r\nimport engine.ServiceType;\r\nimport engine.TwitterService;\r\nimport server.FacebookServer;\r\nimport server.MailServer;\r\nimport server.TwitterServer;\r\n/**\r\n * \r\n * @author Rafael Dias\r\n *\r\n */\r\npublic class ServicePanel extends JPanel{\r\n\t\r\n\tprivate MainWindow mainWindow;\r\n\t\r\n\tpublic JList<Service> lista;\r\n\tprivate JButton pull = new JButton(\"Get messages\");\r\n\tpublic JButton toggle = new JButton(\"Enable\");\r\n\tpublic JButton editService = new JButton(\"Edit\");\r\n\t\r\n\tpublic ServicePanel(MainWindow mw) {\r\n\t\tsuper();\r\n\t\tthis.setLayout(new BorderLayout());\r\n\t\tmainWindow = mw;\r\n\t\t\r\n\t\tJPanel buttons = new JPanel();\r\n\t\tpull.setPreferredSize(new Dimension(150,25));\r\n\t\ttoggle.setPreferredSize(new Dimension(100,25));\r\n\t\teditService.setPreferredSize(new Dimension(100, 25));\r\n\t\tbuttons.add(pull);\r\n\t\tbuttons.add(toggle);\r\n\t\tbuttons.add(editService);\r\n\t\tthis.add(buttons,BorderLayout.SOUTH);\r\n\t\tthis.setVisible(true);\r\n\t\t\r\n\t\tthis.setDefaultList(Controller.getInstance().getAllServices());\r\n\t\tthis.setListeners();\r\n\t\t\r\n\t}\r\n\tprivate void setDefaultList(ArrayList<Service> s){\r\n\t\tService [] values = new Service[s.size()];\r\n\t\tint i = 0;\r\n\t\tfor(Service service : s){\r\n\t\t\tvalues[i] = service;\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tlista = new JList(values);\r\n\t\tlista.setFixedCellHeight(25);\r\n\t\tJScrollPane scrollPane = new JScrollPane(lista);\r\n\t\tthis.add(scrollPane,BorderLayout.CENTER);\r\n\t\tlista.setCellRenderer(new MyCellRenderer());\r\n\t}\r\n\t\r\n\tprivate void setListeners() {\r\n\t\ttoggle.addActionListener(new ActionListener() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\tService selected = ServicePanel.this.lista.getSelectedValue();\r\n\t\t\t\tif(!ServicePanel.this.lista.isSelectionEmpty()) {\r\n\t\t\t\t\tController.getInstance().toogleServiceState(selected);\r\n\t\t\t\t\tServicePanel.this.lista.repaint();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\ttoggle.addMouseListener(new MouseListener() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void mouseReleased(MouseEvent e) {\r\n\t\t\t\tif(!ServicePanel.this.lista.isSelectionEmpty()) {\r\n\t\t\t\t\tif(ServicePanel.this.lista.getSelectedValue().isAtive()){\r\n\t\t\t\t\t\tServicePanel.this.toggle.setText(\"Disable\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tServicePanel.this.toggle.setText(\"Enable\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void mousePressed(MouseEvent e) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void mouseExited(MouseEvent e) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void mouseEntered(MouseEvent e) {\r\n\t\t\t\tif(!ServicePanel.this.lista.isSelectionEmpty()) {\r\n\t\t\t\t\tif(ServicePanel.this.lista.getSelectedValue().isAtive()){\r\n\t\t\t\t\t\tServicePanel.this.toggle.setText(\"Disable\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tServicePanel.this.toggle.setText(\"Enable\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void mouseClicked(MouseEvent e) {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\tlista.addListSelectionListener(new ListSelectionListener() {\r\n\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void valueChanged(ListSelectionEvent e) {\r\n\t\t\t\tif(ServicePanel.this.lista.getSelectedValue().isAtive()){\r\n\t\t\t\t\tServicePanel.this.toggle.setText(\"Disable\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tServicePanel.this.toggle.setText(\"Enable\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tpull.addActionListener(new ActionListener() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\t List<Service> s = Controller.getInstance().getAtiveServices();\r\n\t\t\t\t System.out.println(\"Servi\u00e7os Ativos: \");\r\n\t\t\t\t List<MyMessage> messages = new ArrayList<MyMessage>();\r\n\t\t\t\t for (Service service : s) {\r\n\t\t\t\t\tif(service.getName() == ServiceType.TWITTER) {\r\n\t\t\t\t\t\tTwitterService twitterService = (TwitterService) service;\r\n\t\t\t\t\t\tTwitterServer ts = new TwitterServer(twitterService);\r\n\t\t\t\t\t\tSystem.out.println(twitterService.getWatch());\r\n\t\t\t\t\t\tmessages.addAll(ts.getTweetsFromUser(twitterService.getWatch(), 10));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(service.getName() == ServiceType.FACEBOOK) {\r\n\t\t\t\t\t\tFacebookService fbService = (FacebookService) service;\r\n\t\t\t\t\t\tFacebookServer fs = new FacebookServer();\r\n\t\t\t\t\t\tmessages.addAll(fs.getTimelinePosts());\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(service.getName() == ServiceType.EMAIL) {\r\n\t\t\t\t\t\tMailServer emailServer = new MailServer(service.getUser(),service.getPassword());\r\n\t\t\t\t\t\tmessages.addAll(emailServer.receiveEmail(service.getUser(), service.getPassword()));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t Controller.getInstance().addAllMessages(messages);\r\n\t\t\t\t mainWindow.updateMessageListUI();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t});\r\n\t\teditService.addActionListener(new ActionListener() {\r\n\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\tService s = (Service)lista.getSelectedValue();\r\n\t\t\t\tif(s != null) {\r\n\t\t\t\t\tif(s instanceof TwitterService) {\r\n\t\t\t\t\t\tnew TwitterEditionWindow((TwitterService)s);\r\n\t\t\t\t\t} else if(s instanceof FacebookService) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else { //Email\r\n\t\t\t\t\t\tnew ServiceEditionWindow(s);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t\r\n}\r\n"},
{"Line": "=>78", "parseTypeFail": "sucess", "Pattern": "UNKNOWN=>If", "RetCheckAPI": ["hu.inf.unideb.fridges.smartfridge.controller.RecipeService.findByNameAndIngredientAndFamily(java.lang.String,java.lang.String,java.lang.String)"], "Type": "Insert", "BugDetectionTag": "[IfRet]", "Content": "=>if (recipes.isEmpty()) { java.util.List<hu.inf.unideb.fridges.smartfridge.controller.Recipe> backupList = recipeService.findAll(); recipes = ((backupList.size()) >= 10) ? backupList.subList(0, 10) : backupList; response.put(\"status\", \"Sajnos nem tal\u00e1ltunk ilyen receptet :(\"); }else { response.put(\"status\", \"success\"); }", "FileName": "/home/PATH/BugDetectionProject/3Clone/NewDown201811-12/All/V177/725/buggy-version/src.main.java.hu.inf.unideb.fridges.smartfridge.controller.RecipeController.java", "BodyUseAPI": [], "Fixed commit": "90e3f1cf5dca1e1df039bbfefcbe71ab22fe8c92", "Url": "https://api.github.com/repos/Csszabi98/Smartfridge", "Date": "2018-12-11T21:50:56Z"}]}
